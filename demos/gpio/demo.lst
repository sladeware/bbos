0000: 00 b4 c4 04 ' Frequency: 80000000 Hz
0004: 6f          ' XTAL mode
0005: 66          ' Checksum
0006: 10 00       ' Base of program
0008: 9c 5f       ' Base of variables
000a: b4 5f       ' Base of stack
000c: 2c 00       ' Initial program counter
000e: d4 5f       ' Initial stack pointer

'******************************************************************************
'                              lmm_default.spin                                
'******************************************************************************

'=================================== CONs =====================================
_clkmode = 1032
_xinfreq = 5000000
_stack = 50
START_SCREEN = -1
START_KBD = -1
START_MOUSE = -1
'=============================== Object Header ================================
0010: 6c 00 02 05 ' 108 bytes, 2-1 methods, 5 object pointers
0014: 1c 00 1c 00 ' ptr #1 to $002c: PUB Start (locals size: 28)
0018: 6c 00 00 00 ' ptr #2 to $007c: OBJ Catalina : Catalina.spin (VAR offset: 0)
001c: 04 5f 00 00 ' ptr #3 to $5f14: OBJ Common : Catalina_Common.spin (VAR offset: 0)
0020: 0c 3e 00 00 ' ptr #4 to $3e1c: OBJ Cogstore : Catalina_Cogstore.spin (VAR offset: 0)
0024: b8 41 00 00 ' ptr #5 to $41c8: OBJ Kernel : Catalina_LMM.spin (VAR offset: 0)
0028: 60 49 00 00 ' ptr #6 to $4970: OBJ HMI : Catalina_HMI_Plugin_HiRes_Tv.spin (VAR offset: 0)
'=========================== Method #1: PUB Start =============================
'PUB Start : ok | cog, ALLOC, HMI_DATA, IO_BLOCK, Proxy_Lock, Server_CPU, s
'------------------------------------------------------------------------------
  Common.InitializeRegistry
'------------------------------------------------------------------------------
002c: 01             FRAME	Call without return value	
002d: 06 03 01       CALLOBJ	3:1
'------------------------------------------------------------------------------
  ALLOC := Common#REQUESTS
'------------------------------------------------------------------------------
0030: 39 7e 9c       PUSH#k2	32412
0033: 69             POP  	Locals+8
'------------------------------------------------------------------------------
  ok         := TRUE
'------------------------------------------------------------------------------
0034: 34             PUSH#-1	
0035: 61             POP  	Locals+0
'------------------------------------------------------------------------------
  Proxy_Lock := -1
'------------------------------------------------------------------------------
0036: 34             PUSH#-1	
0037: 75             POP  	Locals+20
'------------------------------------------------------------------------------
  s := CogStore.Size
'------------------------------------------------------------------------------
0038: 00             FRAME	Call with return value	
0039: 06 04 06       CALLOBJ	4:6
003c: 7d             POP  	Locals+28
'------------------------------------------------------------------------------
  if (s => 0)
'------------------------------------------------------------------------------
003d: 7c             PUSH 	Locals+28
003e: 35             PUSH#0	
003f: fe             GE   	
0040: 0a 07          JPF  	.+7 (dest:$0049)
'------------------------------------------------------------------------------
    ALLOC := ALLOC - s*4
'------------------------------------------------------------------------------
0042: 68             PUSH 	Locals+8
0043: 7c             PUSH 	Locals+28
0044: 37 01          PUSH#kp	4 ($4)
0046: f4             MPY  	
0047: ed             SUB  	
0048: 69             POP  	Locals+8
'------------------------------------------------------------------------------
  CogStore.Setup(ALLOC)
'------------------------------------------------------------------------------
0049: 01             FRAME	Call without return value	
004a: 68             PUSH 	Locals+8
004b: 06 04 07       CALLOBJ	4:7
'------------------------------------------------------------------------------
  CogStore.Stop
'------------------------------------------------------------------------------
004e: 01             FRAME	Call without return value	
004f: 06 04 03       CALLOBJ	4:3
'------------------------------------------------------------------------------
  HMI_DATA := ALLOC - 4 * HMI#DATASIZE
'------------------------------------------------------------------------------
0052: 68             PUSH 	Locals+8
0053: 37 01          PUSH#kp	4 ($4)
0055: 39 02 99       PUSH#k2	665
0058: f4             MPY  	
0059: ed             SUB  	
005a: 6d             POP  	Locals+12
'------------------------------------------------------------------------------
  ALLOC    := HMI_DATA
'------------------------------------------------------------------------------
005b: 6c             PUSH 	Locals+12
005c: 69             POP  	Locals+8
'------------------------------------------------------------------------------
  if ok
'------------------------------------------------------------------------------
005d: 60             PUSH 	Locals+0
005e: 0a 0c          JPF  	.+12 (dest:$006c)
'------------------------------------------------------------------------------
    ok := HMI.Start(Common#REGISTRY, HMI_DATA, START_KBD, START_MOUSE, START_SCREEN)
'------------------------------------------------------------------------------
0060: 00             FRAME	Call with return value	
0061: 39 7e dc       PUSH#k2	32476
0064: 6c             PUSH 	Locals+12
0065: 34             PUSH#-1	
0066: 34             PUSH#-1	
0067: 34             PUSH#-1	
0068: 06 06 02       CALLOBJ	6:2
006b: 61             POP  	Locals+0
'------------------------------------------------------------------------------
  Kernel.Run (Common#REGISTRY, Common#REQUESTS, Catalina.Base, ALLOC)
'------------------------------------------------------------------------------
006c: 01             FRAME	Call without return value	
006d: 39 7e dc       PUSH#k2	32476
0070: 39 7e 9c       PUSH#k2	32412
0073: 00             FRAME	Call with return value	
0074: 06 02 01       CALLOBJ	2:1
0077: 68             PUSH 	Locals+8
0078: 06 05 02       CALLOBJ	5:2
007b: 32             RETURN	

'******************************************************************************
'                                Catalina.spin                                 
'******************************************************************************

'=================================== CONs =====================================
SEGMENT_LAYOUT = 0
'=============================== Object Header ================================
007c: a0 3d 02 00 ' 15776 bytes, 2-1 methods, 0 object pointers
0080: 98 3d 00 00 ' ptr #1 to $3e14: PUB Base (locals size: 0)
'================================ DAT Section =================================
0084(0000):             '         org  0
0084(0000): 00 00 00 00 '         long 0          '$00
0088(0001): 00 00 00 00 '         long 0          '$01
008c(0002): 00 00 3c 5c ' INIT    jmp  0          '$02
0090(0003): 00 00 3c 5c ' LODL    jmp  0          '$03
0094(0004): 00 00 3c 5c ' LODA    jmp  0          '$04
0098(0005): 00 00 3c 5c ' LODF    jmp  0          '$05
009c(0006): 00 00 3c 5c ' PSHL    jmp  0          '$06
00a0(0007): 00 00 3c 5c ' PSHB    jmp  0          '$07
00a4(0008): 00 00 3c 5c ' CPYB    jmp  0          '$08
00a8(0009): 00 00 3c 5c ' NEWF    jmp  0          '$09
00ac(000a): 00 00 3c 5c ' RETF    jmp  0          '$0a
00b0(000b): 00 00 3c 5c ' CALA    jmp  0          '$0b
00b4(000c): 00 00 3c 5c ' RETN    jmp  0          '$0c
00b8(000d): 00 00 3c 5c ' CALI    jmp  0          '$0d
00bc(000e): 00 00 3c 5c ' JMPA    jmp  0          '$0e
00c0(000f): 00 00 3c 5c ' JMPI    jmp  0          '$0f
00c4(0010): 00 00 3c 5c ' DIVS    jmp  0          '$10
00c8(0011): 00 00 3c 5c ' DIVU    jmp  0          '$11
00cc(0012): 00 00 3c 5c ' MULT    jmp  0          '$12
00d0(0013): 00 00 3c 5c ' BR_Z    jmp  0          '$13
00d4(0014): 00 00 3c 5c ' BRNZ    jmp  0          '$14
00d8(0015): 00 00 3c 5c ' BRAE    jmp  0          '$15
00dc(0016): 00 00 3c 5c ' BR_A    jmp  0          '$16
00e0(0017): 00 00 3c 5c ' BRBE    jmp  0          '$17
00e4(0018): 00 00 3c 5c ' BR_B    jmp  0          '$18
00e8(0019): 00 00 3c 5c ' SYSP    jmp  0          '$19
00ec(001a): 00 00 3c 5c ' PSHA    jmp  0          '$1a
00f0(001b): 00 00 3c 5c ' FADD    jmp  0          '$1b
00f4(001c): 00 00 3c 5c ' FSUB    jmp  0          '$1c
00f8(001d): 00 00 3c 5c ' FMUL    jmp  0          '$1d
00fc(001e): 00 00 3c 5c ' FDIV    jmp  0          '$1e
0100(001f): 00 00 3c 5c ' FCMP    jmp  0          '$1f
0104(0020): 00 00 3c 5c ' FLIN    jmp  0          '$20
0108(0021): 00 00 3c 5c ' INFL    jmp  0          '$21
010c(0022): 00 00 3c 5c ' PSHM    jmp  0          '$22
0110(0023): 00 00 3c 5c ' POPM    jmp  0          '$23
0114(0024): 00 00 3c 5c ' PSHF    jmp  0          '$24
0118(0025): 00 00 3c 5c ' RLNG    jmp  0          '$25
011c(0026): 00 00 3c 5c ' RWRD    jmp  0          '$26
0120(0027): 00 00 3c 5c ' RBYT    jmp  0          '$27
0124(0028): 00 00 3c 5c ' WLNG    jmp  0          '$28
0128(0029): 00 00 3c 5c ' WWRD    jmp  0          '$29
012c(002a): 00 00 3c 5c ' WBYT    jmp  0          '$2a
0130(002b): 00 00 00 00 ' PC      long 0          '$2b
0134(002c): 00 00 00 00 ' SP      long 0          '$2c
0138(002d): 00 00 00 00 ' FP      long 0          '$2d
013c(002e): 00 00 00 00 ' RI      long 0          '$2e
0140(002f): 00 00 00 00 ' BC      long 0          '$2f
0144(0030): 00 00 00 00 ' BA      long 0          '$30
0148(0031): 00 00 00 00 ' BZ      long 0          '$31
014c(0032): 00 00 00 00 ' CS      long 0          '$32
0150(0033): 00 00 00 00 ' r0      long 0          '$33
0154(0034): 00 00 00 00 ' r1      long 0          '$34
0158(0035): 00 00 00 00 ' r2      long 0          '$35
015c(0036): 00 00 00 00 ' r3      long 0          '$36
0160(0037): 00 00 00 00 ' r4      long 0          '$37
0164(0038): 00 00 00 00 ' r5      long 0          '$38
0168(0039): 00 00 00 00 ' r6      long 0          '$39
016c(003a): 00 00 00 00 ' r7      long 0          '$3a
0170(003b): 00 00 00 00 ' r8      long 0          '$3b
0174(003c): 00 00 00 00 ' r9      long 0          '$3c
0178(003d): 00 00 00 00 ' r10     long 0          '$3d
017c(003e): 00 00 00 00 ' r11     long 0          '$3e
0180(003f): 00 00 00 00 ' r12     long 0          '$3f
0184(0040): 00 00 00 00 ' r13     long 0          '$40
0188(0041): 00 00 00 00 ' r14     long 0          '$41
018c(0042): 00 00 00 00 ' r15     long 0          '$42
0190(0043): 00 00 00 00 ' r16     long 0          '$43
0194(0044): 00 00 00 00 ' r17     long 0          '$44
0198(0045): 00 00 00 00 ' r18     long 0          '$45
019c(0046): 00 00 00 00 ' r19     long 0          '$46
01a0(0047): 00 00 00 00 ' r20     long 0          '$47
01a4(0048): 00 00 00 00 ' r21     long 0          '$48
01a8(0049): 00 00 00 00 ' r22     long 0          '$49
01ac(004a): 00 00 00 00 ' r23     long 0          '$4a
01b0(004b): 00 00 00 80 ' Bit31   long  $80000000 '$4b
01b4(004c): ff ff ff ff ' all_1s  long  $ffffffff '$4c
01b8(004d): ff 00 00 00 ' cviu_m1 long  $000000ff '$4d
01bc(004e): ff ff 00 00 ' cviu_m2 long  $0000ffff '$4e
01c0(004f): 00 00 00 ff ' top8    long  $ff000000 '$4f   ' top 8 bits bitmask
01c4(0050): ff ff ff 00 ' low24   long  $00ffffff '$50   ' low 24 bits bitmask
01c8(0051): 94 3d 00 00 ' init_BZ long  @sbrkinit '$51   ' end of code / start of heap
01cc(0052): a4 08 00 00 ' init_PC long  @C_main   '$52   ' the initial PC
01d0(0053):             ' seglayout
01d0(0053): 00 00 00 00 '         long  SEGMENT_LAYOUT
01d4(0054):             ' segtable
01d4(0054): 6c 01 00 00 '         long  @Catalina_Code
01d8(0055): e0 31 00 00 '         long  @Catalina_Cnst
01dc(0056): 08 34 00 00 '         long  @Catalina_Init
01e0(0057): b8 34 00 00 '         long  @Catalina_Data
01e4(0058): 98 3d 00 00 '         long  @Catalina_Ends
01e8(0059):             '  long ' align long
01e8(0059):             ' Catalina_Code
01e8(0059):             '  long ' align long
01e8(0059):             '  long ' align long
01e8(0059):             ' C__exit
01e8(0059): 80 66 fc a0 '  mov r0,#$80
01ec(005a): 00 66 7c 0c '  clkset r0
01f0(005b):             ' C__sys_plugin
01f0(005b): 19 00 7c 5c '  jmp #SYSP
01f4(005c): 0c 00 7c 5c '  jmp #RETN
01f8(005d):             ' C_arg_setup
01f8(005d): 04 00 7c 5c '  jmp #LODA                 ' point to argv address
01fc(005e): 98 01 00 00 '  long @C_argv_locn
0200(005f): 2e 5e bc 08 '  rdlong BC,RI
0204(0060): 2f 6c bc 04 '  rdword r3,BC              ' load argc
0208(0061): 02 5e fc 80 '  add BC,#2
020c(0062): 2f 6a bc 04 '  rdword r2,BC              ' load argv
0210(0063): 0c 00 7c 5c '  jmp #RETN                 ' done
0214(0064):             ' C_argv_locn
0214(0064): 30 7f 00 00 '  long $7F30                ' must match value in Catalina_Common_Input.spin
0218(0065):             ' C_debug_init
0218(0065): 0c 00 7c 5c '  jmp #RETN                 ' done
021c(0066):             '  long ' align long
021c(0066):             ' C___bbos_port_init ' <symbol:__bbos_port_init>
021c(0066): 22 00 7c 5c '  jmp #PSHM
0220(0067): 00 0c 02 00 '  long $20c00 ' save registers
0224(0068): 35 88 bc a0 '  mov r17, r2 ' reg var <- reg arg
0228(0069): 0c 7c fc a0 '  mov r11, #12 ' reg <- coni
022c(006a): 44 7a bc a0 '  mov r10, r17 ' CVII
0230(006b): 44 7a bc a0 '  mov r10, r17 ' CVII
0234(006c): 10 7a fc 2c '  shl r10, #16
0238(006d): 10 7a fc 38 '  sar r10, #16 ' sign extend
023c(006e): 3e 66 bc a0 '  mov r0, r11 ' setup r0/r1 (2)
0240(006f): 3d 68 bc a0 '  mov r1, r10 ' setup r0/r1 (2)
0244(0070): 12 00 7c 5c '  jmp #MULT ' MULT(I/U)
0248(0071): 04 00 7c 5c '  jmp #LODA
024c(0072): b8 34 00 00 '  long @C_port_table
0250(0073): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
0254(0074): 33 7c bc a0 '  mov r11, r0 ' ADDI/P
0258(0075): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (3)
025c(0076): 04 00 7c 5c '  jmp #LODA
0260(0077): e0 31 00 00 '  long @C___bbos_port_init_L000005
0264(0078): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
0268(0079): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
026c(007a): 0c 7c fc a0 '  mov r11, #12 ' reg <- coni
0270(007b): 44 7a bc a0 '  mov r10, r17 ' CVII
0274(007c): 44 7a bc a0 '  mov r10, r17 ' CVII
0278(007d): 10 7a fc 2c '  shl r10, #16
027c(007e): 10 7a fc 38 '  sar r10, #16 ' sign extend
0280(007f): 3e 66 bc a0 '  mov r0, r11 ' setup r0/r1 (2)
0284(0080): 3d 68 bc a0 '  mov r1, r10 ' setup r0/r1 (2)
0288(0081): 12 00 7c 5c '  jmp #MULT ' MULT(I/U)
028c(0082): 04 00 7c 5c '  jmp #LODA
0290(0083): bc 34 00 00 '  long @C_port_table+4
0294(0084): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
0298(0085): 33 7c bc a0 '  mov r11, r0 ' ADDI/P
029c(0086): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (3)
02a0(0087): 04 00 7c 5c '  jmp #LODA
02a4(0088): e0 31 00 00 '  long @C___bbos_port_init_L000005
02a8(0089): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
02ac(008a): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
02b0(008b): 0c 7c fc a0 '  mov r11, #12 ' reg <- coni
02b4(008c): 44 7a bc a0 '  mov r10, r17 ' CVII
02b8(008d): 44 7a bc a0 '  mov r10, r17 ' CVII
02bc(008e): 10 7a fc 2c '  shl r10, #16
02c0(008f): 10 7a fc 38 '  sar r10, #16 ' sign extend
02c4(0090): 3e 66 bc a0 '  mov r0, r11 ' setup r0/r1 (2)
02c8(0091): 3d 68 bc a0 '  mov r1, r10 ' setup r0/r1 (2)
02cc(0092): 12 00 7c 5c '  jmp #MULT ' MULT(I/U)
02d0(0093): 04 00 7c 5c '  jmp #LODA
02d4(0094): c0 34 00 00 '  long @C_port_table+8
02d8(0095): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
02dc(0096): 33 7c bc a0 '  mov r11, r0 ' ADDI/P
02e0(0097): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (3)
02e4(0098): 01 7a fc a0 '  mov r10, #1 ' reg <- coni
02e8(0099): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
02ec(009a): 00 66 fc a0 '  mov r0, #0 ' RET coni
02f0(009b): 23 00 7c 5c '  jmp #POPM
02f4(009c): 00 0c 02 00 '  long $20c00 ' restore registers
02f8(009d): 0c 00 7c 5c '  jmp #RETN
02fc(009e):             '  long ' align long
02fc(009e):             ' C___bbos_port_is_empty ' <symbol:__bbos_port_is_empty>
02fc(009e): 22 00 7c 5c '  jmp #PSHM
0300(009f): 00 0c 03 00 '  long $30c00 ' save registers
0304(00a0): 35 88 bc a0 '  mov r17, r2 ' reg var <- reg arg
0308(00a1): 0c 7c fc a0 '  mov r11, #12 ' reg <- coni
030c(00a2): 44 7a bc a0 '  mov r10, r17 ' CVII
0310(00a3): 44 7a bc a0 '  mov r10, r17 ' CVII
0314(00a4): 10 7a fc 2c '  shl r10, #16
0318(00a5): 10 7a fc 38 '  sar r10, #16 ' sign extend
031c(00a6): 3e 66 bc a0 '  mov r0, r11 ' setup r0/r1 (2)
0320(00a7): 3d 68 bc a0 '  mov r1, r10 ' setup r0/r1 (2)
0324(00a8): 12 00 7c 5c '  jmp #MULT ' MULT(I/U)
0328(00a9): 04 00 7c 5c '  jmp #LODA
032c(00aa): b8 34 00 00 '  long @C_port_table
0330(00ab): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
0334(00ac): 33 7c bc a0 '  mov r11, r0 ' ADDI/P
0338(00ad): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (3)
033c(00ae): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
0340(00af): 00 7c 7c 86 '  cmp r11,  #0 wz
0344(00b0): 14 00 7c 5c '  jmp #BRNZ
0348(00b1): dc 02 00 00 '  long @C___bbos_port_is_empty_12 ' NEU4
034c(00b2): 01 86 fc a0 '  mov r16, #1 ' reg <- coni
0350(00b3): 0e 00 7c 5c '  jmp #JMPA
0354(00b4): e0 02 00 00 '  long @C___bbos_port_is_empty_13 ' JUMPV addrg
0358(00b5):             ' C___bbos_port_is_empty_12
0358(00b5): 00 86 fc a0 '  mov r16, #0 ' reg <- coni
035c(00b6):             ' C___bbos_port_is_empty_13
035c(00b6): 43 7c bc a0 '  mov r11, r16 ' CVI, CVU or LOAD
0360(00b7): 3e 66 bc a0 '  mov r0, r11 ' CVUI
0364(00b8): 4d 66 bc 60 '  and r0, cviu_m1 ' zero extend
0368(00b9): 23 00 7c 5c '  jmp #POPM
036c(00ba): 00 0c 03 00 '  long $30c00 ' restore registers
0370(00bb): 0c 00 7c 5c '  jmp #RETN
0374(00bc):             '  long ' align long
0374(00bc):             ' C___bbos_port_write ' <symbol:__bbos_port_write>
0374(00bc): 22 00 7c 5c '  jmp #PSHM
0378(00bd): 00 0e 03 00 '  long $30e00 ' save registers
037c(00be): 36 88 bc a0 '  mov r17, r3 ' reg var <- reg arg
0380(00bf): 35 86 bc a0 '  mov r16, r2 ' reg var <- reg arg
0384(00c0): 0c 7c fc a0 '  mov r11, #12 ' reg <- coni
0388(00c1): 44 7a bc a0 '  mov r10, r17 ' CVII
038c(00c2): 44 7a bc a0 '  mov r10, r17 ' CVII
0390(00c3): 10 7a fc 2c '  shl r10, #16
0394(00c4): 10 7a fc 38 '  sar r10, #16 ' sign extend
0398(00c5): 3e 66 bc a0 '  mov r0, r11 ' setup r0/r1 (2)
039c(00c6): 3d 68 bc a0 '  mov r1, r10 ' setup r0/r1 (2)
03a0(00c7): 12 00 7c 5c '  jmp #MULT ' MULT(I/U)
03a4(00c8): 04 00 7c 5c '  jmp #LODA
03a8(00c9): c0 34 00 00 '  long @C_port_table+8
03ac(00ca): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
03b0(00cb): 33 7c bc a0 '  mov r11, r0 ' ADDI/P
03b4(00cc): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (3)
03b8(00cd): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
03bc(00ce): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
03c0(00cf): 00 7c 7c c2 '  cmps r11,  #0 wz
03c4(00d0): 14 00 7c 5c '  jmp #BRNZ
03c8(00d1): 5c 03 00 00 '  long @C___bbos_port_write_15 ' NEI4
03cc(00d2): 01 66 fc a0 '  mov r0, #1 ' RET coni
03d0(00d3): 0e 00 7c 5c '  jmp #JMPA
03d4(00d4): c4 04 00 00 '  long @C___bbos_port_write_14 ' JUMPV addrg
03d8(00d5):             ' C___bbos_port_write_15
03d8(00d5): 0c 7c fc a0 '  mov r11, #12 ' reg <- coni
03dc(00d6): 44 7a bc a0 '  mov r10, r17 ' CVII
03e0(00d7): 44 7a bc a0 '  mov r10, r17 ' CVII
03e4(00d8): 10 7a fc 2c '  shl r10, #16
03e8(00d9): 10 7a fc 38 '  sar r10, #16 ' sign extend
03ec(00da): 3e 66 bc a0 '  mov r0, r11 ' setup r0/r1 (2)
03f0(00db): 3d 68 bc a0 '  mov r1, r10 ' setup r0/r1 (2)
03f4(00dc): 12 00 7c 5c '  jmp #MULT ' MULT(I/U)
03f8(00dd): 04 00 7c 5c '  jmp #LODA
03fc(00de): bc 34 00 00 '  long @C_port_table+4
0400(00df): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
0404(00e0): 33 7c bc a0 '  mov r11, r0 ' ADDI/P
0408(00e1): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (3)
040c(00e2): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
0410(00e3): 00 7c 7c 86 '  cmp r11,  #0 wz
0414(00e4): 14 00 7c 5c '  jmp #BRNZ
0418(00e5): 34 04 00 00 '  long @C___bbos_port_write_18 ' NEU4
041c(00e6): 0c 7c fc a0 '  mov r11, #12 ' reg <- coni
0420(00e7): 44 7a bc a0 '  mov r10, r17 ' CVII
0424(00e8): 44 7a bc a0 '  mov r10, r17 ' CVII
0428(00e9): 10 7a fc 2c '  shl r10, #16
042c(00ea): 10 7a fc 38 '  sar r10, #16 ' sign extend
0430(00eb): 3e 66 bc a0 '  mov r0, r11 ' setup r0/r1 (2)
0434(00ec): 3d 68 bc a0 '  mov r1, r10 ' setup r0/r1 (2)
0438(00ed): 12 00 7c 5c '  jmp #MULT ' MULT(I/U)
043c(00ee): 04 00 7c 5c '  jmp #LODA
0440(00ef): b8 34 00 00 '  long @C_port_table
0444(00f0): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
0448(00f1): 33 7c bc a0 '  mov r11, r0 ' ADDI/P
044c(00f2): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (3)
0450(00f3): 3e 86 3c 08 '  wrlong r16, r11 ' ASGNP4 reg
0454(00f4): 0c 7c fc a0 '  mov r11, #12 ' reg <- coni
0458(00f5): 44 7a bc a0 '  mov r10, r17 ' CVII
045c(00f6): 44 7a bc a0 '  mov r10, r17 ' CVII
0460(00f7): 10 7a fc 2c '  shl r10, #16
0464(00f8): 10 7a fc 38 '  sar r10, #16 ' sign extend
0468(00f9): 3e 66 bc a0 '  mov r0, r11 ' setup r0/r1 (2)
046c(00fa): 3d 68 bc a0 '  mov r1, r10 ' setup r0/r1 (2)
0470(00fb): 12 00 7c 5c '  jmp #MULT ' MULT(I/U)
0474(00fc): 04 00 7c 5c '  jmp #LODA
0478(00fd): bc 34 00 00 '  long @C_port_table+4
047c(00fe): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
0480(00ff): 33 7c bc a0 '  mov r11, r0 ' ADDI/P
0484(0100): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (3)
0488(0101): 3e 86 3c 08 '  wrlong r16, r11 ' ASGNP4 reg
048c(0102): 43 7c bc a0 '  mov r11, r16
0490(0103): 0c 7c fc d0 '  adds r11, #12 ' ADDP4 coni
0494(0104): 04 00 7c 5c '  jmp #LODA
0498(0105): e0 31 00 00 '  long @C___bbos_port_init_L000005
049c(0106): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
04a0(0107): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
04a4(0108): 00 66 fc a0 '  mov r0, #0 ' RET coni
04a8(0109): 0e 00 7c 5c '  jmp #JMPA
04ac(010a): c4 04 00 00 '  long @C___bbos_port_write_14 ' JUMPV addrg
04b0(010b):             ' C___bbos_port_write_18
04b0(010b): 0c 7c fc a0 '  mov r11, #12 ' reg <- coni
04b4(010c): 44 7a bc a0 '  mov r10, r17 ' CVII
04b8(010d): 44 7a bc a0 '  mov r10, r17 ' CVII
04bc(010e): 10 7a fc 2c '  shl r10, #16
04c0(010f): 10 7a fc 38 '  sar r10, #16 ' sign extend
04c4(0110): 3e 66 bc a0 '  mov r0, r11 ' setup r0/r1 (2)
04c8(0111): 3d 68 bc a0 '  mov r1, r10 ' setup r0/r1 (2)
04cc(0112): 12 00 7c 5c '  jmp #MULT ' MULT(I/U)
04d0(0113): 43 7a bc a0 '  mov r10, r16
04d4(0114): 0c 7a fc d0 '  adds r10, #12 ' ADDP4 coni
04d8(0115): 04 00 7c 5c '  jmp #LODA
04dc(0116): bc 34 00 00 '  long @C_port_table+4
04e0(0117): 2e 78 bc a0 '  mov r9, RI ' reg <- addrg
04e4(0118): 33 7c bc a0 '  mov r11, r0 ' ADDI/P
04e8(0119): 3c 7c bc d0 '  adds r11, r9 ' ADDI/P (3)
04ec(011a): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
04f0(011b): 0c 7c fc d0 '  adds r11, #12 ' ADDP4 coni
04f4(011c): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
04f8(011d): 3d 7c 3c 08 '  wrlong r11, r10 ' ASGNP4 reg
04fc(011e): 0c 7c fc a0 '  mov r11, #12 ' reg <- coni
0500(011f): 44 7a bc a0 '  mov r10, r17 ' CVII
0504(0120): 44 7a bc a0 '  mov r10, r17 ' CVII
0508(0121): 10 7a fc 2c '  shl r10, #16
050c(0122): 10 7a fc 38 '  sar r10, #16 ' sign extend
0510(0123): 3e 66 bc a0 '  mov r0, r11 ' setup r0/r1 (2)
0514(0124): 3d 68 bc a0 '  mov r1, r10 ' setup r0/r1 (2)
0518(0125): 12 00 7c 5c '  jmp #MULT ' MULT(I/U)
051c(0126): 04 00 7c 5c '  jmp #LODA
0520(0127): bc 34 00 00 '  long @C_port_table+4
0524(0128): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
0528(0129): 33 7c bc a0 '  mov r11, r0 ' ADDI/P
052c(012a): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (3)
0530(012b): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
0534(012c): 0c 7c fc d0 '  adds r11, #12 ' ADDP4 coni
0538(012d): 3e 86 3c 08 '  wrlong r16, r11 ' ASGNP4 reg
053c(012e): 00 66 fc a0 '  mov r0, #0 ' RET coni
0540(012f):             ' C___bbos_port_write_14
0540(012f): 23 00 7c 5c '  jmp #POPM
0544(0130): 00 0e 03 00 '  long $30e00 ' restore registers
0548(0131): 0c 00 7c 5c '  jmp #RETN
054c(0132):             '  long ' align long
054c(0132):             ' C___bbos_port_read ' <symbol:__bbos_port_read>
054c(0132): 22 00 7c 5c '  jmp #PSHM
0550(0133): 00 0e 03 00 '  long $30e00 ' save registers
0554(0134): 36 88 bc a0 '  mov r17, r3 ' reg var <- reg arg
0558(0135): 35 86 bc a0 '  mov r16, r2 ' reg var <- reg arg
055c(0136): 0c 7c fc a0 '  mov r11, #12 ' reg <- coni
0560(0137): 44 7a bc a0 '  mov r10, r17 ' CVII
0564(0138): 44 7a bc a0 '  mov r10, r17 ' CVII
0568(0139): 10 7a fc 2c '  shl r10, #16
056c(013a): 10 7a fc 38 '  sar r10, #16 ' sign extend
0570(013b): 3e 66 bc a0 '  mov r0, r11 ' setup r0/r1 (2)
0574(013c): 3d 68 bc a0 '  mov r1, r10 ' setup r0/r1 (2)
0578(013d): 12 00 7c 5c '  jmp #MULT ' MULT(I/U)
057c(013e): 04 00 7c 5c '  jmp #LODA
0580(013f): c0 34 00 00 '  long @C_port_table+8
0584(0140): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
0588(0141): 33 7c bc a0 '  mov r11, r0 ' ADDI/P
058c(0142): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (3)
0590(0143): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
0594(0144): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
0598(0145): 00 7c 7c c2 '  cmps r11,  #0 wz
059c(0146): 14 00 7c 5c '  jmp #BRNZ
05a0(0147): 34 05 00 00 '  long @C___bbos_port_read_25 ' NEI4
05a4(0148): 01 66 fc a0 '  mov r0, #1 ' RET coni
05a8(0149): 0e 00 7c 5c '  jmp #JMPA
05ac(014a): a8 06 00 00 '  long @C___bbos_port_read_24 ' JUMPV addrg
05b0(014b):             ' C___bbos_port_read_25
05b0(014b): 44 6a bc a0 '  mov r2, r17 ' CVII
05b4(014c): 44 6a bc a0 '  mov r2, r17 ' CVII
05b8(014d): 10 6a fc 2c '  shl r2, #16
05bc(014e): 10 6a fc 38 '  sar r2, #16 ' sign extend
05c0(014f): 04 5e fc a0 '  mov BC, #4 ' arg size
05c4(0150): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
05c8(0151): 0b 00 7c 5c '  jmp #CALA
05cc(0152): 80 02 00 00 '  long @C___bbos_port_is_empty
05d0(0153): 04 58 fc 80 '  add SP, #4 ' CALL addrg
05d4(0154): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
05d8(0155): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
05dc(0156): 00 7c 7c c2 '  cmps r11,  #0 wz
05e0(0157): 13 00 7c 5c '  jmp #BR_Z
05e4(0158): 78 05 00 00 '  long @C___bbos_port_read_28 ' EQI4
05e8(0159): 01 66 fc a0 '  mov r0, #1 ' RET coni
05ec(015a): 0e 00 7c 5c '  jmp #JMPA
05f0(015b): a8 06 00 00 '  long @C___bbos_port_read_24 ' JUMPV addrg
05f4(015c):             ' C___bbos_port_read_28
05f4(015c): 0c 7c fc a0 '  mov r11, #12 ' reg <- coni
05f8(015d): 44 7a bc a0 '  mov r10, r17 ' CVII
05fc(015e): 44 7a bc a0 '  mov r10, r17 ' CVII
0600(015f): 10 7a fc 2c '  shl r10, #16
0604(0160): 10 7a fc 38 '  sar r10, #16 ' sign extend
0608(0161): 3e 66 bc a0 '  mov r0, r11 ' setup r0/r1 (2)
060c(0162): 3d 68 bc a0 '  mov r1, r10 ' setup r0/r1 (2)
0610(0163): 12 00 7c 5c '  jmp #MULT ' MULT(I/U)
0614(0164): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
0618(0165): 43 66 bc a0 '  mov r0, r16 ' CVI, CVU or LOAD
061c(0166): 04 00 7c 5c '  jmp #LODA
0620(0167): b8 34 00 00 '  long @C_port_table
0624(0168): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
0628(0169): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
062c(016a): 3e 68 bc 08 '  rdlong r1, r11 ' reg <- INDIRP4 reg
0630(016b): 08 00 7c 5c '  jmp #CPYB
0634(016c): 14 00 00 00 '  long 20 ' ASGNB
0638(016d): 0c 7c fc a0 '  mov r11, #12 ' reg <- coni
063c(016e): 44 7a bc a0 '  mov r10, r17 ' CVII
0640(016f): 44 7a bc a0 '  mov r10, r17 ' CVII
0644(0170): 10 7a fc 2c '  shl r10, #16
0648(0171): 10 7a fc 38 '  sar r10, #16 ' sign extend
064c(0172): 3e 66 bc a0 '  mov r0, r11 ' setup r0/r1 (2)
0650(0173): 3d 68 bc a0 '  mov r1, r10 ' setup r0/r1 (2)
0654(0174): 12 00 7c 5c '  jmp #MULT ' MULT(I/U)
0658(0175): 04 00 7c 5c '  jmp #LODA
065c(0176): b8 34 00 00 '  long @C_port_table
0660(0177): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
0664(0178): 33 7a bc d0 '  adds r10, r0 ' ADDI/P (2)
0668(0179): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRP4 reg
066c(017a): 04 00 7c 5c '  jmp #LODA
0670(017b): bc 34 00 00 '  long @C_port_table+4
0674(017c): 2e 78 bc a0 '  mov r9, RI ' reg <- addrg
0678(017d): 33 7c bc a0 '  mov r11, r0 ' ADDI/P
067c(017e): 3c 7c bc d0 '  adds r11, r9 ' ADDI/P (3)
0680(017f): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
0684(0180): 3e 7a 3c 86 '  cmp r10, r11 wz
0688(0181): 14 00 7c 5c '  jmp #BRNZ
068c(0182): 60 06 00 00 '  long @C___bbos_port_read_30 ' NEU4
0690(0183): 0c 7c fc a0 '  mov r11, #12 ' reg <- coni
0694(0184): 44 7a bc a0 '  mov r10, r17 ' CVII
0698(0185): 44 7a bc a0 '  mov r10, r17 ' CVII
069c(0186): 10 7a fc 2c '  shl r10, #16
06a0(0187): 10 7a fc 38 '  sar r10, #16 ' sign extend
06a4(0188): 3e 66 bc a0 '  mov r0, r11 ' setup r0/r1 (2)
06a8(0189): 3d 68 bc a0 '  mov r1, r10 ' setup r0/r1 (2)
06ac(018a): 12 00 7c 5c '  jmp #MULT ' MULT(I/U)
06b0(018b): 04 00 7c 5c '  jmp #LODA
06b4(018c): bc 34 00 00 '  long @C_port_table+4
06b8(018d): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
06bc(018e): 33 7c bc a0 '  mov r11, r0 ' ADDI/P
06c0(018f): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (3)
06c4(0190): 04 00 7c 5c '  jmp #LODA
06c8(0191): e0 31 00 00 '  long @C___bbos_port_init_L000005
06cc(0192): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
06d0(0193): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
06d4(0194): 0e 00 7c 5c '  jmp #JMPA
06d8(0195): a4 06 00 00 '  long @C___bbos_port_read_31 ' JUMPV addrg
06dc(0196):             ' C___bbos_port_read_30
06dc(0196): 0c 7c fc a0 '  mov r11, #12 ' reg <- coni
06e0(0197): 44 7a bc a0 '  mov r10, r17 ' CVII
06e4(0198): 44 7a bc a0 '  mov r10, r17 ' CVII
06e8(0199): 10 7a fc 2c '  shl r10, #16
06ec(019a): 10 7a fc 38 '  sar r10, #16 ' sign extend
06f0(019b): 3e 66 bc a0 '  mov r0, r11 ' setup r0/r1 (2)
06f4(019c): 3d 68 bc a0 '  mov r1, r10 ' setup r0/r1 (2)
06f8(019d): 12 00 7c 5c '  jmp #MULT ' MULT(I/U)
06fc(019e): 04 00 7c 5c '  jmp #LODA
0700(019f): b8 34 00 00 '  long @C_port_table
0704(01a0): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
0708(01a1): 33 7c bc a0 '  mov r11, r0 ' ADDI/P
070c(01a2): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (3)
0710(01a3): 3e 7a bc 08 '  rdlong r10, r11 ' reg <- INDIRP4 reg
0714(01a4): 0c 7a fc d0 '  adds r10, #12 ' ADDP4 coni
0718(01a5): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRP4 reg
071c(01a6): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
0720(01a7):             ' C___bbos_port_read_31
0720(01a7): 00 66 fc a0 '  mov r0, #0 ' RET coni
0724(01a8):             ' C___bbos_port_read_24
0724(01a8): 23 00 7c 5c '  jmp #POPM
0728(01a9): 00 0e 03 00 '  long $30e00 ' restore registers
072c(01aa): 0c 00 7c 5c '  jmp #RETN
0730(01ab):             '  long ' align long
0730(01ab):             ' C_bbos_idle ' <symbol:bbos_idle>
0730(01ab): 0c 00 7c 5c '  jmp #RETN
0734(01ac):             '  long ' align long
0734(01ac):             ' C_bbos_banner ' <symbol:bbos_banner>
0734(01ac): 04 00 7c 5c '  jmp #LODA
0738(01ad): 48 32 00 00 '  long @C_bbos_banner_6_L000007
073c(01ae): 2e 6a bc a0 '  mov r2, RI ' reg ARG ADDRG
0740(01af): 04 00 7c 5c '  jmp #LODA
0744(01b0): 58 32 00 00 '  long @C_bbos_banner_4_L000005
0748(01b1): 2e 6c bc a0 '  mov r3, RI ' reg ARG ADDRG
074c(01b2): 08 5e fc a0 '  mov BC, #8 ' arg size
0750(01b3): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0754(01b4): 0b 00 7c 5c '  jmp #CALA
0758(01b5): 9c 30 00 00 '  long @C_printf
075c(01b6): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0760(01b7): 0c 00 7c 5c '  jmp #RETN
0764(01b8):             '  long ' align long
0764(01b8):             ' C_bbos_panic ' <symbol:bbos_panic>
0764(01b8): 09 00 7c 5c '  jmp #NEWF
0768(01b9): 04 58 fc 84 '  sub SP, #4
076c(01ba): 22 00 7c 5c '  jmp #PSHM
0770(01bb): 00 08 00 00 '  long $800 ' save registers
0774(01bc): 2d 5c bc a0 '  mov RI, FP
0778(01bd): 08 5c fc 80 '  add RI, #8
077c(01be): 04 5e fc 84 '  sub BC, #4
0780(01bf): 2e 5e 3c 87 '  cmp BC, RI wz,wc
0784(01c0): 2f 6a 0c 08 '  if_ae wrlong r2, BC ' spill reg (varadic)
0788(01c1): 04 5e fc 84 '  sub BC, #4
078c(01c2): 2e 5e 3c 87 '  cmp BC, RI wz,wc
0790(01c3): 2f 6c 0c 08 '  if_ae wrlong r3, BC ' spill reg (varadic)
0794(01c4): 04 5e fc 84 '  sub BC, #4
0798(01c5): 2e 5e 3c 87 '  cmp BC, RI wz,wc
079c(01c6): 2f 6e 0c 08 '  if_ae wrlong r4, BC ' spill reg (varadic)
07a0(01c7): 04 5e fc 84 '  sub BC, #4
07a4(01c8): 2e 5e 3c 87 '  cmp BC, RI wz,wc
07a8(01c9): 2f 70 0c 08 '  if_ae wrlong r5, BC ' spill reg (varadic)
07ac(01ca): 2d 7c bc a0 '  mov r11, FP
07b0(01cb): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
07b4(01cc): 05 00 7c 5c '  jmp #LODF
07b8(01cd): fc ff ff ff '  long -4
07bc(01ce): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
07c0(01cf): 04 00 7c 5c '  jmp #LODA
07c4(01d0): d0 34 00 00 '  long @C_bbos_panic_buf_L000010
07c8(01d1): 2e 6a bc a0 '  mov r2, RI ' reg ARG ADDRG
07cc(01d2): 04 00 7c 5c '  jmp #LODA
07d0(01d3): 3c 32 00 00 '  long @C_bbos_panic_12_L000013
07d4(01d4): 2e 6c bc a0 '  mov r3, RI ' reg ARG ADDRG
07d8(01d5): 08 5e fc a0 '  mov BC, #8 ' arg size
07dc(01d6): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
07e0(01d7): 0b 00 7c 5c '  jmp #CALA
07e4(01d8): 9c 30 00 00 '  long @C_printf
07e8(01d9): 08 58 fc 80 '  add SP, #8 ' CALL addrg
07ec(01da): 23 00 7c 5c '  jmp #POPM
07f0(01db): 00 08 00 00 '  long $800 ' restore registers
07f4(01dc): 04 58 fc 80 '  add SP, #4 ' framesize
07f8(01dd): 0a 00 7c 5c '  jmp #RETF
07fc(01de):             '  long ' align long
07fc(01de):             ' C_bbos_init ' <symbol:bbos_init>
07fc(01de): 22 00 7c 5c '  jmp #PSHM
0800(01df): 00 08 00 00 '  long $800 ' save registers
0804(01e0): 00 7c fc a0 '  mov r11, #0 ' reg <- coni
0808(01e1): 04 00 7c 5c '  jmp #LODA
080c(01e2): 50 35 00 00 '  long @C_bbos_system_state
0810(01e3): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrg
0814(01e4): 00 5e fc a0 '  mov BC, #0 ' arg size
0818(01e5): 0b 00 7c 5c '  jmp #CALA
081c(01e6): b8 06 00 00 '  long @C_bbos_banner ' CALL addrg
0820(01e7): 04 00 7c 5c '  jmp #LODA
0824(01e8): 28 32 00 00 '  long @C_bbos_init_15_L000016
0828(01e9): 2e 6a bc a0 '  mov r2, RI ' reg ARG ADDRG
082c(01ea): 04 5e fc a0 '  mov BC, #4 ' arg size
0830(01eb): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
0834(01ec): 0b 00 7c 5c '  jmp #CALA
0838(01ed): 9c 30 00 00 '  long @C_printf
083c(01ee): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0840(01ef): 04 00 7c 5c '  jmp #LODA
0844(01f0): 0c 32 00 00 '  long @C_bbos_init_17_L000018
0848(01f1): 2e 6a bc a0 '  mov r2, RI ' reg ARG ADDRG
084c(01f2): 04 5e fc a0 '  mov BC, #4 ' arg size
0850(01f3): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
0854(01f4): 0b 00 7c 5c '  jmp #CALA
0858(01f5): 9c 30 00 00 '  long @C_printf
085c(01f6): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0860(01f7): 23 00 7c 5c '  jmp #POPM
0864(01f8): 00 08 00 00 '  long $800 ' restore registers
0868(01f9): 0c 00 7c 5c '  jmp #RETN
086c(01fa):             '  long ' align long
086c(01fa):             ' C_bbos_start ' <symbol:bbos_start>
086c(01fa): 22 00 7c 5c '  jmp #PSHM
0870(01fb): 00 08 00 00 '  long $800 ' save registers
0874(01fc): 04 00 7c 5c '  jmp #LODA
0878(01fd): 50 35 00 00 '  long @C_bbos_system_state
087c(01fe): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrg
0880(01ff): 00 7c 7c c2 '  cmps r11,  #0 wz
0884(0200): 13 00 7c 5c '  jmp #BR_Z
0888(0201): 3c 08 00 00 '  long @C_bbos_start_20 ' EQI4
088c(0202): 01 7c 7c c2 '  cmps r11,  #1 wz
0890(0203): 13 00 7c 5c '  jmp #BR_Z
0894(0204): 3c 08 00 00 '  long @C_bbos_start_20 ' EQI4
0898(0205): 04 00 7c 5c '  jmp #LODA
089c(0206): f0 31 00 00 '  long @C_bbos_start_22_L000023
08a0(0207): 2e 6a bc a0 '  mov r2, RI ' reg ARG ADDRG
08a4(0208): 04 5e fc a0 '  mov BC, #4 ' arg size
08a8(0209): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
08ac(020a): 0b 00 7c 5c '  jmp #CALA
08b0(020b): e8 06 00 00 '  long @C_bbos_panic
08b4(020c): 04 58 fc 80 '  add SP, #4 ' CALL addrg
08b8(020d):             ' C_bbos_start_20
08b8(020d): 02 7c fc a0 '  mov r11, #2 ' reg <- coni
08bc(020e): 04 00 7c 5c '  jmp #LODA
08c0(020f): 50 35 00 00 '  long @C_bbos_system_state
08c4(0210): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrg
08c8(0211): 04 00 7c 5c '  jmp #LODA
08cc(0212): e4 31 00 00 '  long @C_bbos_start_24_L000025
08d0(0213): 2e 6a bc a0 '  mov r2, RI ' reg ARG ADDRG
08d4(0214): 04 5e fc a0 '  mov BC, #4 ' arg size
08d8(0215): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
08dc(0216): 0b 00 7c 5c '  jmp #CALA
08e0(0217): 9c 30 00 00 '  long @C_printf
08e4(0218): 04 58 fc 80 '  add SP, #4 ' CALL addrg
08e8(0219): 00 5e fc a0 '  mov BC, #0 ' arg size
08ec(021a): 0b 00 7c 5c '  jmp #CALA
08f0(021b): b0 0b 00 00 '  long @C_bbos ' CALL addrg
08f4(021c): 23 00 7c 5c '  jmp #POPM
08f8(021d): 00 08 00 00 '  long $800 ' restore registers
08fc(021e): 0c 00 7c 5c '  jmp #RETN
0900(021f):             '  long ' align long
0900(021f):             ' C_bbos_main ' <symbol:bbos_main>
0900(021f): 00 5e fc a0 '  mov BC, #0 ' arg size
0904(0220): 0b 00 7c 5c '  jmp #CALA
0908(0221): 80 07 00 00 '  long @C_bbos_init ' CALL addrg
090c(0222): 00 5e fc a0 '  mov BC, #0 ' arg size
0910(0223): 0b 00 7c 5c '  jmp #CALA
0914(0224): f0 07 00 00 '  long @C_bbos_start ' CALL addrg
0918(0225): 00 66 fc a0 '  mov r0, #0 ' RET coni
091c(0226): 0c 00 7c 5c '  jmp #RETN
0920(0227):             '  long ' align long
0920(0227):             ' C_main ' <symbol:main>
0920(0227): 0b 00 7c 5c '  jmp #CALA
0924(0228): 7c 01 00 00 '  long @C_arg_setup
0928(0229): 00 5e fc a0 '  mov BC, #0 ' arg size
092c(022a): 0b 00 7c 5c '  jmp #CALA
0930(022b): 84 08 00 00 '  long @C_bbos_main ' CALL addrg
0934(022c): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
0938(022d): 0e 00 7c 5c '  jmp #JMPA
093c(022e): 6c 01 00 00 '  long @C__exit
0940(022f):             '  long ' align long
0940(022f):             ' C_blinker ' <symbol:blinker>
0940(022f): 22 00 7c 5c '  jmp #PSHM
0944(0230): 00 0c 02 00 '  long $20c00 ' save registers
0948(0231): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
094c(0232): 04 5e fc a0 '  mov BC, #4 ' arg size
0950(0233): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
0954(0234): 0b 00 7c 5c '  jmp #CALA
0958(0235): 80 02 00 00 '  long @C___bbos_port_is_empty
095c(0236): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0960(0237): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
0964(0238): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
0968(0239): 00 7c 7c c2 '  cmps r11,  #0 wz
096c(023a): 14 00 7c 5c '  jmp #BRNZ
0970(023b): 5c 0a 00 00 '  long @C_blinker_14 ' NEI4
0974(023c): 04 00 7c 5c '  jmp #LODA
0978(023d): 54 35 00 00 '  long @C_blinker_message_L000005
097c(023e): 2e 6a bc a0 '  mov r2, RI ' reg ARG ADDRG
0980(023f): 00 6c fc a0 '  mov r3, #0 ' reg ARG coni
0984(0240): 08 5e fc a0 '  mov BC, #8 ' arg size
0988(0241): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
098c(0242): 0b 00 7c 5c '  jmp #CALA
0990(0243): d0 04 00 00 '  long @C___bbos_port_read
0994(0244): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0998(0245): 04 00 7c 5c '  jmp #LODA
099c(0246): 68 35 00 00 '  long @C_blinker_request_L000009
09a0(0247): 2e 66 bc a0 '  mov r0, RI ' reg <- addrg
09a4(0248): 04 00 7c 5c '  jmp #LODA
09a8(0249): 64 35 00 00 '  long @C_blinker_message_L000005+16
09ac(024a): 2e 68 bc 08 '  rdlong r1, RI ' reg <- INDIRP4 addrg
09b0(024b): 08 00 7c 5c '  jmp #CPYB
09b4(024c): 10 00 00 00 '  long 16 ' ASGNB
09b8(024d): 04 00 7c 5c '  jmp #LODA
09bc(024e): 54 35 00 00 '  long @C_blinker_message_L000005
09c0(024f): 2e 88 bc 08 '  rdlong r17, RI ' reg <- INDIRI4 addrg
09c4(0250): 00 88 7c c2 '  cmps r17,  #0 wz
09c8(0251): 13 00 7c 5c '  jmp #BR_Z
09cc(0252): 68 09 00 00 '  long @C_blinker_20 ' EQI4
09d0(0253): 03 88 7c c2 '  cmps r17,  #3 wz
09d4(0254): 13 00 7c 5c '  jmp #BR_Z
09d8(0255): f0 09 00 00 '  long @C_blinker_29 ' EQI4
09dc(0256): 0e 00 7c 5c '  jmp #JMPA
09e0(0257): 5c 0a 00 00 '  long @C_blinker_17 ' JUMPV addrg
09e4(0258):             ' C_blinker_20
09e4(0258): 04 00 7c 5c '  jmp #LODA
09e8(0259): 74 35 00 00 '  long @C_blinker_request_L000009+12
09ec(025a): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrg
09f0(025b): 00 7c 7c c2 '  cmps r11,  #0 wz
09f4(025c): 14 00 7c 5c '  jmp #BRNZ
09f8(025d): bc 09 00 00 '  long @C_blinker_21 ' NEI4
09fc(025e): 12 6a fc a0 '  mov r2, #18 ' reg ARG coni
0a00(025f): 04 00 7c 5c '  jmp #LODA
0a04(0260): 08 33 00 00 '  long @C_blinker_24_L000025
0a08(0261): 2e 6c bc a0 '  mov r3, RI ' reg ARG ADDRG
0a0c(0262): 08 5e fc a0 '  mov BC, #8 ' arg size
0a10(0263): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0a14(0264): 0b 00 7c 5c '  jmp #CALA
0a18(0265): 9c 30 00 00 '  long @C_printf
0a1c(0266): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0a20(0267): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
0a24(0268): 04 00 7c 5c '  jmp #LODA
0a28(0269): 0c 34 00 00 '  long @C_blinker_init_complete_L000007
0a2c(026a): 2e 7c 3c 00 '  wrbyte r11, RI ' ASGNU1 addrg
0a30(026b): 0e 00 7c 5c '  jmp #JMPA
0a34(026c): 5c 0a 00 00 '  long @C_blinker_18 ' JUMPV addrg
0a38(026d):             ' C_blinker_21
0a38(026d): 04 00 7c 5c '  jmp #LODA
0a3c(026e): 74 35 00 00 '  long @C_blinker_request_L000009+12
0a40(026f): 2e 6a bc 08 '  rdlong r2, RI ' reg ARG INDIR ADDRG
0a44(0270): 04 00 7c 5c '  jmp #LODA
0a48(0271): e8 32 00 00 '  long @C_blinker_26_L000027
0a4c(0272): 2e 6c bc a0 '  mov r3, RI ' reg ARG ADDRG
0a50(0273): 08 5e fc a0 '  mov BC, #8 ' arg size
0a54(0274): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0a58(0275): 0b 00 7c 5c '  jmp #CALA
0a5c(0276): 9c 30 00 00 '  long @C_printf
0a60(0277): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0a64(0278): 0e 00 7c 5c '  jmp #JMPA
0a68(0279): 5c 0a 00 00 '  long @C_blinker_18 ' JUMPV addrg
0a6c(027a):             ' C_blinker_29
0a6c(027a): 04 00 7c 5c '  jmp #LODA
0a70(027b): 74 35 00 00 '  long @C_blinker_request_L000009+12
0a74(027c): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrg
0a78(027d): 00 7c 7c c2 '  cmps r11,  #0 wz
0a7c(027e): 14 00 7c 5c '  jmp #BRNZ
0a80(027f): 30 0a 00 00 '  long @C_blinker_30 ' NEI4
0a84(0280): 04 00 7c 5c '  jmp #LODA
0a88(0281): cc 32 00 00 '  long @C_blinker_33_L000034
0a8c(0282): 2e 6a bc a0 '  mov r2, RI ' reg ARG ADDRG
0a90(0283): 04 5e fc a0 '  mov BC, #4 ' arg size
0a94(0284): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
0a98(0285): 0b 00 7c 5c '  jmp #CALA
0a9c(0286): 9c 30 00 00 '  long @C_printf
0aa0(0287): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0aa4(0288): 0e 00 7c 5c '  jmp #JMPA
0aa8(0289): 5c 0a 00 00 '  long @C_blinker_18 ' JUMPV addrg
0aac(028a):             ' C_blinker_30
0aac(028a): 04 00 7c 5c '  jmp #LODA
0ab0(028b): 74 35 00 00 '  long @C_blinker_request_L000009+12
0ab4(028c): 2e 6a bc 08 '  rdlong r2, RI ' reg ARG INDIR ADDRG
0ab8(028d): 04 00 7c 5c '  jmp #LODA
0abc(028e): a8 32 00 00 '  long @C_blinker_35_L000036
0ac0(028f): 2e 6c bc a0 '  mov r3, RI ' reg ARG ADDRG
0ac4(0290): 08 5e fc a0 '  mov BC, #8 ' arg size
0ac8(0291): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0acc(0292): 0b 00 7c 5c '  jmp #CALA
0ad0(0293): 9c 30 00 00 '  long @C_printf
0ad4(0294): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0ad8(0295):             ' C_blinker_17
0ad8(0295):             ' C_blinker_18
0ad8(0295):             ' C_blinker_14
0ad8(0295): 04 00 7c 5c '  jmp #LODA
0adc(0296): 0c 34 00 00 '  long @C_blinker_init_complete_L000007
0ae0(0297): 2e 7c bc 00 '  rdbyte r11, RI ' reg <- INDIRU1 addrg
0ae4(0298): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
0ae8(0299): 00 7c 7c c2 '  cmps r11,  #0 wz
0aec(029a): 14 00 7c 5c '  jmp #BRNZ
0af0(029b): 04 0b 00 00 '  long @C_blinker_38 ' NEI4
0af4(029c): 12 7c fc a0 '  mov r11, #18 ' reg <- coni
0af8(029d): 04 00 7c 5c '  jmp #LODA
0afc(029e): 6c 35 00 00 '  long @C_blinker_request_L000009+4
0b00(029f): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNU4 addrg
0b04(02a0): 04 00 7c 5c '  jmp #LODA
0b08(02a1): 14 34 00 00 '  long @C_blinker_indicator_L000013
0b0c(02a2): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRU4 addrg
0b10(02a3): 04 00 7c 5c '  jmp #LODA
0b14(02a4): 70 35 00 00 '  long @C_blinker_request_L000009+8
0b18(02a5): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNU4 addrg
0b1c(02a6): 00 7c fc a0 '  mov r11, #0 ' reg <- coni
0b20(02a7): 04 00 7c 5c '  jmp #LODA
0b24(02a8): 54 35 00 00 '  long @C_blinker_message_L000005
0b28(02a9): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrg
0b2c(02aa): 04 00 7c 5c '  jmp #LODA
0b30(02ab): 68 35 00 00 '  long @C_blinker_request_L000009
0b34(02ac): 2e 7c bc a0 '  mov r11, RI ' reg <- addrg
0b38(02ad): 04 00 7c 5c '  jmp #LODA
0b3c(02ae): 64 35 00 00 '  long @C_blinker_message_L000005+16
0b40(02af): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrg
0b44(02b0): 00 7c fc a0 '  mov r11, #0 ' reg <- coni
0b48(02b1): 04 00 7c 5c '  jmp #LODA
0b4c(02b2): 5c 35 00 00 '  long @C_blinker_message_L000005+8
0b50(02b3): 2e 7c 3c 04 '  wrword r11, RI ' ASGNI2 addrg
0b54(02b4): 04 00 7c 5c '  jmp #LODA
0b58(02b5): 54 35 00 00 '  long @C_blinker_message_L000005
0b5c(02b6): 2e 6a bc a0 '  mov r2, RI ' reg ARG ADDRG
0b60(02b7): 01 6c fc a0 '  mov r3, #1 ' reg ARG coni
0b64(02b8): 08 5e fc a0 '  mov BC, #8 ' arg size
0b68(02b9): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0b6c(02ba): 0b 00 7c 5c '  jmp #CALA
0b70(02bb): f8 02 00 00 '  long @C___bbos_port_write
0b74(02bc): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0b78(02bd): 0e 00 7c 5c '  jmp #JMPA
0b7c(02be): a4 0b 00 00 '  long @C_blinker_3 ' JUMPV addrg
0b80(02bf):             ' C_blinker_38
0b80(02bf): 12 7c fc a0 '  mov r11, #18 ' reg <- coni
0b84(02c0): 04 00 7c 5c '  jmp #LODA
0b88(02c1): 6c 35 00 00 '  long @C_blinker_request_L000009+4
0b8c(02c2): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNU4 addrg
0b90(02c3): 04 00 7c 5c '  jmp #LODA
0b94(02c4): 14 34 00 00 '  long @C_blinker_indicator_L000013
0b98(02c5): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRU4 addrg
0b9c(02c6): 04 00 7c 5c '  jmp #LODA
0ba0(02c7): 70 35 00 00 '  long @C_blinker_request_L000009+8
0ba4(02c8): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNU4 addrg
0ba8(02c9): 04 00 7c 5c '  jmp #LODA
0bac(02ca): 14 34 00 00 '  long @C_blinker_indicator_L000013
0bb0(02cb): 2e 7c bc a0 '  mov r11, RI ' reg <- addrg
0bb4(02cc): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRU4 reg
0bb8(02cd): 04 00 7c 5c '  jmp #LODA
0bbc(02ce): 10 34 00 00 '  long @C_blinker_mask_L000011
0bc0(02cf): 2e 7a bc 08 '  rdlong r10, RI ' reg <- INDIRU4 addrg
0bc4(02d0): 3d 7c bc 6c '  xor r11, r10 ' BXORI/U (1)
0bc8(02d1): 04 00 7c 5c '  jmp #LODA
0bcc(02d2): 14 34 00 00 '  long @C_blinker_indicator_L000013
0bd0(02d3): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNU4 addrg
0bd4(02d4): 03 7c fc a0 '  mov r11, #3 ' reg <- coni
0bd8(02d5): 04 00 7c 5c '  jmp #LODA
0bdc(02d6): 54 35 00 00 '  long @C_blinker_message_L000005
0be0(02d7): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrg
0be4(02d8): 04 00 7c 5c '  jmp #LODA
0be8(02d9): 68 35 00 00 '  long @C_blinker_request_L000009
0bec(02da): 2e 7c bc a0 '  mov r11, RI ' reg <- addrg
0bf0(02db): 04 00 7c 5c '  jmp #LODA
0bf4(02dc): 64 35 00 00 '  long @C_blinker_message_L000005+16
0bf8(02dd): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrg
0bfc(02de): 04 00 7c 5c '  jmp #LODA
0c00(02df): 54 35 00 00 '  long @C_blinker_message_L000005
0c04(02e0): 2e 6a bc a0 '  mov r2, RI ' reg ARG ADDRG
0c08(02e1): 01 6c fc a0 '  mov r3, #1 ' reg ARG coni
0c0c(02e2): 08 5e fc a0 '  mov BC, #8 ' arg size
0c10(02e3): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0c14(02e4): 0b 00 7c 5c '  jmp #CALA
0c18(02e5): f8 02 00 00 '  long @C___bbos_port_write
0c1c(02e6): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0c20(02e7):             ' C_blinker_3
0c20(02e7): 23 00 7c 5c '  jmp #POPM
0c24(02e8): 00 0c 02 00 '  long $20c00 ' restore registers
0c28(02e9): 0c 00 7c 5c '  jmp #RETN
0c2c(02ea):             '  long ' align long
0c2c(02ea):             ' C_bbos ' <symbol:bbos>
0c2c(02ea): 22 00 7c 5c '  jmp #PSHM
0c30(02eb): 00 0c 00 00 '  long $c00 ' save registers
0c34(02ec): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
0c38(02ed): 04 5e fc a0 '  mov BC, #4 ' arg size
0c3c(02ee): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
0c40(02ef): 0b 00 7c 5c '  jmp #CALA
0c44(02f0): a0 01 00 00 '  long @C___bbos_port_init
0c48(02f1): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0c4c(02f2): 01 6a fc a0 '  mov r2, #1 ' reg ARG coni
0c50(02f3): 04 5e fc a0 '  mov BC, #4 ' arg size
0c54(02f4): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
0c58(02f5): 0b 00 7c 5c '  jmp #CALA
0c5c(02f6): a0 01 00 00 '  long @C___bbos_port_init
0c60(02f7): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0c64(02f8): 01 6a fc a0 '  mov r2, #1 ' reg ARG coni
0c68(02f9): 00 6c fc a0 '  mov r3, #0 ' reg ARG coni
0c6c(02fa): 08 5e fc a0 '  mov BC, #8 ' arg size
0c70(02fb): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0c74(02fc): 0b 00 7c 5c '  jmp #CALA
0c78(02fd): 1c 13 00 00 '  long @C_p8x32a_gpio_init
0c7c(02fe): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0c80(02ff): 04 00 7c 5c '  jmp #LODA
0c84(0300): a4 32 00 00 '  long @C_bbos_L000049
0c88(0301): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
0c8c(0302): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
0c90(0303): 3e 6c bc a0 '  mov r3, r11 ' CVI, CVU or LOAD
0c94(0304): 08 5e fc a0 '  mov BC, #8 ' arg size
0c98(0305): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0c9c(0306): 0b 00 7c 5c '  jmp #CALA
0ca0(0307): 54 19 00 00 '  long @C__dira
0ca4(0308): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0ca8(0309): 04 00 7c 5c '  jmp #LODA
0cac(030a): a4 32 00 00 '  long @C_bbos_L000049
0cb0(030b): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
0cb4(030c): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
0cb8(030d): 3e 6c bc a0 '  mov r3, r11 ' CVI, CVU or LOAD
0cbc(030e): 08 5e fc a0 '  mov BC, #8 ' arg size
0cc0(030f): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0cc4(0310): 0b 00 7c 5c '  jmp #CALA
0cc8(0311): 8c 30 00 00 '  long @C__outa
0ccc(0312): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0cd0(0313): 00 5e fc a0 '  mov BC, #0 ' arg size
0cd4(0314): 0b 00 7c 5c '  jmp #CALA
0cd8(0315): 4c 19 00 00 '  long @C__cnt ' CALL addrg
0cdc(0316): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
0ce0(0317): 04 00 7c 5c '  jmp #LODA
0ce4(0318): a0 32 00 00 '  long @C_bbos_L000053
0ce8(0319): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
0cec(031a): 3e 6a bc a0 '  mov r2, r11 ' ADDU
0cf0(031b): 3d 6a bc 80 '  add r2, r10 ' ADDU (3)
0cf4(031c): 04 5e fc a0 '  mov BC, #4 ' arg size
0cf8(031d): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
0cfc(031e): 0b 00 7c 5c '  jmp #CALA
0d00(031f): d8 31 00 00 '  long @C__waitcnt
0d04(0320): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0d08(0321): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
0d0c(0322): 04 00 7c 5c '  jmp #LODA
0d10(0323): a4 32 00 00 '  long @C_bbos_L000049
0d14(0324): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG con
0d18(0325): 08 5e fc a0 '  mov BC, #8 ' arg size
0d1c(0326): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0d20(0327): 0b 00 7c 5c '  jmp #CALA
0d24(0328): 8c 30 00 00 '  long @C__outa
0d28(0329): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0d2c(032a): 0e 00 7c 5c '  jmp #JMPA
0d30(032b): 08 0d 00 00 '  long @C_bbos_57 ' JUMPV addrg
0d34(032c):             ' C_bbos_56
0d34(032c): 00 5e fc a0 '  mov BC, #0 ' arg size
0d38(032d): 0b 00 7c 5c '  jmp #CALA
0d3c(032e): c4 08 00 00 '  long @C_blinker ' CALL addrg
0d40(032f): 00 5e fc a0 '  mov BC, #0 ' arg size
0d44(0330): 0b 00 7c 5c '  jmp #CALA
0d48(0331): c0 13 00 00 '  long @C_p8x32a_gpio_messenger ' CALL addrg
0d4c(0332): 00 5e fc a0 '  mov BC, #0 ' arg size
0d50(0333): 0b 00 7c 5c '  jmp #CALA
0d54(0334): 4c 19 00 00 '  long @C__cnt ' CALL addrg
0d58(0335): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
0d5c(0336): 04 00 7c 5c '  jmp #LODA
0d60(0337): a0 32 00 00 '  long @C_bbos_L000053
0d64(0338): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
0d68(0339): 3e 6a bc a0 '  mov r2, r11 ' ADDU
0d6c(033a): 3d 6a bc 80 '  add r2, r10 ' ADDU (3)
0d70(033b): 04 5e fc a0 '  mov BC, #4 ' arg size
0d74(033c): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
0d78(033d): 0b 00 7c 5c '  jmp #CALA
0d7c(033e): d8 31 00 00 '  long @C__waitcnt
0d80(033f): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0d84(0340):             ' C_bbos_57
0d84(0340): 0e 00 7c 5c '  jmp #JMPA
0d88(0341): b8 0c 00 00 '  long @C_bbos_56 ' JUMPV addrg
0d8c(0342): 23 00 7c 5c '  jmp #POPM
0d90(0343): 00 0c 00 00 '  long $c00 ' restore registers
0d94(0344): 0c 00 7c 5c '  jmp #RETN
0d98(0345):             '  long ' align long
0d98(0345):             ' C_gpio_register_chip ' <symbol:gpio_register_chip>
0d98(0345): 22 00 7c 5c '  jmp #PSHM
0d9c(0346): 00 0e 03 00 '  long $30e00 ' save registers
0da0(0347): 35 7c bc a0 '  mov r11, r2
0da4(0348): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
0da8(0349): 3e 86 bc 04 '  rdword r16, r11 ' reg <- INDIRI2 reg
0dac(034a): 43 7c bc a0 '  mov r11, r16 ' CVII
0db0(034b): 43 7c bc a0 '  mov r11, r16 ' CVII
0db4(034c): 10 7c fc 2c '  shl r11, #16
0db8(034d): 10 7c fc 38 '  sar r11, #16 ' sign extend
0dbc(034e): 3e 88 bc a0 '  mov r17, r11 ' CVI, CVU or LOAD
0dc0(034f): 0e 00 7c 5c '  jmp #JMPA
0dc4(0350): 94 0d 00 00 '  long @C_gpio_register_chip_7 ' JUMPV addrg
0dc8(0351):             ' C_gpio_register_chip_4
0dc8(0351): 44 7c bc a0 '  mov r11, r17 ' CVUI
0dcc(0352): 4e 7c bc 60 '  and r11, cviu_m2 ' zero extend
0dd0(0353): 03 7c fc 2c '  shl r11, #3 ' LSHI4 coni
0dd4(0354): 04 00 7c 5c '  jmp #LODA
0dd8(0355): 78 35 00 00 '  long @C_gpio_table
0ddc(0356): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
0de0(0357): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
0de4(0358): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
0de8(0359): 00 7c 7c 86 '  cmp r11,  #0 wz
0dec(035a): 13 00 7c 5c '  jmp #BR_Z
0df0(035b): 84 0d 00 00 '  long @C_gpio_register_chip_8 ' EQU4
0df4(035c): 01 66 fc a0 '  mov r0, #1 ' RET coni
0df8(035d): 0e 00 7c 5c '  jmp #JMPA
0dfc(035e): 80 0e 00 00 '  long @C_gpio_register_chip_3 ' JUMPV addrg
0e00(035f):             ' C_gpio_register_chip_8
0e00(035f): 44 7c bc a0 '  mov r11, r17 ' CVUI
0e04(0360): 4e 7c bc 60 '  and r11, cviu_m2 ' zero extend
0e08(0361): 01 7c fc d0 '  adds r11, #1 ' ADDI4 coni
0e0c(0362): 3e 88 bc a0 '  mov r17, r11 ' CVI, CVU or LOAD
0e10(0363):             ' C_gpio_register_chip_7
0e10(0363): 44 7c bc a0 '  mov r11, r17 ' CVUI
0e14(0364): 4e 7c bc 60 '  and r11, cviu_m2 ' zero extend
0e18(0365): 43 7a bc a0 '  mov r10, r16 ' CVII
0e1c(0366): 43 7a bc a0 '  mov r10, r16 ' CVII
0e20(0367): 10 7a fc 2c '  shl r10, #16
0e24(0368): 10 7a fc 38 '  sar r10, #16 ' sign extend
0e28(0369): 35 78 bc a0 '  mov r9, r2
0e2c(036a): 06 78 fc d0 '  adds r9, #6 ' ADDP4 coni
0e30(036b): 3c 78 bc 04 '  rdword r9, r9 ' reg <- INDIRU2 reg
0e34(036c): 4e 78 bc 60 '  and r9, cviu_m2 ' zero extend
0e38(036d): 3c 7a bc d0 '  adds r10, r9 ' ADDI/P (1)
0e3c(036e): 3d 7c 3c c3 '  cmps r11, r10 wz,wc
0e40(036f): 18 00 7c 5c '  jmp #BR_B
0e44(0370): 4c 0d 00 00 '  long @C_gpio_register_chip_4 ' LTI4
0e48(0371): 43 7c bc a0 '  mov r11, r16 ' CVII
0e4c(0372): 43 7c bc a0 '  mov r11, r16 ' CVII
0e50(0373): 10 7c fc 2c '  shl r11, #16
0e54(0374): 10 7c fc 38 '  sar r11, #16 ' sign extend
0e58(0375): 3e 88 bc a0 '  mov r17, r11 ' CVI, CVU or LOAD
0e5c(0376): 0e 00 7c 5c '  jmp #JMPA
0e60(0377): 44 0e 00 00 '  long @C_gpio_register_chip_13 ' JUMPV addrg
0e64(0378):             ' C_gpio_register_chip_10
0e64(0378): 44 7c bc a0 '  mov r11, r17 ' CVUI
0e68(0379): 4e 7c bc 60 '  and r11, cviu_m2 ' zero extend
0e6c(037a): 03 7c fc 2c '  shl r11, #3 ' LSHI4 coni
0e70(037b): 04 00 7c 5c '  jmp #LODA
0e74(037c): 78 35 00 00 '  long @C_gpio_table
0e78(037d): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
0e7c(037e): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
0e80(037f): 3e 6a 3c 08 '  wrlong r2, r11 ' ASGNP4 reg
0e84(0380): 44 7c bc a0 '  mov r11, r17 ' CVUI
0e88(0381): 4e 7c bc 60 '  and r11, cviu_m2 ' zero extend
0e8c(0382): 03 7c fc 2c '  shl r11, #3 ' LSHI4 coni
0e90(0383): 04 00 7c 5c '  jmp #LODA
0e94(0384): 7c 35 00 00 '  long @C_gpio_table+4
0e98(0385): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
0e9c(0386): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
0ea0(0387): 04 00 7c 5c '  jmp #LODA
0ea4(0388): 2c 33 00 00 '  long @C_gpio_register_chip_L000016
0ea8(0389): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
0eac(038a): 3e 7a 3c 04 '  wrword r10, r11 ' ASGNI2 reg
0eb0(038b): 44 7c bc a0 '  mov r11, r17 ' CVUI
0eb4(038c): 4e 7c bc 60 '  and r11, cviu_m2 ' zero extend
0eb8(038d): 01 7c fc d0 '  adds r11, #1 ' ADDI4 coni
0ebc(038e): 3e 88 bc a0 '  mov r17, r11 ' CVI, CVU or LOAD
0ec0(038f):             ' C_gpio_register_chip_13
0ec0(038f): 44 7c bc a0 '  mov r11, r17 ' CVUI
0ec4(0390): 4e 7c bc 60 '  and r11, cviu_m2 ' zero extend
0ec8(0391): 43 7a bc a0 '  mov r10, r16 ' CVII
0ecc(0392): 43 7a bc a0 '  mov r10, r16 ' CVII
0ed0(0393): 10 7a fc 2c '  shl r10, #16
0ed4(0394): 10 7a fc 38 '  sar r10, #16 ' sign extend
0ed8(0395): 35 78 bc a0 '  mov r9, r2
0edc(0396): 06 78 fc d0 '  adds r9, #6 ' ADDP4 coni
0ee0(0397): 3c 78 bc 04 '  rdword r9, r9 ' reg <- INDIRU2 reg
0ee4(0398): 4e 78 bc 60 '  and r9, cviu_m2 ' zero extend
0ee8(0399): 3c 7a bc d0 '  adds r10, r9 ' ADDI/P (1)
0eec(039a): 3d 7c 3c c3 '  cmps r11, r10 wz,wc
0ef0(039b): 18 00 7c 5c '  jmp #BR_B
0ef4(039c): e8 0d 00 00 '  long @C_gpio_register_chip_10 ' LTI4
0ef8(039d): 00 66 fc a0 '  mov r0, #0 ' RET coni
0efc(039e):             ' C_gpio_register_chip_3
0efc(039e): 23 00 7c 5c '  jmp #POPM
0f00(039f): 00 0e 03 00 '  long $30e00 ' restore registers
0f04(03a0): 0c 00 7c 5c '  jmp #RETN
0f08(03a1):             '  long ' align long
0f08(03a1):             ' C_gpio_unregister_chip ' <symbol:gpio_unregister_chip>
0f08(03a1): 22 00 7c 5c '  jmp #PSHM
0f0c(03a2): 00 0e 03 00 '  long $30e00 ' save registers
0f10(03a3): 35 7c bc a0 '  mov r11, r2
0f14(03a4): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
0f18(03a5): 3e 86 bc 04 '  rdword r16, r11 ' reg <- INDIRI2 reg
0f1c(03a6): 43 7c bc a0 '  mov r11, r16 ' CVII
0f20(03a7): 43 7c bc a0 '  mov r11, r16 ' CVII
0f24(03a8): 10 7c fc 2c '  shl r11, #16
0f28(03a9): 10 7c fc 38 '  sar r11, #16 ' sign extend
0f2c(03aa): 3e 88 bc a0 '  mov r17, r11 ' CVI, CVU or LOAD
0f30(03ab): 0e 00 7c 5c '  jmp #JMPA
0f34(03ac): 24 0f 00 00 '  long @C_gpio_unregister_chip_23 ' JUMPV addrg
0f38(03ad):             ' C_gpio_unregister_chip_20
0f38(03ad): 44 7c bc a0 '  mov r11, r17 ' CVUI
0f3c(03ae): 4e 7c bc 60 '  and r11, cviu_m2 ' zero extend
0f40(03af): 03 7c fc 2c '  shl r11, #3 ' LSHI4 coni
0f44(03b0): 04 00 7c 5c '  jmp #LODA
0f48(03b1): 78 35 00 00 '  long @C_gpio_table
0f4c(03b2): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
0f50(03b3): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
0f54(03b4): 04 00 7c 5c '  jmp #LODA
0f58(03b5): 28 33 00 00 '  long @C_gpio_unregister_chip_L000025
0f5c(03b6): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
0f60(03b7): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
0f64(03b8): 44 7c bc a0 '  mov r11, r17 ' CVUI
0f68(03b9): 4e 7c bc 60 '  and r11, cviu_m2 ' zero extend
0f6c(03ba): 03 7c fc 2c '  shl r11, #3 ' LSHI4 coni
0f70(03bb): 04 00 7c 5c '  jmp #LODA
0f74(03bc): 7c 35 00 00 '  long @C_gpio_table+4
0f78(03bd): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
0f7c(03be): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
0f80(03bf): 04 00 7c 5c '  jmp #LODA
0f84(03c0): 2c 33 00 00 '  long @C_gpio_register_chip_L000016
0f88(03c1): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
0f8c(03c2): 3e 7a 3c 04 '  wrword r10, r11 ' ASGNI2 reg
0f90(03c3): 44 7c bc a0 '  mov r11, r17 ' CVUI
0f94(03c4): 4e 7c bc 60 '  and r11, cviu_m2 ' zero extend
0f98(03c5): 01 7c fc d0 '  adds r11, #1 ' ADDI4 coni
0f9c(03c6): 3e 88 bc a0 '  mov r17, r11 ' CVI, CVU or LOAD
0fa0(03c7):             ' C_gpio_unregister_chip_23
0fa0(03c7): 44 7c bc a0 '  mov r11, r17 ' CVUI
0fa4(03c8): 4e 7c bc 60 '  and r11, cviu_m2 ' zero extend
0fa8(03c9): 43 7a bc a0 '  mov r10, r16 ' CVII
0fac(03ca): 43 7a bc a0 '  mov r10, r16 ' CVII
0fb0(03cb): 10 7a fc 2c '  shl r10, #16
0fb4(03cc): 10 7a fc 38 '  sar r10, #16 ' sign extend
0fb8(03cd): 35 78 bc a0 '  mov r9, r2
0fbc(03ce): 06 78 fc d0 '  adds r9, #6 ' ADDP4 coni
0fc0(03cf): 3c 78 bc 04 '  rdword r9, r9 ' reg <- INDIRU2 reg
0fc4(03d0): 4e 78 bc 60 '  and r9, cviu_m2 ' zero extend
0fc8(03d1): 3c 7a bc d0 '  adds r10, r9 ' ADDI/P (1)
0fcc(03d2): 3d 7c 3c c3 '  cmps r11, r10 wz,wc
0fd0(03d3): 18 00 7c 5c '  jmp #BR_B
0fd4(03d4): bc 0e 00 00 '  long @C_gpio_unregister_chip_20 ' LTI4
0fd8(03d5): 00 66 fc a0 '  mov r0, #0 ' RET coni
0fdc(03d6): 23 00 7c 5c '  jmp #POPM
0fe0(03d7): 00 0e 03 00 '  long $30e00 ' restore registers
0fe4(03d8): 0c 00 7c 5c '  jmp #RETN
0fe8(03d9):             '  long ' align long
0fe8(03d9):             ' C_tmpfile7l3ION_4d07ee05_bbos_driver_bootstrapper_L000008 ' <symbol:bbos_driver_bootstrapper>
0fe8(03d9): 04 00 7c 5c '  jmp #LODA
0fec(03da): 90 3d 00 00 '  long @C_tmpfiler5stRb_4d07ee05_driver_thread_id_L000003
0ff0(03db): 2e 6c 3c 04 '  wrword r3, RI ' ASGNI2 addrg
0ff4(03dc): 04 00 7c 5c '  jmp #LODA
0ff8(03dd): 8c 3d 00 00 '  long @C_tmpfilerULIfI_4d07ee05_driver_listen_port_id_L000004
0ffc(03de): 2e 6a 3c 04 '  wrword r2, RI ' ASGNI2 addrg
1000(03df): 0c 00 7c 5c '  jmp #RETN
1004(03e0):             '  long ' align long
1004(03e0):             ' C_tmpfile1bMZck_4d07ee05_bbos_driver_messenger_L000010 ' <symbol:bbos_driver_messenger>
1004(03e0): 22 00 7c 5c '  jmp #PSHM
1008(03e1): 00 08 00 00 '  long $800 ' save registers
100c(03e2): 04 00 7c 5c '  jmp #LODA
1010(03e3): 8c 3d 00 00 '  long @C_tmpfilerULIfI_4d07ee05_driver_listen_port_id_L000004
1014(03e4): 2e 7c bc 04 '  rdword r11, RI ' reg <- INDIRI2 addrg
1018(03e5): 3e 6a bc a0 '  mov r2, r11 ' CVII
101c(03e6): 3e 6a bc a0 '  mov r2, r11 ' CVII
1020(03e7): 10 6a fc 2c '  shl r2, #16
1024(03e8): 10 6a fc 38 '  sar r2, #16 ' sign extend
1028(03e9): 04 5e fc a0 '  mov BC, #4 ' arg size
102c(03ea): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
1030(03eb): 0b 00 7c 5c '  jmp #CALA
1034(03ec): 80 02 00 00 '  long @C___bbos_port_is_empty
1038(03ed): 04 58 fc 80 '  add SP, #4 ' CALL addrg
103c(03ee): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
1040(03ef): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
1044(03f0): 00 7c 7c c2 '  cmps r11,  #0 wz
1048(03f1): 13 00 7c 5c '  jmp #BR_Z
104c(03f2): e8 0f 00 00 '  long @C_tmpfile1bMZck_4d07ee05_bbos_driver_messenger_L000010_12 ' EQI4
1050(03f3): 00 5e fc a0 '  mov BC, #0 ' arg size
1054(03f4): 0b 00 7c 5c '  jmp #CALA
1058(03f5): 18 13 00 00 '  long @C_tmpfile3ZBd2K_4d07ee05_bbos_driver_idle_L000006 ' CALL addrg
105c(03f6): 0e 00 7c 5c '  jmp #JMPA
1060(03f7): b4 10 00 00 '  long @C_tmpfile1bMZck_4d07ee05_bbos_driver_messenger_L000010_11 ' JUMPV addrg
1064(03f8):             ' C_tmpfile1bMZck_4d07ee05_bbos_driver_messenger_L000010_12
1064(03f8): 04 00 7c 5c '  jmp #LODA
1068(03f9): 78 3d 00 00 '  long @C_tmpfileZ46XDe_4d07ee05_driver_message_L000005
106c(03fa): 2e 6a bc a0 '  mov r2, RI ' reg ARG ADDRG
1070(03fb): 04 00 7c 5c '  jmp #LODA
1074(03fc): 8c 3d 00 00 '  long @C_tmpfilerULIfI_4d07ee05_driver_listen_port_id_L000004
1078(03fd): 2e 7c bc 04 '  rdword r11, RI ' reg <- INDIRI2 addrg
107c(03fe): 3e 6c bc a0 '  mov r3, r11 ' CVII
1080(03ff): 3e 6c bc a0 '  mov r3, r11 ' CVII
1084(0400): 10 6c fc 2c '  shl r3, #16
1088(0401): 10 6c fc 38 '  sar r3, #16 ' sign extend
108c(0402): 08 5e fc a0 '  mov BC, #8 ' arg size
1090(0403): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
1094(0404): 0b 00 7c 5c '  jmp #CALA
1098(0405): d0 04 00 00 '  long @C___bbos_port_read
109c(0406): 08 58 fc 80 '  add SP, #8 ' CALL addrg
10a0(0407): 04 00 7c 5c '  jmp #LODA
10a4(0408): 88 3d 00 00 '  long @C_tmpfileZ46XDe_4d07ee05_driver_message_L000005+16
10a8(0409): 2e 6a bc 08 '  rdlong r2, RI ' reg ARG INDIR ADDRG
10ac(040a): 04 00 7c 5c '  jmp #LODA
10b0(040b): 78 3d 00 00 '  long @C_tmpfileZ46XDe_4d07ee05_driver_message_L000005
10b4(040c): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRG
10b8(040d): 08 5e fc a0 '  mov BC, #8 ' arg size
10bc(040e): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
10c0(040f): 0b 00 7c 5c '  jmp #CALA
10c4(0410): d0 13 00 00 '  long @C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007
10c8(0411): 08 58 fc 80 '  add SP, #8 ' CALL addrg
10cc(0412): 04 00 7c 5c '  jmp #LODA
10d0(0413): 80 3d 00 00 '  long @C_tmpfileZ46XDe_4d07ee05_driver_message_L000005+8
10d4(0414): 2e 7c bc 04 '  rdword r11, RI ' reg <- INDIRI2 addrg
10d8(0415): 10 7c fc 2c '  shl r11, #16
10dc(0416): 10 7c fc 38 '  sar r11, #16 ' sign extend
10e0(0417): 00 7c 7c c2 '  cmps r11,  #0 wz
10e4(0418): 13 00 7c 5c '  jmp #BR_Z
10e8(0419): 78 10 00 00 '  long @C_tmpfile1bMZck_4d07ee05_bbos_driver_messenger_L000010_15 ' EQI4
10ec(041a): 0e 00 7c 5c '  jmp #JMPA
10f0(041b): b4 10 00 00 '  long @C_tmpfile1bMZck_4d07ee05_bbos_driver_messenger_L000010_11 ' JUMPV addrg
10f4(041c):             ' C_tmpfile1bMZck_4d07ee05_bbos_driver_messenger_L000010_15
10f4(041c): 04 00 7c 5c '  jmp #LODA
10f8(041d): 78 3d 00 00 '  long @C_tmpfileZ46XDe_4d07ee05_driver_message_L000005
10fc(041e): 2e 6a bc a0 '  mov r2, RI ' reg ARG ADDRG
1100(041f): 04 00 7c 5c '  jmp #LODA
1104(0420): 80 3d 00 00 '  long @C_tmpfileZ46XDe_4d07ee05_driver_message_L000005+8
1108(0421): 2e 7c bc 04 '  rdword r11, RI ' reg <- INDIRI2 addrg
110c(0422): 3e 6c bc a0 '  mov r3, r11 ' CVII
1110(0423): 3e 6c bc a0 '  mov r3, r11 ' CVII
1114(0424): 10 6c fc 2c '  shl r3, #16
1118(0425): 10 6c fc 38 '  sar r3, #16 ' sign extend
111c(0426): 08 5e fc a0 '  mov BC, #8 ' arg size
1120(0427): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
1124(0428): 0b 00 7c 5c '  jmp #CALA
1128(0429): f8 02 00 00 '  long @C___bbos_port_write
112c(042a): 08 58 fc 80 '  add SP, #8 ' CALL addrg
1130(042b):             ' C_tmpfile1bMZck_4d07ee05_bbos_driver_messenger_L000010_11
1130(042b): 23 00 7c 5c '  jmp #POPM
1134(042c): 00 08 00 00 '  long $800 ' restore registers
1138(042d): 0c 00 7c 5c '  jmp #RETN
113c(042e):             '  long ' align long
113c(042e):             ' C_tmpfilezxjEZm_4d07ee05_gpio_direction_input_L000021 ' <symbol:gpio_direction_input>
113c(042e): 09 00 7c 5c '  jmp #NEWF
1140(042f): 08 58 fc 84 '  sub SP, #8
1144(0430): 22 00 7c 5c '  jmp #PSHM
1148(0431): 00 0c 02 00 '  long $20c00 ' save registers
114c(0432): 35 88 bc a0 '  mov r17, r2 ' reg var <- reg arg
1150(0433): 44 7c bc a0 '  mov r11, r17
1154(0434): 03 7c fc 2c '  shl r11, #3 ' LSHU4 coni
1158(0435): 04 00 7c 5c '  jmp #LODA
115c(0436): 78 35 00 00 '  long @C_gpio_table
1160(0437): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
1164(0438): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
1168(0439): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
116c(043a): 05 00 7c 5c '  jmp #LODF
1170(043b): fc ff ff ff '  long -4
1174(043c): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
1178(043d): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
117c(043e): 44 7a bc a0 '  mov r10, r17 ' CVI, CVU or LOAD
1180(043f): 3d 7c bc 2c '  shl r11, r10 ' LSHI/U (1)
1184(0440): 05 00 7c 5c '  jmp #LODF
1188(0441): f8 ff ff ff '  long -8
118c(0442): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNU4 addrl
1190(0443): 2d 7c bc a0 '  mov r11, FP
1194(0444): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
1198(0445): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
119c(0446): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
11a0(0447): 3e 7c bc 04 '  rdword r11, r11 ' reg <- INDIRI2 reg
11a4(0448): 10 7c fc 2c '  shl r11, #16
11a8(0449): 10 7c fc 38 '  sar r11, #16 ' sign extend
11ac(044a): 00 7c 7c c2 '  cmps r11,  #0 wz
11b0(044b): 14 00 7c 5c '  jmp #BRNZ
11b4(044c): 6c 11 00 00 '  long @C_tmpfilezxjEZm_4d07ee05_gpio_direction_input_L000021_23 ' NEI4
11b8(044d): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
11bc(044e): 2d 5c bc a0 '  mov RI, FP
11c0(044f): 08 5c fc 84 '  sub RI, #-(-8)
11c4(0450): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRLi
11c8(0451): 08 5e fc a0 '  mov BC, #8 ' arg size
11cc(0452): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
11d0(0453): 0b 00 7c 5c '  jmp #CALA
11d4(0454): 54 19 00 00 '  long @C__dira
11d8(0455): 08 58 fc 80 '  add SP, #8 ' CALL addrg
11dc(0456): 00 66 fc a0 '  mov r0, #0 ' RET coni
11e0(0457): 0e 00 7c 5c '  jmp #JMPA
11e4(0458): 70 11 00 00 '  long @C_tmpfilezxjEZm_4d07ee05_gpio_direction_input_L000021_22 ' JUMPV addrg
11e8(0459):             ' C_tmpfilezxjEZm_4d07ee05_gpio_direction_input_L000021_23
11e8(0459): 01 66 fc a0 '  mov r0, #1 ' RET coni
11ec(045a):             ' C_tmpfilezxjEZm_4d07ee05_gpio_direction_input_L000021_22
11ec(045a): 23 00 7c 5c '  jmp #POPM
11f0(045b): 00 0c 02 00 '  long $20c00 ' restore registers
11f4(045c): 08 58 fc 80 '  add SP, #8 ' framesize
11f8(045d): 0a 00 7c 5c '  jmp #RETF
11fc(045e):             '  long ' align long
11fc(045e):             ' C_tmpfileLmH0nT_4d07ee05_gpio_get_value_L000025 ' <symbol:gpio_get_value>
11fc(045e): 22 00 7c 5c '  jmp #PSHM
1200(045f): 00 0e 02 00 '  long $20e00 ' save registers
1204(0460): 35 88 bc a0 '  mov r17, r2 ' reg var <- reg arg
1208(0461): 00 5e fc a0 '  mov BC, #0 ' arg size
120c(0462): 0b 00 7c 5c '  jmp #CALA
1210(0463): 84 30 00 00 '  long @C__ina ' CALL addrg
1214(0464): 01 7a fc a0 '  mov r10, #1 ' reg <- coni
1218(0465): 44 78 bc a0 '  mov r9, r17 ' CVI, CVU or LOAD
121c(0466): 3c 7a bc 2c '  shl r10, r9 ' LSHI/U (1)
1220(0467): 33 7c bc a0 '  mov r11, r0 ' BANDI/U
1224(0468): 3d 7c bc 60 '  and r11, r10 ' BANDI/U (3)
1228(0469): 3e 66 bc a0 '  mov r0, r11 ' CVII
122c(046a): 3e 66 bc a0 '  mov r0, r11 ' CVII
1230(046b): 10 66 fc 2c '  shl r0, #16
1234(046c): 10 66 fc 38 '  sar r0, #16 ' sign extend
1238(046d): 23 00 7c 5c '  jmp #POPM
123c(046e): 00 0e 02 00 '  long $20e00 ' restore registers
1240(046f): 0c 00 7c 5c '  jmp #RETN
1244(0470):             '  long ' align long
1244(0470):             ' C_tmpfilehyJnMp_4d07ee05_gpio_set_value_L000027 ' <symbol:gpio_set_value>
1244(0470): 22 00 7c 5c '  jmp #PSHM
1248(0471): 00 ec 03 00 '  long $3ec00 ' save registers
124c(0472): 36 88 bc a0 '  mov r17, r3 ' reg var <- reg arg
1250(0473): 35 86 bc a0 '  mov r16, r2 ' reg var <- reg arg
1254(0474): 00 5e fc a0 '  mov BC, #0 ' arg size
1258(0475): 0b 00 7c 5c '  jmp #CALA
125c(0476): 84 30 00 00 '  long @C__ina ' CALL addrg
1260(0477): 33 84 bc a0 '  mov r15, r0 ' CVI, CVU or LOAD
1264(0478): 00 86 7c c2 '  cmps r16,  #0 wz
1268(0479): 14 00 7c 5c '  jmp #BRNZ
126c(047a): 00 12 00 00 '  long @C_tmpfilehyJnMp_4d07ee05_gpio_set_value_L000027_30 ' NEI4
1270(047b): 01 82 fc a0 '  mov r14, #1 ' reg <- coni
1274(047c): 0e 00 7c 5c '  jmp #JMPA
1278(047d): 04 12 00 00 '  long @C_tmpfilehyJnMp_4d07ee05_gpio_set_value_L000027_31 ' JUMPV addrg
127c(047e):             ' C_tmpfilehyJnMp_4d07ee05_gpio_set_value_L000027_30
127c(047e): 00 82 fc a0 '  mov r14, #0 ' reg <- coni
1280(047f):             ' C_tmpfilehyJnMp_4d07ee05_gpio_set_value_L000027_31
1280(047f): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
1284(0480): 41 5c bc a0 '  mov RI, r14
1288(0481): 3e 5c bc 2c '  shl RI, r11
128c(0482): 2e 7c bc a0 '  mov r11, RI ' SHLI/U (2)
1290(0483): 4c 7c bc 6c '  xor r11, all_1s ' BCOMI4
1294(0484): 3e 84 bc 60 '  and r15, r11 ' BANDI/U (1)
1298(0485): 00 86 7c c2 '  cmps r16,  #0 wz
129c(0486): 13 00 7c 5c '  jmp #BR_Z
12a0(0487): 34 12 00 00 '  long @C_tmpfilehyJnMp_4d07ee05_gpio_set_value_L000027_33 ' EQI4
12a4(0488): 01 80 fc a0 '  mov r13, #1 ' reg <- coni
12a8(0489): 0e 00 7c 5c '  jmp #JMPA
12ac(048a): 38 12 00 00 '  long @C_tmpfilehyJnMp_4d07ee05_gpio_set_value_L000027_34 ' JUMPV addrg
12b0(048b):             ' C_tmpfilehyJnMp_4d07ee05_gpio_set_value_L000027_33
12b0(048b): 00 80 fc a0 '  mov r13, #0 ' reg <- coni
12b4(048c):             ' C_tmpfilehyJnMp_4d07ee05_gpio_set_value_L000027_34
12b4(048c): 40 7a bc a0 '  mov r10, r13 ' LSHI/U
12b8(048d): 44 7a bc 2c '  shl r10, r17 ' LSHI/U (3)
12bc(048e): 3d 84 bc 68 '  or r15, r10 ' BORI/U (1)
12c0(048f): 42 6a bc a0 '  mov r2, r15 ' CVI, CVU or LOAD
12c4(0490): 01 7a fc a0 '  mov r10, #1 ' reg <- coni
12c8(0491): 3d 7c bc a0 '  mov r11, r10 ' LSHI/U
12cc(0492): 44 7c bc 2c '  shl r11, r17 ' LSHI/U (3)
12d0(0493): 3e 6c bc a0 '  mov r3, r11 ' CVI, CVU or LOAD
12d4(0494): 08 5e fc a0 '  mov BC, #8 ' arg size
12d8(0495): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
12dc(0496): 0b 00 7c 5c '  jmp #CALA
12e0(0497): 8c 30 00 00 '  long @C__outa
12e4(0498): 08 58 fc 80 '  add SP, #8 ' CALL addrg
12e8(0499): 00 66 fc a0 '  mov r0, #0 ' RET coni
12ec(049a): 23 00 7c 5c '  jmp #POPM
12f0(049b): 00 ec 03 00 '  long $3ec00 ' restore registers
12f4(049c): 0c 00 7c 5c '  jmp #RETN
12f8(049d):             '  long ' align long
12f8(049d):             ' C_tmpfile5OFMaW_4d07ee05_gpio_direction_output_L000035 ' <symbol:gpio_direction_output>
12f8(049d): 09 00 7c 5c '  jmp #NEWF
12fc(049e): 04 58 fc 84 '  sub SP, #4
1300(049f): 22 00 7c 5c '  jmp #PSHM
1304(04a0): 00 8c 03 00 '  long $38c00 ' save registers
1308(04a1): 36 88 bc a0 '  mov r17, r3 ' reg var <- reg arg
130c(04a2): 35 86 bc a0 '  mov r16, r2 ' reg var <- reg arg
1310(04a3): 44 7c bc a0 '  mov r11, r17
1314(04a4): 03 7c fc 2c '  shl r11, #3 ' LSHU4 coni
1318(04a5): 04 00 7c 5c '  jmp #LODA
131c(04a6): 78 35 00 00 '  long @C_gpio_table
1320(04a7): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
1324(04a8): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
1328(04a9): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
132c(04aa): 05 00 7c 5c '  jmp #LODF
1330(04ab): fc ff ff ff '  long -4
1334(04ac): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
1338(04ad): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
133c(04ae): 44 7a bc a0 '  mov r10, r17 ' CVI, CVU or LOAD
1340(04af): 3d 7c bc 2c '  shl r11, r10 ' LSHI/U (1)
1344(04b0): 3e 84 bc a0 '  mov r15, r11 ' CVI, CVU or LOAD
1348(04b1): 42 6a bc a0 '  mov r2, r15 ' CVI, CVU or LOAD
134c(04b2): 42 6c bc a0 '  mov r3, r15 ' CVI, CVU or LOAD
1350(04b3): 08 5e fc a0 '  mov BC, #8 ' arg size
1354(04b4): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
1358(04b5): 0b 00 7c 5c '  jmp #CALA
135c(04b6): 54 19 00 00 '  long @C__dira
1360(04b7): 08 58 fc 80 '  add SP, #8 ' CALL addrg
1364(04b8): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
1368(04b9): 44 6c bc a0 '  mov r3, r17 ' CVI, CVU or LOAD
136c(04ba): 08 5e fc a0 '  mov BC, #8 ' arg size
1370(04bb): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
1374(04bc): 0b 00 7c 5c '  jmp #CALA
1378(04bd): c8 11 00 00 '  long @C_tmpfilehyJnMp_4d07ee05_gpio_set_value_L000027
137c(04be): 08 58 fc 80 '  add SP, #8 ' CALL addrg
1380(04bf): 00 66 fc a0 '  mov r0, #0 ' RET coni
1384(04c0): 23 00 7c 5c '  jmp #POPM
1388(04c1): 00 8c 03 00 '  long $38c00 ' restore registers
138c(04c2): 04 58 fc 80 '  add SP, #4 ' framesize
1390(04c3): 0a 00 7c 5c '  jmp #RETF
1394(04c4):             '  long ' align long
1394(04c4):             ' C_tmpfile3ZBd2K_4d07ee05_bbos_driver_idle_L000006 ' <symbol:bbos_driver_idle>
1394(04c4): 0c 00 7c 5c '  jmp #RETN
1398(04c5):             '  long ' align long
1398(04c5):             ' C_p8x32a_gpio_init ' <symbol:p8x32a_gpio_init>
1398(04c5): 22 00 7c 5c '  jmp #PSHM
139c(04c6): 00 08 03 00 '  long $30800 ' save registers
13a0(04c7): 36 88 bc a0 '  mov r17, r3 ' reg var <- reg arg
13a4(04c8): 35 86 bc a0 '  mov r16, r2 ' reg var <- reg arg
13a8(04c9): 43 6a bc a0 '  mov r2, r16 ' CVII
13ac(04ca): 10 6a fc 2c '  shl r2, #16
13b0(04cb): 10 6a fc 38 '  sar r2, #16 ' sign extend
13b4(04cc): 44 6c bc a0 '  mov r3, r17 ' CVII
13b8(04cd): 44 6c bc a0 '  mov r3, r17 ' CVII
13bc(04ce): 10 6c fc 2c '  shl r3, #16
13c0(04cf): 10 6c fc 38 '  sar r3, #16 ' sign extend
13c4(04d0): 08 5e fc a0 '  mov BC, #8 ' arg size
13c8(04d1): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
13cc(04d2): 0b 00 7c 5c '  jmp #CALA
13d0(04d3): 6c 0f 00 00 '  long @C_tmpfile7l3ION_4d07ee05_bbos_driver_bootstrapper_L000008
13d4(04d4): 08 58 fc 80 '  add SP, #8 ' CALL addrg
13d8(04d5): 04 00 7c 5c '  jmp #LODA
13dc(04d6): 18 34 00 00 '  long @C_p8x32a_gpio_banks
13e0(04d7): 2e 6a bc a0 '  mov r2, RI ' reg ARG ADDRG
13e4(04d8): 04 5e fc a0 '  mov BC, #4 ' arg size
13e8(04d9): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
13ec(04da): 0b 00 7c 5c '  jmp #CALA
13f0(04db): 1c 0d 00 00 '  long @C_gpio_register_chip
13f4(04dc): 04 58 fc 80 '  add SP, #4 ' CALL addrg
13f8(04dd): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
13fc(04de): 10 7c fc 2c '  shl r11, #16
1400(04df): 10 7c fc 38 '  sar r11, #16 ' sign extend
1404(04e0): 00 7c 7c c2 '  cmps r11,  #0 wz
1408(04e1): 13 00 7c 5c '  jmp #BR_Z
140c(04e2): b4 13 00 00 '  long @C_p8x32a_gpio_init_39 ' EQI4
1410(04e3): 04 00 7c 5c '  jmp #LODA
1414(04e4): 5c 33 00 00 '  long @C_p8x32a_gpio_init_41_L000042
1418(04e5): 2e 6a bc a0 '  mov r2, RI ' reg ARG ADDRG
141c(04e6): 04 5e fc a0 '  mov BC, #4 ' arg size
1420(04e7): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
1424(04e8): 0b 00 7c 5c '  jmp #CALA
1428(04e9): 9c 30 00 00 '  long @C_printf
142c(04ea): 04 58 fc 80 '  add SP, #4 ' CALL addrg
1430(04eb):             ' C_p8x32a_gpio_init_39
1430(04eb): 23 00 7c 5c '  jmp #POPM
1434(04ec): 00 08 03 00 '  long $30800 ' restore registers
1438(04ed): 0c 00 7c 5c '  jmp #RETN
143c(04ee):             '  long ' align long
143c(04ee):             ' C_p8x32a_gpio_messenger ' <symbol:p8x32a_gpio_messenger>
143c(04ee): 00 5e fc a0 '  mov BC, #0 ' arg size
1440(04ef): 0b 00 7c 5c '  jmp #CALA
1444(04f0): 88 0f 00 00 '  long @C_tmpfile1bMZck_4d07ee05_bbos_driver_messenger_L000010 ' CALL addrg
1448(04f1): 0c 00 7c 5c '  jmp #RETN
144c(04f2):             '  long ' align long
144c(04f2):             ' C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007 ' <symbol:bbos_driver_demultiplexer>
144c(04f2): 22 00 7c 5c '  jmp #PSHM
1450(04f3): 00 8c 03 00 '  long $38c00 ' save registers
1454(04f4): 36 88 bc a0 '  mov r17, r3 ' reg var <- reg arg
1458(04f5): 35 86 bc a0 '  mov r16, r2 ' reg var <- reg arg
145c(04f6): 43 84 bc a0 '  mov r15, r16 ' CVI, CVU or LOAD
1460(04f7): 00 88 7c c2 '  cmps r17,  #0 wz
1464(04f8): 13 00 7c 5c '  jmp #BR_Z
1468(04f9): 04 14 00 00 '  long @C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_47 ' EQI4
146c(04fa): 01 88 7c c2 '  cmps r17,  #1 wz
1470(04fb): 13 00 7c 5c '  jmp #BR_Z
1474(04fc): dc 14 00 00 '  long @C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_57 ' EQI4
1478(04fd): 0e 00 7c 5c '  jmp #JMPA
147c(04fe): 80 15 00 00 '  long @C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_45 ' JUMPV addrg
1480(04ff):             ' C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_47
1480(04ff): 42 7c bc a0 '  mov r11, r15
1484(0500): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
1488(0501): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRU4 reg
148c(0502): 03 7c fc 2c '  shl r11, #3 ' LSHU4 coni
1490(0503): 04 00 7c 5c '  jmp #LODA
1494(0504): 7c 35 00 00 '  long @C_gpio_table+4
1498(0505): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
149c(0506): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
14a0(0507): 3e 7c bc 04 '  rdword r11, r11 ' reg <- INDIRI2 reg
14a4(0508): 10 7c fc 2c '  shl r11, #16
14a8(0509): 10 7c fc 38 '  sar r11, #16 ' sign extend
14ac(050a): 04 00 7c 5c '  jmp #LODA
14b0(050b): 58 33 00 00 '  long @C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L00000_L000051
14b4(050c): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
14b8(050d): 3d 7c 3c c2 '  cmps r11, r10 wz
14bc(050e): 13 00 7c 5c '  jmp #BR_Z
14c0(050f): 60 14 00 00 '  long @C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_48 ' EQI4
14c4(0510): 42 7c bc a0 '  mov r11, r15
14c8(0511): 0c 7c fc d0 '  adds r11, #12 ' ADDP4 coni
14cc(0512): 01 7a fc a0 '  mov r10, #1 ' reg <- coni
14d0(0513): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNI4 reg
14d4(0514): 0e 00 7c 5c '  jmp #JMPA
14d8(0515): 24 17 00 00 '  long @C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_44 ' JUMPV addrg
14dc(0516):             ' C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_48
14dc(0516): 42 7c bc a0 '  mov r11, r15
14e0(0517): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
14e4(0518): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRU4 reg
14e8(0519): 03 7c fc 2c '  shl r11, #3 ' LSHU4 coni
14ec(051a): 04 00 7c 5c '  jmp #LODA
14f0(051b): 7c 35 00 00 '  long @C_gpio_table+4
14f4(051c): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
14f8(051d): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
14fc(051e): 42 7a bc 04 '  rdword r10, r15 ' reg <- INDIRU2 reg
1500(051f): 4e 7a bc 60 '  and r10, cviu_m2 ' zero extend
1504(0520): 3e 7a 3c 04 '  wrword r10, r11 ' ASGNI2 reg
1508(0521): 42 7c bc 04 '  rdword r11, r15 ' reg <- INDIRU2 reg
150c(0522): 3e 6a bc a0 '  mov r2, r11 ' CVUI
1510(0523): 4e 6a bc 60 '  and r2, cviu_m2 ' zero extend
1514(0524): 42 7c bc a0 '  mov r11, r15
1518(0525): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
151c(0526): 3e 6c bc 08 '  rdlong r3, r11 ' reg <- INDIRU4 reg
1520(0527): 04 00 7c 5c '  jmp #LODA
1524(0528): 40 33 00 00 '  long @C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L00000_L000056
1528(0529): 2e 6e bc a0 '  mov r4, RI ' reg ARG ADDRG
152c(052a): 0c 5e fc a0 '  mov BC, #12 ' arg size
1530(052b): 0c 58 fc 84 '  sub SP, #12 ' stack space for reg ARGs
1534(052c): 0b 00 7c 5c '  jmp #CALA
1538(052d): 9c 30 00 00 '  long @C_printf
153c(052e): 0c 58 fc 80 '  add SP, #12 ' CALL addrg
1540(052f): 42 7c bc a0 '  mov r11, r15
1544(0530): 0c 7c fc d0 '  adds r11, #12 ' ADDP4 coni
1548(0531): 00 7a fc a0 '  mov r10, #0 ' reg <- coni
154c(0532): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNI4 reg
1550(0533): 0e 00 7c 5c '  jmp #JMPA
1554(0534): 24 17 00 00 '  long @C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_44 ' JUMPV addrg
1558(0535):             ' C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_57
1558(0535): 42 7c bc a0 '  mov r11, r15
155c(0536): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
1560(0537): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRU4 reg
1564(0538): 03 7c fc 2c '  shl r11, #3 ' LSHU4 coni
1568(0539): 04 00 7c 5c '  jmp #LODA
156c(053a): 7c 35 00 00 '  long @C_gpio_table+4
1570(053b): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
1574(053c): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
1578(053d): 3e 7c bc 04 '  rdword r11, r11 ' reg <- INDIRI2 reg
157c(053e): 10 7c fc 2c '  shl r11, #16
1580(053f): 10 7c fc 38 '  sar r11, #16 ' sign extend
1584(0540): 04 00 7c 5c '  jmp #LODA
1588(0541): 58 33 00 00 '  long @C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L00000_L000051
158c(0542): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
1590(0543): 3d 7c 3c c2 '  cmps r11, r10 wz
1594(0544): 14 00 7c 5c '  jmp #BRNZ
1598(0545): 38 15 00 00 '  long @C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_58 ' NEI4
159c(0546): 42 7c bc a0 '  mov r11, r15
15a0(0547): 0c 7c fc d0 '  adds r11, #12 ' ADDP4 coni
15a4(0548): 01 7a fc a0 '  mov r10, #1 ' reg <- coni
15a8(0549): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNI4 reg
15ac(054a): 0e 00 7c 5c '  jmp #JMPA
15b0(054b): 24 17 00 00 '  long @C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_44 ' JUMPV addrg
15b4(054c):             ' C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_58
15b4(054c): 42 7c bc a0 '  mov r11, r15
15b8(054d): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
15bc(054e): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRU4 reg
15c0(054f): 03 7c fc 2c '  shl r11, #3 ' LSHU4 coni
15c4(0550): 04 00 7c 5c '  jmp #LODA
15c8(0551): 7c 35 00 00 '  long @C_gpio_table+4
15cc(0552): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
15d0(0553): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
15d4(0554): 04 00 7c 5c '  jmp #LODA
15d8(0555): 58 33 00 00 '  long @C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L00000_L000051
15dc(0556): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
15e0(0557): 3e 7a 3c 04 '  wrword r10, r11 ' ASGNI2 reg
15e4(0558): 42 7c bc a0 '  mov r11, r15
15e8(0559): 0c 7c fc d0 '  adds r11, #12 ' ADDP4 coni
15ec(055a): 00 7a fc a0 '  mov r10, #0 ' reg <- coni
15f0(055b): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNI4 reg
15f4(055c): 0e 00 7c 5c '  jmp #JMPA
15f8(055d): 24 17 00 00 '  long @C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_44 ' JUMPV addrg
15fc(055e):             ' C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_45
15fc(055e): 42 7c bc a0 '  mov r11, r15
1600(055f): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
1604(0560): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRU4 reg
1608(0561): 03 7c fc 2c '  shl r11, #3 ' LSHU4 coni
160c(0562): 04 00 7c 5c '  jmp #LODA
1610(0563): 7c 35 00 00 '  long @C_gpio_table+4
1614(0564): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
1618(0565): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
161c(0566): 3e 7c bc 04 '  rdword r11, r11 ' reg <- INDIRI2 reg
1620(0567): 10 7c fc 2c '  shl r11, #16
1624(0568): 10 7c fc 38 '  sar r11, #16 ' sign extend
1628(0569): 42 7a bc 04 '  rdword r10, r15 ' reg <- INDIRU2 reg
162c(056a): 4e 7a bc 60 '  and r10, cviu_m2 ' zero extend
1630(056b): 3d 7c 3c c2 '  cmps r11, r10 wz
1634(056c): 13 00 7c 5c '  jmp #BR_Z
1638(056d): d8 15 00 00 '  long @C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_46 ' EQI4
163c(056e): 42 7c bc a0 '  mov r11, r15
1640(056f): 0c 7c fc d0 '  adds r11, #12 ' ADDP4 coni
1644(0570): 01 7a fc a0 '  mov r10, #1 ' reg <- coni
1648(0571): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNI4 reg
164c(0572): 0e 00 7c 5c '  jmp #JMPA
1650(0573): 24 17 00 00 '  long @C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_44 ' JUMPV addrg
1654(0574):             ' C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_46
1654(0574): 02 7c fc a0 '  mov r11, #2 ' reg <- coni
1658(0575): 3e 88 3c c3 '  cmps r17, r11 wz,wc
165c(0576): 18 00 7c 5c '  jmp #BR_B
1660(0577): 14 17 00 00 '  long @C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_67 ' LTI4
1664(0578): 05 88 7c c3 '  cmps r17,  #5 wz,wc
1668(0579): 16 00 7c 5c '  jmp #BR_A
166c(057a): 14 17 00 00 '  long @C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_67 ' GTI4
1670(057b): 44 7c bc a0 '  mov r11, r17
1674(057c): 02 7c fc 2c '  shl r11, #2 ' LSHI4 coni
1678(057d): 04 00 7c 5c '  jmp #LODA
167c(057e): 28 33 00 00 '  long @C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L00000_L000074-8
1680(057f): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
1684(0580): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
1688(0581): 3e 5c bc 08 '  rdlong RI, r11
168c(0582): 0f 00 7c 5c '  jmp #JMPI ' JUMPV INDIR reg
1690(0583):             ' C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_68
1690(0583): 42 7c bc a0 '  mov r11, r15
1694(0584): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
1698(0585): 3e 6a bc 08 '  rdlong r2, r11 ' reg <- INDIRU4 reg
169c(0586): 04 5e fc a0 '  mov BC, #4 ' arg size
16a0(0587): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
16a4(0588): 0b 00 7c 5c '  jmp #CALA
16a8(0589): c0 10 00 00 '  long @C_tmpfilezxjEZm_4d07ee05_gpio_direction_input_L000021
16ac(058a): 04 58 fc 80 '  add SP, #4 ' CALL addrg
16b0(058b): 42 7a bc a0 '  mov r10, r15
16b4(058c): 0c 7a fc d0 '  adds r10, #12 ' ADDP4 coni
16b8(058d): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
16bc(058e): 10 7c fc 2c '  shl r11, #16
16c0(058f): 10 7c fc 38 '  sar r11, #16 ' sign extend
16c4(0590): 3d 7c 3c 08 '  wrlong r11, r10 ' ASGNI4 reg
16c8(0591):             ' C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_69
16c8(0591): 42 7c bc a0 '  mov r11, r15
16cc(0592): 08 7c fc d0 '  adds r11, #8 ' ADDP4 coni
16d0(0593): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRU4 reg
16d4(0594): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
16d8(0595): 42 7c bc a0 '  mov r11, r15
16dc(0596): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
16e0(0597): 3e 6c bc 08 '  rdlong r3, r11 ' reg <- INDIRU4 reg
16e4(0598): 08 5e fc a0 '  mov BC, #8 ' arg size
16e8(0599): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
16ec(059a): 0b 00 7c 5c '  jmp #CALA
16f0(059b): 7c 12 00 00 '  long @C_tmpfile5OFMaW_4d07ee05_gpio_direction_output_L000035
16f4(059c): 08 58 fc 80 '  add SP, #8 ' CALL addrg
16f8(059d): 42 7a bc a0 '  mov r10, r15
16fc(059e): 0c 7a fc d0 '  adds r10, #12 ' ADDP4 coni
1700(059f): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
1704(05a0): 10 7c fc 2c '  shl r11, #16
1708(05a1): 10 7c fc 38 '  sar r11, #16 ' sign extend
170c(05a2): 3d 7c 3c 08 '  wrlong r11, r10 ' ASGNI4 reg
1710(05a3):             ' C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_70
1710(05a3): 42 7c bc a0 '  mov r11, r15
1714(05a4): 08 7c fc d0 '  adds r11, #8 ' ADDP4 coni
1718(05a5): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRU4 reg
171c(05a6): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
1720(05a7): 42 7c bc a0 '  mov r11, r15
1724(05a8): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
1728(05a9): 3e 6c bc 08 '  rdlong r3, r11 ' reg <- INDIRU4 reg
172c(05aa): 08 5e fc a0 '  mov BC, #8 ' arg size
1730(05ab): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
1734(05ac): 0b 00 7c 5c '  jmp #CALA
1738(05ad): c8 11 00 00 '  long @C_tmpfilehyJnMp_4d07ee05_gpio_set_value_L000027
173c(05ae): 08 58 fc 80 '  add SP, #8 ' CALL addrg
1740(05af): 42 7a bc a0 '  mov r10, r15
1744(05b0): 0c 7a fc d0 '  adds r10, #12 ' ADDP4 coni
1748(05b1): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
174c(05b2): 10 7c fc 2c '  shl r11, #16
1750(05b3): 10 7c fc 38 '  sar r11, #16 ' sign extend
1754(05b4): 3d 7c 3c 08 '  wrlong r11, r10 ' ASGNI4 reg
1758(05b5):             ' C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_71
1758(05b5): 42 7c bc a0 '  mov r11, r15
175c(05b6): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
1760(05b7): 3e 6a bc 08 '  rdlong r2, r11 ' reg <- INDIRU4 reg
1764(05b8): 04 5e fc a0 '  mov BC, #4 ' arg size
1768(05b9): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
176c(05ba): 0b 00 7c 5c '  jmp #CALA
1770(05bb): 80 11 00 00 '  long @C_tmpfileLmH0nT_4d07ee05_gpio_get_value_L000025
1774(05bc): 04 58 fc 80 '  add SP, #4 ' CALL addrg
1778(05bd): 42 7a bc a0 '  mov r10, r15
177c(05be): 0c 7a fc d0 '  adds r10, #12 ' ADDP4 coni
1780(05bf): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
1784(05c0): 10 7c fc 2c '  shl r11, #16
1788(05c1): 10 7c fc 38 '  sar r11, #16 ' sign extend
178c(05c2): 3d 7c 3c 08 '  wrlong r11, r10 ' ASGNI4 reg
1790(05c3):             ' C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_67
1790(05c3): 42 7c bc a0 '  mov r11, r15
1794(05c4): 0c 7c fc d0 '  adds r11, #12 ' ADDP4 coni
1798(05c5): 01 7a fc a0 '  mov r10, #1 ' reg <- coni
179c(05c6): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNI4 reg
17a0(05c7):             ' C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_44
17a0(05c7): 23 00 7c 5c '  jmp #POPM
17a4(05c8): 00 8c 03 00 '  long $38c00 ' restore registers
17a8(05c9): 0c 00 7c 5c '  jmp #RETN
17ac(05ca):             '  long ' align long
17ac(05ca):             ' C_t_char ' <symbol:t_char>
17ac(05ca): 22 00 7c 5c '  jmp #PSHM
17b0(05cb): 00 08 03 00 '  long $30800 ' save registers
17b4(05cc): 36 88 bc a0 '  mov r17, r3 ' reg var <- reg arg
17b8(05cd): 35 86 bc a0 '  mov r16, r2 ' reg var <- reg arg
17bc(05ce): 44 7c bc a0 '  mov r11, r17
17c0(05cf): 01 7c fc 60 '  and r11, #1 ' BANDU4 coni
17c4(05d0): 17 7c fc 2c '  shl r11, #23 ' LSHU4 coni
17c8(05d1): 43 7c bc 80 '  add r11, r16 ' ADDU (1)
17cc(05d2): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
17d0(05d3): 16 6c fc a0 '  mov r3, #22 ' reg ARG coni
17d4(05d4): 01 6e fc a0 '  mov r4, #1 ' reg ARG coni
17d8(05d5): 0c 5e fc a0 '  mov BC, #12 ' arg size
17dc(05d6): 0c 58 fc 84 '  sub SP, #12 ' stack space for reg ARGs
17e0(05d7): 0b 00 7c 5c '  jmp #CALA
17e4(05d8): 80 17 00 00 '  long @C__short_plugin_request
17e8(05d9): 0c 58 fc 80 '  add SP, #12 ' CALL addrg
17ec(05da): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
17f0(05db): 23 00 7c 5c '  jmp #POPM
17f4(05dc): 00 08 03 00 '  long $30800 ' restore registers
17f8(05dd): 0c 00 7c 5c '  jmp #RETN
17fc(05de):             '  long ' align long
17fc(05de):             ' C__short_plugin_request ' <symbol:_short_plugin_request>
17fc(05de): 22 00 7c 5c '  jmp #PSHM
1800(05df): 00 88 03 00 '  long $38800 ' save registers
1804(05e0): 37 88 bc a0 '  mov r17, r4 ' reg var <- reg arg
1808(05e1): 36 86 bc a0 '  mov r16, r3 ' reg var <- reg arg
180c(05e2): 35 84 bc a0 '  mov r15, r2 ' reg var <- reg arg
1810(05e3): 43 7c bc a0 '  mov r11, r16
1814(05e4): 18 7c fc 2c '  shl r11, #24 ' LSHI4 coni
1818(05e5): 3e 6a bc a0 '  mov r2, r11 ' ADDI/P
181c(05e6): 42 6a bc d0 '  adds r2, r15 ' ADDI/P (3)
1820(05e7): 44 6c bc a0 '  mov r3, r17 ' CVI, CVU or LOAD
1824(05e8): 08 5e fc a0 '  mov BC, #8 ' arg size
1828(05e9): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
182c(05ea): 0b 00 7c 5c '  jmp #CALA
1830(05eb): 74 01 00 00 '  long @C__sys_plugin
1834(05ec): 08 58 fc 80 '  add SP, #8 ' CALL addrg
1838(05ed): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
183c(05ee): 23 00 7c 5c '  jmp #POPM
1840(05ef): 00 88 03 00 '  long $38800 ' restore registers
1844(05f0): 0c 00 7c 5c '  jmp #RETN
1848(05f1):             '  long ' align long
1848(05f1):             ' C__long_plugin_request ' <symbol:_long_plugin_request>
1848(05f1): 09 00 7c 5c '  jmp #NEWF
184c(05f2): 04 58 fc 84 '  sub SP, #4
1850(05f3): 22 00 7c 5c '  jmp #PSHM
1854(05f4): 00 8c 03 00 '  long $38c00 ' save registers
1858(05f5): 37 88 bc a0 '  mov r17, r4 ' reg var <- reg arg
185c(05f6): 36 86 bc a0 '  mov r16, r3 ' reg var <- reg arg
1860(05f7): 35 84 bc a0 '  mov r15, r2 ' reg var <- reg arg
1864(05f8): 05 00 7c 5c '  jmp #LODF
1868(05f9): fc ff ff ff '  long -4
186c(05fa): 2e 84 3c 08 '  wrlong r15, RI ' ASGNI4 addrl
1870(05fb): 43 7c bc a0 '  mov r11, r16
1874(05fc): 18 7c fc 2c '  shl r11, #24 ' LSHI4 coni
1878(05fd): 2d 7a bc a0 '  mov r10, FP
187c(05fe): 04 7a fc 84 '  sub r10, #-(-4) ' reg <- addrli
1880(05ff): 3e 6a bc a0 '  mov r2, r11 ' ADDI/P
1884(0600): 3d 6a bc d0 '  adds r2, r10 ' ADDI/P (3)
1888(0601): 44 6c bc a0 '  mov r3, r17 ' CVI, CVU or LOAD
188c(0602): 08 5e fc a0 '  mov BC, #8 ' arg size
1890(0603): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
1894(0604): 0b 00 7c 5c '  jmp #CALA
1898(0605): 74 01 00 00 '  long @C__sys_plugin
189c(0606): 08 58 fc 80 '  add SP, #8 ' CALL addrg
18a0(0607): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
18a4(0608): 23 00 7c 5c '  jmp #POPM
18a8(0609): 00 8c 03 00 '  long $38c00 ' restore registers
18ac(060a): 04 58 fc 80 '  add SP, #4 ' framesize
18b0(060b): 0a 00 7c 5c '  jmp #RETF
18b4(060c):             '  long ' align long
18b4(060c):             ' C__long_plugin_request_2 ' <symbol:_long_plugin_request_2>
18b4(060c): 09 00 7c 5c '  jmp #NEWF
18b8(060d): 08 58 fc 84 '  sub SP, #8
18bc(060e): 22 00 7c 5c '  jmp #PSHM
18c0(060f): 00 cc 03 00 '  long $3cc00 ' save registers
18c4(0610): 38 88 bc a0 '  mov r17, r5 ' reg var <- reg arg
18c8(0611): 37 86 bc a0 '  mov r16, r4 ' reg var <- reg arg
18cc(0612): 36 84 bc a0 '  mov r15, r3 ' reg var <- reg arg
18d0(0613): 35 82 bc a0 '  mov r14, r2 ' reg var <- reg arg
18d4(0614): 05 00 7c 5c '  jmp #LODF
18d8(0615): f8 ff ff ff '  long -8
18dc(0616): 2e 84 3c 08 '  wrlong r15, RI ' ASGNI4 addrl
18e0(0617): 05 00 7c 5c '  jmp #LODF
18e4(0618): fc ff ff ff '  long -4
18e8(0619): 2e 82 3c 08 '  wrlong r14, RI ' ASGNI4 addrl
18ec(061a): 43 7c bc a0 '  mov r11, r16
18f0(061b): 18 7c fc 2c '  shl r11, #24 ' LSHI4 coni
18f4(061c): 2d 7a bc a0 '  mov r10, FP
18f8(061d): 08 7a fc 84 '  sub r10, #-(-8) ' reg <- addrli
18fc(061e): 3e 6a bc a0 '  mov r2, r11 ' ADDI/P
1900(061f): 3d 6a bc d0 '  adds r2, r10 ' ADDI/P (3)
1904(0620): 44 6c bc a0 '  mov r3, r17 ' CVI, CVU or LOAD
1908(0621): 08 5e fc a0 '  mov BC, #8 ' arg size
190c(0622): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
1910(0623): 0b 00 7c 5c '  jmp #CALA
1914(0624): 74 01 00 00 '  long @C__sys_plugin
1918(0625): 08 58 fc 80 '  add SP, #8 ' CALL addrg
191c(0626): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
1920(0627): 23 00 7c 5c '  jmp #POPM
1924(0628): 00 cc 03 00 '  long $3cc00 ' restore registers
1928(0629): 08 58 fc 80 '  add SP, #8 ' framesize
192c(062a): 0a 00 7c 5c '  jmp #RETF
1930(062b):             '  long ' align long
1930(062b):             ' C_catalina_putc ' <symbol:catalina_putc>
1930(062b): 22 00 7c 5c '  jmp #PSHM
1934(062c): 00 0c 03 00 '  long $30c00 ' save registers
1938(062d): 36 88 bc a0 '  mov r17, r3 ' reg var <- reg arg
193c(062e): 35 86 bc a0 '  mov r16, r2 ' reg var <- reg arg
1940(062f): 43 7c bc a0 '  mov r11, r16 ' CVI, CVU or LOAD
1944(0630): 04 00 7c 5c '  jmp #LODA
1948(0631): 38 34 00 00 '  long @C___stdout
194c(0632): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
1950(0633): 3d 7c 3c 86 '  cmp r11, r10 wz
1954(0634): 14 00 7c 5c '  jmp #BRNZ
1958(0635): 04 19 00 00 '  long @C_catalina_putc_2 ' NEU4
195c(0636): 44 6a bc a0 '  mov r2, r17 ' CVI, CVU or LOAD
1960(0637): 01 6c fc a0 '  mov r3, #1 ' reg ARG coni
1964(0638): 08 5e fc a0 '  mov BC, #8 ' arg size
1968(0639): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
196c(063a): 0b 00 7c 5c '  jmp #CALA
1970(063b): 30 17 00 00 '  long @C_t_char
1974(063c): 08 58 fc 80 '  add SP, #8 ' CALL addrg
1978(063d): 0e 00 7c 5c '  jmp #JMPA
197c(063e): 3c 19 00 00 '  long @C_catalina_putc_3 ' JUMPV addrg
1980(063f):             ' C_catalina_putc_2
1980(063f): 43 7c bc a0 '  mov r11, r16 ' CVI, CVU or LOAD
1984(0640): 04 00 7c 5c '  jmp #LODA
1988(0641): 50 34 00 00 '  long @C___stderr
198c(0642): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
1990(0643): 3d 7c 3c 86 '  cmp r11, r10 wz
1994(0644): 14 00 7c 5c '  jmp #BRNZ
1998(0645): 3c 19 00 00 '  long @C_catalina_putc_4 ' NEU4
199c(0646): 44 6a bc a0 '  mov r2, r17 ' CVI, CVU or LOAD
19a0(0647): 01 6c fc a0 '  mov r3, #1 ' reg ARG coni
19a4(0648): 08 5e fc a0 '  mov BC, #8 ' arg size
19a8(0649): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
19ac(064a): 0b 00 7c 5c '  jmp #CALA
19b0(064b): 30 17 00 00 '  long @C_t_char
19b4(064c): 08 58 fc 80 '  add SP, #8 ' CALL addrg
19b8(064d):             ' C_catalina_putc_4
19b8(064d):             ' C_catalina_putc_3
19b8(064d): 44 66 bc a0 '  mov r0, r17 ' CVI, CVU or LOAD
19bc(064e): 23 00 7c 5c '  jmp #POPM
19c0(064f): 00 0c 03 00 '  long $30c00 ' restore registers
19c4(0650): 0c 00 7c 5c '  jmp #RETN
19c8(0651):             '  long ' align long
19c8(0651):             ' C__cnt
19c8(0651): f1 67 bc a0 '  mov r0, CNT
19cc(0652): 0c 00 7c 5c '  jmp #RETN
19d0(0653):             '  long ' align long
19d0(0653):             ' C__dira
19d0(0653): f6 67 bc a0 '  mov r0, DIRA
19d4(0654): 36 ec bf 64 '  andn DIRA, r3
19d8(0655): 35 ec bf 68 '  or DIRA, r2
19dc(0656): 0c 00 7c 5c '  jmp #RETN
19e0(0657):             '  long ' align long
19e0(0657):             ' C_tmpfilexMRBQL_4c2c6c11_gnum_L000001 ' <symbol:gnum>
19e0(0657): 22 00 7c 5c '  jmp #PSHM
19e4(0658): 00 ec 03 00 '  long $3ec00 ' save registers
19e8(0659): 37 88 bc a0 '  mov r17, r4 ' reg var <- reg arg
19ec(065a): 36 86 bc a0 '  mov r16, r3 ' reg var <- reg arg
19f0(065b): 35 84 bc a0 '  mov r15, r2 ' reg var <- reg arg
19f4(065c): 44 7c bc 00 '  rdbyte r11, r17 ' reg <- INDIRU1 reg
19f8(065d): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
19fc(065e): 2a 7c 7c c2 '  cmps r11,  #42 wz
1a00(065f): 14 00 7c 5c '  jmp #BRNZ
1a04(0660): bc 19 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_3 ' NEI4
1a08(0661): 42 7c bc 08 '  rdlong r11, r15 ' reg <- INDIRP4 reg
1a0c(0662): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
1a10(0663): 42 7c 3c 08 '  wrlong r11, r15 ' ASGNP4 reg
1a14(0664): 04 00 7c 5c '  jmp #LODA
1a18(0665): 04 34 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
1a1c(0666): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
1a20(0667): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
1a24(0668): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1a28(0669): 43 7c 3c 08 '  wrlong r11, r16 ' ASGNI4 reg
1a2c(066a): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1a30(066b): 0e 00 7c 5c '  jmp #JMPA
1a34(066c): 10 1a 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_4 ' JUMPV addrg
1a38(066d):             ' C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_3
1a38(066d): 00 82 fc a0 '  mov r14, #0 ' reg <- coni
1a3c(066e): 0e 00 7c 5c '  jmp #JMPA
1a40(066f): e4 19 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_9 ' JUMPV addrg
1a44(0670):             ' C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_8
1a44(0670): 0a 7c fc a0 '  mov r11, #10 ' reg <- coni
1a48(0671): 3e 66 bc a0 '  mov r0, r11 ' setup r0/r1 (2)
1a4c(0672): 41 68 bc a0 '  mov r1, r14 ' setup r0/r1 (2)
1a50(0673): 12 00 7c 5c '  jmp #MULT ' MULT(I/U)
1a54(0674): 33 82 bc a0 '  mov r14, r0 ' ADDI/P
1a58(0675): 40 82 bc d0 '  adds r14, r13 ' ADDI/P (3)
1a5c(0676): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1a60(0677):             ' C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_9
1a60(0677): 44 7c bc 00 '  rdbyte r11, r17 ' reg <- INDIRU1 reg
1a64(0678): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
1a68(0679): 30 7c fc d4 '  subs r11, #48 ' SUBI4 coni
1a6c(067a): 3e 80 bc a0 '  mov r13, r11 ' CVI, CVU or LOAD
1a70(067b): 00 7c 7c c3 '  cmps r11,  #0 wz,wc
1a74(067c): 18 00 7c 5c '  jmp #BR_B
1a78(067d): 0c 1a 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_11 ' LTI4
1a7c(067e): 09 80 7c c3 '  cmps r13,  #9 wz,wc
1a80(067f): 17 00 7c 5c '  jmp #BRBE
1a84(0680): c8 19 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_8 ' LEI4
1a88(0681):             ' C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_11
1a88(0681): 43 82 3c 08 '  wrlong r14, r16 ' ASGNI4 reg
1a8c(0682):             ' C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_4
1a8c(0682): 44 66 bc a0 '  mov r0, r17 ' CVI, CVU or LOAD
1a90(0683): 23 00 7c 5c '  jmp #POPM
1a94(0684): 00 ec 03 00 '  long $3ec00 ' restore registers
1a98(0685): 0c 00 7c 5c '  jmp #RETN
1a9c(0686):             '  long ' align long
1a9c(0686):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012 ' <symbol:o_print>
1a9c(0686): 09 00 7c 5c '  jmp #NEWF
1aa0(0687): 10 58 fc 84 '  sub SP, #16
1aa4(0688): 22 00 7c 5c '  jmp #PSHM
1aa8(0689): 00 fc 03 00 '  long $3fc00 ' save registers
1aac(068a): 38 88 bc a0 '  mov r17, r5 ' reg var <- reg arg
1ab0(068b): 37 86 bc a0 '  mov r16, r4 ' reg var <- reg arg
1ab4(068c): 36 84 bc a0 '  mov r15, r3 ' reg var <- reg arg
1ab8(068d): 35 82 bc a0 '  mov r14, r2 ' reg var <- reg arg
1abc(068e): 44 80 bc a0 '  mov r13, r17 ' CVI, CVU or LOAD
1ac0(068f): 2d 7c bc a0 '  mov r11, FP
1ac4(0690): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
1ac8(0691): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1acc(0692): 3e 7e bc a0 '  mov r12, r11
1ad0(0693): 60 7e fc 60 '  and r12, #96 ' BANDI4 coni
1ad4(0694): 20 7c fc a0 '  mov r11, #32 ' reg <- coni
1ad8(0695): 3e 7e 3c c2 '  cmps r12, r11 wz
1adc(0696): 13 00 7c 5c '  jmp #BR_Z
1ae0(0697): 88 1a 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_17 ' EQI4
1ae4(0698): 3e 7e 3c c3 '  cmps r12, r11 wz,wc
1ae8(0699): 18 00 7c 5c '  jmp #BR_B
1aec(069a): ac 1b 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_14 ' LTI4
1af0(069b): 40 7e 7c c2 '  cmps r12,  #64 wz
1af4(069c): 13 00 7c 5c '  jmp #BR_Z
1af8(069d): 20 1b 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_20 ' EQI4
1afc(069e): 0e 00 7c 5c '  jmp #JMPA
1b00(069f): ac 1b 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_14 ' JUMPV addrg
1b04(06a0):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_17
1b04(06a0): 00 82 7c c2 '  cmps r14,  #0 wz
1b08(06a1): 13 00 7c 5c '  jmp #BR_Z
1b0c(06a2): dc 1a 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_18 ' EQI4
1b10(06a3): 2d 7c bc a0 '  mov r11, FP
1b14(06a4): 08 7c fc 80 '  add r11, #8 ' reg <- addrfi
1b18(06a5): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1b1c(06a6): 3e 7a bc 08 '  rdlong r10, r11 ' reg <- INDIRP4 reg
1b20(06a7): 04 7a fc d0 '  adds r10, #4 ' ADDP4 coni
1b24(06a8): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
1b28(06a9): 04 00 7c 5c '  jmp #LODA
1b2c(06aa): 04 34 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
1b30(06ab): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1b34(06ac): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (2)
1b38(06ad): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1b3c(06ae): 10 7c fc 2c '  shl r11, #16
1b40(06af): 10 7c fc 38 '  sar r11, #16 ' sign extend
1b44(06b0): 05 00 7c 5c '  jmp #LODF
1b48(06b1): f8 ff ff ff '  long -8
1b4c(06b2): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1b50(06b3): 0e 00 7c 5c '  jmp #JMPA
1b54(06b4): 30 1c 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_15 ' JUMPV addrg
1b58(06b5):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_18
1b58(06b5): 2d 7c bc a0 '  mov r11, FP
1b5c(06b6): 08 7c fc 80 '  add r11, #8 ' reg <- addrfi
1b60(06b7): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1b64(06b8): 3e 7a bc 08 '  rdlong r10, r11 ' reg <- INDIRP4 reg
1b68(06b9): 04 7a fc d0 '  adds r10, #4 ' ADDP4 coni
1b6c(06ba): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
1b70(06bb): 04 00 7c 5c '  jmp #LODA
1b74(06bc): 04 34 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
1b78(06bd): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1b7c(06be): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (2)
1b80(06bf): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRU4 reg
1b84(06c0): 4e 7c bc 60 '  and r11, cviu_m2 ' zero extend
1b88(06c1): 05 00 7c 5c '  jmp #LODF
1b8c(06c2): fc ff ff ff '  long -4
1b90(06c3): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNU4 addrl
1b94(06c4): 0e 00 7c 5c '  jmp #JMPA
1b98(06c5): 30 1c 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_15 ' JUMPV addrg
1b9c(06c6):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_20
1b9c(06c6): 00 82 7c c2 '  cmps r14,  #0 wz
1ba0(06c7): 13 00 7c 5c '  jmp #BR_Z
1ba4(06c8): 6c 1b 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_21 ' EQI4
1ba8(06c9): 2d 7c bc a0 '  mov r11, FP
1bac(06ca): 08 7c fc 80 '  add r11, #8 ' reg <- addrfi
1bb0(06cb): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1bb4(06cc): 3e 7a bc 08 '  rdlong r10, r11 ' reg <- INDIRP4 reg
1bb8(06cd): 04 7a fc d0 '  adds r10, #4 ' ADDP4 coni
1bbc(06ce): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
1bc0(06cf): 04 00 7c 5c '  jmp #LODA
1bc4(06d0): 04 34 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
1bc8(06d1): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1bcc(06d2): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (2)
1bd0(06d3): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1bd4(06d4): 05 00 7c 5c '  jmp #LODF
1bd8(06d5): f8 ff ff ff '  long -8
1bdc(06d6): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1be0(06d7): 0e 00 7c 5c '  jmp #JMPA
1be4(06d8): 30 1c 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_15 ' JUMPV addrg
1be8(06d9):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_21
1be8(06d9): 2d 7c bc a0 '  mov r11, FP
1bec(06da): 08 7c fc 80 '  add r11, #8 ' reg <- addrfi
1bf0(06db): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1bf4(06dc): 3e 7a bc 08 '  rdlong r10, r11 ' reg <- INDIRP4 reg
1bf8(06dd): 04 7a fc d0 '  adds r10, #4 ' ADDP4 coni
1bfc(06de): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
1c00(06df): 04 00 7c 5c '  jmp #LODA
1c04(06e0): 04 34 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
1c08(06e1): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1c0c(06e2): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (2)
1c10(06e3): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRU4 reg
1c14(06e4): 05 00 7c 5c '  jmp #LODF
1c18(06e5): fc ff ff ff '  long -4
1c1c(06e6): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNU4 addrl
1c20(06e7): 0e 00 7c 5c '  jmp #JMPA
1c24(06e8): 30 1c 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_15 ' JUMPV addrg
1c28(06e9):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_14
1c28(06e9): 00 82 7c c2 '  cmps r14,  #0 wz
1c2c(06ea): 13 00 7c 5c '  jmp #BR_Z
1c30(06eb): f8 1b 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_23 ' EQI4
1c34(06ec): 2d 7c bc a0 '  mov r11, FP
1c38(06ed): 08 7c fc 80 '  add r11, #8 ' reg <- addrfi
1c3c(06ee): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1c40(06ef): 3e 7a bc 08 '  rdlong r10, r11 ' reg <- INDIRP4 reg
1c44(06f0): 04 7a fc d0 '  adds r10, #4 ' ADDP4 coni
1c48(06f1): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
1c4c(06f2): 04 00 7c 5c '  jmp #LODA
1c50(06f3): 04 34 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
1c54(06f4): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1c58(06f5): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (2)
1c5c(06f6): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1c60(06f7): 05 00 7c 5c '  jmp #LODF
1c64(06f8): f8 ff ff ff '  long -8
1c68(06f9): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1c6c(06fa): 0e 00 7c 5c '  jmp #JMPA
1c70(06fb): 30 1c 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_15 ' JUMPV addrg
1c74(06fc):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_23
1c74(06fc): 2d 7c bc a0 '  mov r11, FP
1c78(06fd): 08 7c fc 80 '  add r11, #8 ' reg <- addrfi
1c7c(06fe): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1c80(06ff): 3e 7a bc 08 '  rdlong r10, r11 ' reg <- INDIRP4 reg
1c84(0700): 04 7a fc d0 '  adds r10, #4 ' ADDP4 coni
1c88(0701): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
1c8c(0702): 04 00 7c 5c '  jmp #LODA
1c90(0703): 04 34 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
1c94(0704): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1c98(0705): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (2)
1c9c(0706): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRU4 reg
1ca0(0707): 05 00 7c 5c '  jmp #LODF
1ca4(0708): fc ff ff ff '  long -4
1ca8(0709): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNU4 addrl
1cac(070a):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_15
1cac(070a): 00 82 7c c2 '  cmps r14,  #0 wz
1cb0(070b): 13 00 7c 5c '  jmp #BR_Z
1cb4(070c): 0c 1d 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_26 ' EQI4
1cb8(070d): 2d 7c bc a0 '  mov r11, FP
1cbc(070e): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
1cc0(070f): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1cc4(0710): 00 7c 7c c3 '  cmps r11,  #0 wz,wc
1cc8(0711): 15 00 7c 5c '  jmp #BRAE
1ccc(0712): 8c 1c 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_28 ' GEI4
1cd0(0713): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
1cd4(0714): 3e 88 bc a0 '  mov r17, r11
1cd8(0715): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1cdc(0716): 2d 7a fc a0 '  mov r10, #45 ' reg <- coni
1ce0(0717): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
1ce4(0718): 2d 7c bc a0 '  mov r11, FP
1ce8(0719): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
1cec(071a): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1cf0(071b): 3e 7c bc a4 '  neg r11, r11 ' NEGI4
1cf4(071c): 05 00 7c 5c '  jmp #LODF
1cf8(071d): f8 ff ff ff '  long -8
1cfc(071e): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1d00(071f): 0e 00 7c 5c '  jmp #JMPA
1d04(0720): f4 1c 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_29 ' JUMPV addrg
1d08(0721):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_28
1d08(0721): 2d 7c bc a0 '  mov r11, FP
1d0c(0722): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
1d10(0723): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1d14(0724): 02 7c fc 60 '  and r11, #2 ' BANDI4 coni
1d18(0725): 00 7c 7c c2 '  cmps r11,  #0 wz
1d1c(0726): 13 00 7c 5c '  jmp #BR_Z
1d20(0727): c4 1c 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_30 ' EQI4
1d24(0728): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
1d28(0729): 3e 88 bc a0 '  mov r17, r11
1d2c(072a): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1d30(072b): 2b 7a fc a0 '  mov r10, #43 ' reg <- coni
1d34(072c): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
1d38(072d): 0e 00 7c 5c '  jmp #JMPA
1d3c(072e): f4 1c 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_31 ' JUMPV addrg
1d40(072f):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_30
1d40(072f): 2d 7c bc a0 '  mov r11, FP
1d44(0730): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
1d48(0731): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1d4c(0732): 04 7c fc 60 '  and r11, #4 ' BANDI4 coni
1d50(0733): 00 7c 7c c2 '  cmps r11,  #0 wz
1d54(0734): 13 00 7c 5c '  jmp #BR_Z
1d58(0735): f4 1c 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_32 ' EQI4
1d5c(0736): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
1d60(0737): 3e 88 bc a0 '  mov r17, r11
1d64(0738): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1d68(0739): 20 7a fc a0 '  mov r10, #32 ' reg <- coni
1d6c(073a): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
1d70(073b):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_32
1d70(073b):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_31
1d70(073b):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_29
1d70(073b): 2d 7c bc a0 '  mov r11, FP
1d74(073c): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
1d78(073d): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1d7c(073e): 05 00 7c 5c '  jmp #LODF
1d80(073f): fc ff ff ff '  long -4
1d84(0740): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNU4 addrl
1d88(0741):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_26
1d88(0741): 2d 7c bc a0 '  mov r11, FP
1d8c(0742): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
1d90(0743): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1d94(0744): 08 7c fc 60 '  and r11, #8 ' BANDI4 coni
1d98(0745): 00 7c 7c c2 '  cmps r11,  #0 wz
1d9c(0746): 13 00 7c 5c '  jmp #BR_Z
1da0(0747): 50 1d 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_34 ' EQI4
1da4(0748): 43 7c bc a0 '  mov r11, r16 ' CVUI
1da8(0749): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
1dac(074a): 6f 7c 7c c2 '  cmps r11,  #111 wz
1db0(074b): 14 00 7c 5c '  jmp #BRNZ
1db4(074c): 50 1d 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_34 ' NEI4
1db8(074d): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
1dbc(074e): 3e 88 bc a0 '  mov r17, r11
1dc0(074f): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1dc4(0750): 30 7a fc a0 '  mov r10, #48 ' reg <- coni
1dc8(0751): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
1dcc(0752):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_34
1dcc(0752): 2d 7c bc a0 '  mov r11, FP
1dd0(0753): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
1dd4(0754): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRU4 reg
1dd8(0755): 00 7c 7c 86 '  cmp r11,  #0 wz
1ddc(0756): 14 00 7c 5c '  jmp #BRNZ
1de0(0757): 80 1d 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_36 ' NEU4
1de4(0758): 00 84 7c c2 '  cmps r15,  #0 wz
1de8(0759): 14 00 7c 5c '  jmp #BRNZ
1dec(075a): 3c 1e 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_37 ' NEI4
1df0(075b): 44 66 bc a0 '  mov r0, r17 ' CVI, CVU or LOAD
1df4(075c): 0e 00 7c 5c '  jmp #JMPA
1df8(075d): 1c 20 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_13 ' JUMPV addrg
1dfc(075e):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_36
1dfc(075e): 2d 7c bc a0 '  mov r11, FP
1e00(075f): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
1e04(0760): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1e08(0761): 08 7c fc 60 '  and r11, #8 ' BANDI4 coni
1e0c(0762): 00 7c 7c c2 '  cmps r11,  #0 wz
1e10(0763): 13 00 7c 5c '  jmp #BR_Z
1e14(0764): bc 1d 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_43 ' EQI4
1e18(0765): 43 7c bc a0 '  mov r11, r16 ' CVUI
1e1c(0766): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
1e20(0767): 78 7c 7c c2 '  cmps r11,  #120 wz
1e24(0768): 13 00 7c 5c '  jmp #BR_Z
1e28(0769): d0 1d 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_42 ' EQI4
1e2c(076a): 58 7c 7c c2 '  cmps r11,  #88 wz
1e30(076b): 13 00 7c 5c '  jmp #BR_Z
1e34(076c): d0 1d 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_42 ' EQI4
1e38(076d):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_43
1e38(076d): 43 7c bc a0 '  mov r11, r16 ' CVUI
1e3c(076e): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
1e40(076f): 70 7c 7c c2 '  cmps r11,  #112 wz
1e44(0770): 14 00 7c 5c '  jmp #BRNZ
1e48(0771): 3c 1e 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_40 ' NEI4
1e4c(0772):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_42
1e4c(0772): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
1e50(0773): 3e 88 bc a0 '  mov r17, r11
1e54(0774): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1e58(0775): 30 7a fc a0 '  mov r10, #48 ' reg <- coni
1e5c(0776): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
1e60(0777): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
1e64(0778): 3e 88 bc a0 '  mov r17, r11
1e68(0779): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1e6c(077a): 43 7a bc a0 '  mov r10, r16 ' CVUI
1e70(077b): 4d 7a bc 60 '  and r10, cviu_m1 ' zero extend
1e74(077c): 58 7a 7c c2 '  cmps r10,  #88 wz
1e78(077d): 14 00 7c 5c '  jmp #BRNZ
1e7c(077e): 1c 1e 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_45 ' NEI4
1e80(077f): 58 7a fc a0 '  mov r10, #88 ' reg <- coni
1e84(0780): 05 00 7c 5c '  jmp #LODF
1e88(0781): f0 ff ff ff '  long -16
1e8c(0782): 2e 7a 3c 08 '  wrlong r10, RI ' ASGNI4 addrl
1e90(0783): 0e 00 7c 5c '  jmp #JMPA
1e94(0784): 2c 1e 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_46 ' JUMPV addrg
1e98(0785):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_45
1e98(0785): 78 7a fc a0 '  mov r10, #120 ' reg <- coni
1e9c(0786): 05 00 7c 5c '  jmp #LODF
1ea0(0787): f0 ff ff ff '  long -16
1ea4(0788): 2e 7a 3c 08 '  wrlong r10, RI ' ASGNI4 addrl
1ea8(0789):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_46
1ea8(0789): 2d 7a bc a0 '  mov r10, FP
1eac(078a): 10 7a fc 84 '  sub r10, #-(-16) ' reg <- addrli
1eb0(078b): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRI4 reg
1eb4(078c): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
1eb8(078d):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_40
1eb8(078d):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_37
1eb8(078d): 43 7c bc a0 '  mov r11, r16 ' CVUI
1ebc(078e): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
1ec0(078f): 05 00 7c 5c '  jmp #LODF
1ec4(0790): f0 ff ff ff '  long -16
1ec8(0791): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1ecc(0792): 2d 7c bc a0 '  mov r11, FP
1ed0(0793): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
1ed4(0794): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1ed8(0795): 69 7a fc a0 '  mov r10, #105 ' reg <- coni
1edc(0796): 3d 7c 3c c2 '  cmps r11, r10 wz
1ee0(0797): 13 00 7c 5c '  jmp #BR_Z
1ee4(0798): 5c 1f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_52 ' EQI4
1ee8(0799): 3d 7c 3c c3 '  cmps r11, r10 wz,wc
1eec(079a): 16 00 7c 5c '  jmp #BR_A
1ef0(079b): cc 1e 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_55 ' GTI4
1ef4(079c): 2d 7c bc a0 '  mov r11, FP
1ef8(079d): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
1efc(079e): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1f00(079f): 58 7a fc a0 '  mov r10, #88 ' reg <- coni
1f04(07a0): 3d 7c 3c c2 '  cmps r11, r10 wz
1f08(07a1): 13 00 7c 5c '  jmp #BR_Z
1f0c(07a2): 74 1f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_53 ' EQI4
1f10(07a3): 3d 7c 3c c3 '  cmps r11, r10 wz,wc
1f14(07a4): 18 00 7c 5c '  jmp #BR_B
1f18(07a5): 84 1f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_47 ' LTI4
1f1c(07a6): 2d 7c bc a0 '  mov r11, FP
1f20(07a7): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
1f24(07a8): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1f28(07a9): 62 7c 7c c2 '  cmps r11,  #98 wz
1f2c(07aa): 13 00 7c 5c '  jmp #BR_Z
1f30(07ab): 2c 1f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_50 ' EQI4
1f34(07ac): 64 7c 7c c2 '  cmps r11,  #100 wz
1f38(07ad): 13 00 7c 5c '  jmp #BR_Z
1f3c(07ae): 5c 1f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_52 ' EQI4
1f40(07af): 0e 00 7c 5c '  jmp #JMPA
1f44(07b0): 84 1f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_47 ' JUMPV addrg
1f48(07b1):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_55
1f48(07b1): 2d 7c bc a0 '  mov r11, FP
1f4c(07b2): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
1f50(07b3): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1f54(07b4): 6f 7a fc a0 '  mov r10, #111 ' reg <- coni
1f58(07b5): 3d 7c 3c c2 '  cmps r11, r10 wz
1f5c(07b6): 13 00 7c 5c '  jmp #BR_Z
1f60(07b7): 44 1f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_51 ' EQI4
1f64(07b8): 70 7c 7c c2 '  cmps r11,  #112 wz
1f68(07b9): 13 00 7c 5c '  jmp #BR_Z
1f6c(07ba): 74 1f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_53 ' EQI4
1f70(07bb): 3d 7c 3c c3 '  cmps r11, r10 wz,wc
1f74(07bc): 18 00 7c 5c '  jmp #BR_B
1f78(07bd): 84 1f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_47 ' LTI4
1f7c(07be): 2d 7c bc a0 '  mov r11, FP
1f80(07bf): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
1f84(07c0): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1f88(07c1): 75 7c 7c c2 '  cmps r11,  #117 wz
1f8c(07c2): 13 00 7c 5c '  jmp #BR_Z
1f90(07c3): 5c 1f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_52 ' EQI4
1f94(07c4): 78 7c 7c c2 '  cmps r11,  #120 wz
1f98(07c5): 13 00 7c 5c '  jmp #BR_Z
1f9c(07c6): 74 1f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_53 ' EQI4
1fa0(07c7): 0e 00 7c 5c '  jmp #JMPA
1fa4(07c8): 84 1f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_47 ' JUMPV addrg
1fa8(07c9):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_50
1fa8(07c9): 02 7c fc a0 '  mov r11, #2 ' reg <- coni
1fac(07ca): 05 00 7c 5c '  jmp #LODF
1fb0(07cb): f4 ff ff ff '  long -12
1fb4(07cc): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1fb8(07cd): 0e 00 7c 5c '  jmp #JMPA
1fbc(07ce): 84 1f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_48 ' JUMPV addrg
1fc0(07cf):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_51
1fc0(07cf): 08 7c fc a0 '  mov r11, #8 ' reg <- coni
1fc4(07d0): 05 00 7c 5c '  jmp #LODF
1fc8(07d1): f4 ff ff ff '  long -12
1fcc(07d2): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1fd0(07d3): 0e 00 7c 5c '  jmp #JMPA
1fd4(07d4): 84 1f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_48 ' JUMPV addrg
1fd8(07d5):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_52
1fd8(07d5): 0a 7c fc a0 '  mov r11, #10 ' reg <- coni
1fdc(07d6): 05 00 7c 5c '  jmp #LODF
1fe0(07d7): f4 ff ff ff '  long -12
1fe4(07d8): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1fe8(07d9): 0e 00 7c 5c '  jmp #JMPA
1fec(07da): 84 1f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_48 ' JUMPV addrg
1ff0(07db):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_53
1ff0(07db): 10 7c fc a0 '  mov r11, #16 ' reg <- coni
1ff4(07dc): 05 00 7c 5c '  jmp #LODF
1ff8(07dd): f4 ff ff ff '  long -12
1ffc(07de): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2000(07df):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_47
2000(07df):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_48
2000(07df): 42 6a bc a0 '  mov r2, r15 ' CVI, CVU or LOAD
2004(07e0): 44 6c bc a0 '  mov r3, r17 ' CVI, CVU or LOAD
2008(07e1): 2d 5c bc a0 '  mov RI, FP
200c(07e2): 0c 5c fc 84 '  sub RI, #-(-12)
2010(07e3): 2e 6e bc 08 '  rdlong r4, RI ' reg ARG INDIR ADDRLi
2014(07e4): 2d 5c bc a0 '  mov RI, FP
2018(07e5): 04 5c fc 84 '  sub RI, #-(-4)
201c(07e6): 2e 70 bc 08 '  rdlong r5, RI ' reg ARG INDIR ADDRLi
2020(07e7): 10 5e fc a0 '  mov BC, #16 ' arg size
2024(07e8): 10 58 fc 84 '  sub SP, #16 ' stack space for reg ARGs
2028(07e9): 0b 00 7c 5c '  jmp #CALA
202c(07ea): b8 2f 00 00 '  long @C__i_compute
2030(07eb): 10 58 fc 80 '  add SP, #16 ' CALL addrg
2034(07ec): 33 88 bc a0 '  mov r17, r0 ' CVI, CVU or LOAD
2038(07ed): 43 7c bc a0 '  mov r11, r16 ' CVUI
203c(07ee): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
2040(07ef): 58 7c 7c c2 '  cmps r11,  #88 wz
2044(07f0): 14 00 7c 5c '  jmp #BRNZ
2048(07f1): 18 20 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_58 ' NEI4
204c(07f2): 0e 00 7c 5c '  jmp #JMPA
2050(07f3): 04 20 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_61 ' JUMPV addrg
2054(07f4):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_60
2054(07f4): 40 7c bc 00 '  rdbyte r11, r13 ' reg <- INDIRU1 reg
2058(07f5): 3e 6a bc a0 '  mov r2, r11 ' CVUI
205c(07f6): 4d 6a bc 60 '  and r2, cviu_m1 ' zero extend
2060(07f7): 04 5e fc a0 '  mov BC, #4 ' arg size
2064(07f8): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
2068(07f9): 0b 00 7c 5c '  jmp #CALA
206c(07fa): 90 31 00 00 '  long @C_toupper
2070(07fb): 04 58 fc 80 '  add SP, #4 ' CALL addrg
2074(07fc): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
2078(07fd): 40 7c 3c 00 '  wrbyte r11, r13 ' ASGNU1 reg
207c(07fe): 01 80 fc d0 '  adds r13, #1 ' ADDP4 coni
2080(07ff):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_61
2080(07ff): 40 7c bc a0 '  mov r11, r13 ' CVI, CVU or LOAD
2084(0800): 44 7a bc a0 '  mov r10, r17 ' CVI, CVU or LOAD
2088(0801): 3d 7c 3c 86 '  cmp r11, r10 wz
208c(0802): 14 00 7c 5c '  jmp #BRNZ
2090(0803): d8 1f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_60 ' NEU4
2094(0804):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_58
2094(0804): 44 66 bc a0 '  mov r0, r17 ' CVI, CVU or LOAD
2098(0805):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_13
2098(0805): 23 00 7c 5c '  jmp #POPM
209c(0806): 00 fc 03 00 '  long $3fc00 ' restore registers
20a0(0807): 10 58 fc 80 '  add SP, #16 ' framesize
20a4(0808): 0a 00 7c 5c '  jmp #RETF
20a8(0809):             '  long ' align long
20a8(0809):             ' C__doprnt ' <symbol:_doprnt>
20a8(0809): 09 00 7c 5c '  jmp #NEWF
20ac(080a): 03 00 7c 5c '  jmp #LODL
20b0(080b): 30 04 00 00 '  long 1072
20b4(080c): 2e 58 bc 84 '  sub SP, RI
20b8(080d): 22 00 7c 5c '  jmp #PSHM
20bc(080e): 00 fe 03 00 '  long $3fe00 ' save registers
20c0(080f): 37 88 bc a0 '  mov r17, r4 ' reg var <- reg arg
20c4(0810): 2d 5c bc a0 '  mov RI, FP
20c8(0811): 0c 5c fc 80 '  add RI, #12
20cc(0812): 2e 6c 3c 08 '  wrlong r3, RI ' spill reg
20d0(0813): 35 86 bc a0 '  mov r16, r2 ' reg var <- reg arg
20d4(0814): 00 7e fc a0 '  mov r12, #0 ' reg <- coni
20d8(0815): 0e 00 7c 5c '  jmp #JMPA
20dc(0816): 70 2f 00 00 '  long @C__doprnt_65 ' JUMPV addrg
20e0(0817):             ' C__doprnt_64
20e0(0817): 2d 7c bc a0 '  mov r11, FP
20e4(0818): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
20e8(0819): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
20ec(081a): 25 7c 7c c2 '  cmps r11,  #37 wz
20f0(081b): 13 00 7c 5c '  jmp #BR_Z
20f4(081c): 14 21 00 00 '  long @C__doprnt_67 ' EQI4
20f8(081d): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
20fc(081e): 2d 5c bc a0 '  mov RI, FP
2100(081f): 10 5c fc 84 '  sub RI, #-(-16)
2104(0820): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRLi
2108(0821): 08 5e fc a0 '  mov BC, #8 ' arg size
210c(0822): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
2110(0823): 0b 00 7c 5c '  jmp #CALA
2114(0824): 58 31 00 00 '  long @C_putc
2118(0825): 08 58 fc 80 '  add SP, #8 ' CALL addrg
211c(0826): 04 00 7c 5c '  jmp #LODA
2120(0827): 00 34 00 00 '  long @C__doprnt_L000071
2124(0828): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
2128(0829): 3d 66 3c c2 '  cmps r0, r10 wz
212c(082a): 14 00 7c 5c '  jmp #BRNZ
2130(082b): 08 21 00 00 '  long @C__doprnt_69 ' NEI4
2134(082c): 00 7e 7c c2 '  cmps r12,  #0 wz
2138(082d): 13 00 7c 5c '  jmp #BR_Z
213c(082e): dc 20 00 00 '  long @C__doprnt_75 ' EQI4
2140(082f): 3f 7c bc a4 '  neg r11, r12 ' NEGI4
2144(0830): 05 00 7c 5c '  jmp #LODF
2148(0831): d8 fb ff ff '  long -1064
214c(0832): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2150(0833): 0e 00 7c 5c '  jmp #JMPA
2154(0834): f4 20 00 00 '  long @C__doprnt_76 ' JUMPV addrg
2158(0835):             ' C__doprnt_75
2158(0835): 04 00 7c 5c '  jmp #LODA
215c(0836): 00 34 00 00 '  long @C__doprnt_L000071
2160(0837): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
2164(0838): 05 00 7c 5c '  jmp #LODF
2168(0839): d8 fb ff ff '  long -1064
216c(083a): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2170(083b):             ' C__doprnt_76
2170(083b): 05 00 7c 5c '  jmp #LODF
2174(083c): d8 fb ff ff '  long -1064
2178(083d): 2e 66 bc 08 '  rdlong r0, RI ' reg <- INDIRI4 addrl
217c(083e): 0e 00 7c 5c '  jmp #JMPA
2180(083f): a0 2f 00 00 '  long @C__doprnt_63 ' JUMPV addrg
2184(0840):             ' C__doprnt_69
2184(0840): 01 7e fc d0 '  adds r12, #1 ' ADDI4 coni
2188(0841): 0e 00 7c 5c '  jmp #JMPA
218c(0842): 70 2f 00 00 '  long @C__doprnt_65 ' JUMPV addrg
2190(0843):             ' C__doprnt_67
2190(0843): 00 80 fc a0 '  mov r13, #0 ' reg <- coni
2194(0844):             ' C__doprnt_77
2194(0844): 44 7c bc 00 '  rdbyte r11, r17 ' reg <- INDIRU1 reg
2198(0845): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
219c(0846): 05 00 7c 5c '  jmp #LODF
21a0(0847): d8 fb ff ff '  long -1064
21a4(0848): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
21a8(0849): 05 00 7c 5c '  jmp #LODF
21ac(084a): d8 fb ff ff '  long -1064
21b0(084b): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
21b4(084c): 20 7a fc a0 '  mov r10, #32 ' reg <- coni
21b8(084d): 3d 7c 3c c2 '  cmps r11, r10 wz
21bc(084e): 13 00 7c 5c '  jmp #BR_Z
21c0(084f): b0 21 00 00 '  long @C__doprnt_85 ' EQI4
21c4(0850): 23 7c 7c c2 '  cmps r11,  #35 wz
21c8(0851): 13 00 7c 5c '  jmp #BR_Z
21cc(0852): bc 21 00 00 '  long @C__doprnt_86 ' EQI4
21d0(0853): 3d 7c 3c c3 '  cmps r11, r10 wz,wc
21d4(0854): 18 00 7c 5c '  jmp #BR_B
21d8(0855): d4 21 00 00 '  long @C__doprnt_80 ' LTI4
21dc(0856): 05 00 7c 5c '  jmp #LODF
21e0(0857): d8 fb ff ff '  long -1064
21e4(0858): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
21e8(0859): 2b 7c 7c c2 '  cmps r11,  #43 wz
21ec(085a): 13 00 7c 5c '  jmp #BR_Z
21f0(085b): a4 21 00 00 '  long @C__doprnt_84 ' EQI4
21f4(085c): 2d 7c 7c c2 '  cmps r11,  #45 wz
21f8(085d): 13 00 7c 5c '  jmp #BR_Z
21fc(085e): 98 21 00 00 '  long @C__doprnt_83 ' EQI4
2200(085f): 30 7c 7c c2 '  cmps r11,  #48 wz
2204(0860): 13 00 7c 5c '  jmp #BR_Z
2208(0861): c8 21 00 00 '  long @C__doprnt_87 ' EQI4
220c(0862): 0e 00 7c 5c '  jmp #JMPA
2210(0863): d4 21 00 00 '  long @C__doprnt_80 ' JUMPV addrg
2214(0864):             ' C__doprnt_83
2214(0864): 01 80 fc 68 '  or r13, #1 ' BORI4 coni
2218(0865): 0e 00 7c 5c '  jmp #JMPA
221c(0866): ec 21 00 00 '  long @C__doprnt_81 ' JUMPV addrg
2220(0867):             ' C__doprnt_84
2220(0867): 02 80 fc 68 '  or r13, #2 ' BORI4 coni
2224(0868): 0e 00 7c 5c '  jmp #JMPA
2228(0869): ec 21 00 00 '  long @C__doprnt_81 ' JUMPV addrg
222c(086a):             ' C__doprnt_85
222c(086a): 04 80 fc 68 '  or r13, #4 ' BORI4 coni
2230(086b): 0e 00 7c 5c '  jmp #JMPA
2234(086c): ec 21 00 00 '  long @C__doprnt_81 ' JUMPV addrg
2238(086d):             ' C__doprnt_86
2238(086d): 08 80 fc 68 '  or r13, #8 ' BORI4 coni
223c(086e): 0e 00 7c 5c '  jmp #JMPA
2240(086f): ec 21 00 00 '  long @C__doprnt_81 ' JUMPV addrg
2244(0870):             ' C__doprnt_87
2244(0870): 10 80 fc 68 '  or r13, #16 ' BORI4 coni
2248(0871): 0e 00 7c 5c '  jmp #JMPA
224c(0872): ec 21 00 00 '  long @C__doprnt_81 ' JUMPV addrg
2250(0873):             ' C__doprnt_80
2250(0873): 04 00 7c 5c '  jmp #LODA
2254(0874): fc 33 00 00 '  long @C__doprnt_L000088
2258(0875): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
225c(0876): 3e 80 bc 68 '  or r13, r11 ' BORI/U (1)
2260(0877): 0e 00 7c 5c '  jmp #JMPA
2264(0878): f0 21 00 00 '  long @C__doprnt_78 ' JUMPV addrg
2268(0879):             ' C__doprnt_81
2268(0879): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
226c(087a):             ' C__doprnt_78
226c(087a): 04 00 7c 5c '  jmp #LODA
2270(087b): fc 33 00 00 '  long @C__doprnt_L000088
2274(087c): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
2278(087d): 40 7c bc 60 '  and r11, r13 ' BANDI/U (2)
227c(087e): 00 7c 7c c2 '  cmps r11,  #0 wz
2280(087f): 13 00 7c 5c '  jmp #BR_Z
2284(0880): 18 21 00 00 '  long @C__doprnt_77 ' EQI4
2288(0881): 05 00 7c 5c '  jmp #LODF
228c(0882): e4 ff ff ff '  long -28
2290(0883): 2e 88 3c 08 '  wrlong r17, RI ' ASGNP4 addrl
2294(0884): 2d 6a bc a0 '  mov r2, FP
2298(0885): 0c 6a fc 80 '  add r2, #12 ' reg ARG ADDRFi
229c(0886): 2d 6c bc a0 '  mov r3, FP
22a0(0887): 14 6c fc 84 '  sub r3, #-(-20) ' reg ARG ADDRLi
22a4(0888): 44 6e bc a0 '  mov r4, r17 ' CVI, CVU or LOAD
22a8(0889): 0c 5e fc a0 '  mov BC, #12 ' arg size
22ac(088a): 0c 58 fc 84 '  sub SP, #12 ' stack space for reg ARGs
22b0(088b): 0b 00 7c 5c '  jmp #CALA
22b4(088c): 64 19 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001
22b8(088d): 0c 58 fc 80 '  add SP, #12 ' CALL addrg
22bc(088e): 33 88 bc a0 '  mov r17, r0 ' CVI, CVU or LOAD
22c0(088f): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
22c4(0890): 2d 7a bc a0 '  mov r10, FP
22c8(0891): 1c 7a fc 84 '  sub r10, #-(-28) ' reg <- addrli
22cc(0892): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRP4 reg
22d0(0893): 3d 7c 3c 86 '  cmp r11, r10 wz
22d4(0894): 13 00 7c 5c '  jmp #BR_Z
22d8(0895): 64 22 00 00 '  long @C__doprnt_92 ' EQU4
22dc(0896): 00 81 fc 68 '  or r13, #256 ' BORI4 coni
22e0(0897):             ' C__doprnt_92
22e0(0897): 44 7c bc 00 '  rdbyte r11, r17 ' reg <- INDIRU1 reg
22e4(0898): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
22e8(0899): 2e 7c 7c c2 '  cmps r11,  #46 wz
22ec(089a): 14 00 7c 5c '  jmp #BRNZ
22f0(089b): dc 22 00 00 '  long @C__doprnt_94 ' NEI4
22f4(089c): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
22f8(089d): 05 00 7c 5c '  jmp #LODF
22fc(089e): e4 ff ff ff '  long -28
2300(089f): 2e 88 3c 08 '  wrlong r17, RI ' ASGNP4 addrl
2304(08a0): 2d 6a bc a0 '  mov r2, FP
2308(08a1): 0c 6a fc 80 '  add r2, #12 ' reg ARG ADDRFi
230c(08a2): 2d 6c bc a0 '  mov r3, FP
2310(08a3): 18 6c fc 84 '  sub r3, #-(-24) ' reg ARG ADDRLi
2314(08a4): 44 6e bc a0 '  mov r4, r17 ' CVI, CVU or LOAD
2318(08a5): 0c 5e fc a0 '  mov BC, #12 ' arg size
231c(08a6): 0c 58 fc 84 '  sub SP, #12 ' stack space for reg ARGs
2320(08a7): 0b 00 7c 5c '  jmp #CALA
2324(08a8): 64 19 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001
2328(08a9): 0c 58 fc 80 '  add SP, #12 ' CALL addrg
232c(08aa): 33 88 bc a0 '  mov r17, r0 ' CVI, CVU or LOAD
2330(08ab): 2d 7c bc a0 '  mov r11, FP
2334(08ac): 18 7c fc 84 '  sub r11, #-(-24) ' reg <- addrli
2338(08ad): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
233c(08ae): 00 7c 7c c3 '  cmps r11,  #0 wz,wc
2340(08af): 18 00 7c 5c '  jmp #BR_B
2344(08b0): dc 22 00 00 '  long @C__doprnt_96 ' LTI4
2348(08b1): 04 00 7c 5c '  jmp #LODA
234c(08b2): f8 33 00 00 '  long @C__doprnt_L000098
2350(08b3): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
2354(08b4): 3e 80 bc 68 '  or r13, r11 ' BORI/U (1)
2358(08b5):             ' C__doprnt_96
2358(08b5):             ' C__doprnt_94
2358(08b5): 00 7c fc a0 '  mov r11, #0 ' reg <- coni
235c(08b6): 40 7a bc a0 '  mov r10, r13
2360(08b7): 00 7b fc 60 '  and r10, #256 ' BANDI4 coni
2364(08b8): 3e 7a 3c c2 '  cmps r10, r11 wz
2368(08b9): 13 00 7c 5c '  jmp #BR_Z
236c(08ba): 2c 23 00 00 '  long @C__doprnt_101 ' EQI4
2370(08bb): 2d 7a bc a0 '  mov r10, FP
2374(08bc): 14 7a fc 84 '  sub r10, #-(-20) ' reg <- addrli
2378(08bd): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRI4 reg
237c(08be): 3e 7a 3c c3 '  cmps r10, r11 wz,wc
2380(08bf): 15 00 7c 5c '  jmp #BRAE
2384(08c0): 2c 23 00 00 '  long @C__doprnt_101 ' GEI4
2388(08c1): 2d 7c bc a0 '  mov r11, FP
238c(08c2): 14 7c fc 84 '  sub r11, #-(-20) ' reg <- addrli
2390(08c3): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
2394(08c4): 3e 7c bc a4 '  neg r11, r11 ' NEGI4
2398(08c5): 05 00 7c 5c '  jmp #LODF
239c(08c6): ec ff ff ff '  long -20
23a0(08c7): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
23a4(08c8): 01 80 fc 68 '  or r13, #1 ' BORI4 coni
23a8(08c9):             ' C__doprnt_101
23a8(08c9): 40 7c bc a0 '  mov r11, r13
23ac(08ca): 00 7d fc 60 '  and r11, #256 ' BANDI4 coni
23b0(08cb): 00 7c 7c c2 '  cmps r11,  #0 wz
23b4(08cc): 14 00 7c 5c '  jmp #BRNZ
23b8(08cd): 50 23 00 00 '  long @C__doprnt_103 ' NEI4
23bc(08ce): 00 7c fc a0 '  mov r11, #0 ' reg <- coni
23c0(08cf): 05 00 7c 5c '  jmp #LODF
23c4(08d0): ec ff ff ff '  long -20
23c8(08d1): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
23cc(08d2):             ' C__doprnt_103
23cc(08d2): 40 7c bc a0 '  mov r11, r13
23d0(08d3): 02 7c fc 60 '  and r11, #2 ' BANDI4 coni
23d4(08d4): 00 7c 7c c2 '  cmps r11,  #0 wz
23d8(08d5): 13 00 7c 5c '  jmp #BR_Z
23dc(08d6): 74 23 00 00 '  long @C__doprnt_105 ' EQI4
23e0(08d7): 04 00 7c 5c '  jmp #LODA
23e4(08d8): f4 33 00 00 '  long @C__doprnt_L000107
23e8(08d9): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
23ec(08da): 3e 80 bc 60 '  and r13, r11 ' BANDI/U (1)
23f0(08db):             ' C__doprnt_105
23f0(08db): 40 7c bc a0 '  mov r11, r13
23f4(08dc): 01 7c fc 60 '  and r11, #1 ' BANDI4 coni
23f8(08dd): 00 7c 7c c2 '  cmps r11,  #0 wz
23fc(08de): 13 00 7c 5c '  jmp #BR_Z
2400(08df): 98 23 00 00 '  long @C__doprnt_110 ' EQI4
2404(08e0): 04 00 7c 5c '  jmp #LODA
2408(08e1): f0 33 00 00 '  long @C__doprnt_L000112
240c(08e2): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
2410(08e3): 3e 80 bc 60 '  and r13, r11 ' BANDI/U (1)
2414(08e4):             ' C__doprnt_110
2414(08e4): 05 00 7c 5c '  jmp #LODF
2418(08e5): dc fb ff ff '  long -1060
241c(08e6): 2e 7c bc a0 '  mov r11, RI ' reg <- addrl
2420(08e7): 05 00 7c 5c '  jmp #LODF
2424(08e8): fc ff ff ff '  long -4
2428(08e9): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
242c(08ea): 05 00 7c 5c '  jmp #LODF
2430(08eb): dc fb ff ff '  long -1060
2434(08ec): 2e 84 bc a0 '  mov r15, RI ' reg <- addrl
2438(08ed): 44 7c bc 00 '  rdbyte r11, r17 ' reg <- INDIRU1 reg
243c(08ee): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
2440(08ef): 05 00 7c 5c '  jmp #LODF
2444(08f0): d8 fb ff ff '  long -1064
2448(08f1): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
244c(08f2): 05 00 7c 5c '  jmp #LODF
2450(08f3): d8 fb ff ff '  long -1064
2454(08f4): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
2458(08f5): 68 7a fc a0 '  mov r10, #104 ' reg <- coni
245c(08f6): 3d 7c 3c c2 '  cmps r11, r10 wz
2460(08f7): 13 00 7c 5c '  jmp #BR_Z
2464(08f8): 38 24 00 00 '  long @C__doprnt_118 ' EQI4
2468(08f9): 3d 7c 3c c3 '  cmps r11, r10 wz,wc
246c(08fa): 16 00 7c 5c '  jmp #BR_A
2470(08fb): 18 24 00 00 '  long @C__doprnt_122 ' GTI4
2474(08fc): 05 00 7c 5c '  jmp #LODF
2478(08fd): d8 fb ff ff '  long -1064
247c(08fe): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
2480(08ff): 4c 7c 7c c2 '  cmps r11,  #76 wz
2484(0900): 13 00 7c 5c '  jmp #BR_Z
2488(0901): 58 24 00 00 '  long @C__doprnt_120 ' EQI4
248c(0902): 0e 00 7c 5c '  jmp #JMPA
2490(0903): 60 24 00 00 '  long @C__doprnt_115 ' JUMPV addrg
2494(0904):             ' C__doprnt_122
2494(0904): 05 00 7c 5c '  jmp #LODF
2498(0905): d8 fb ff ff '  long -1064
249c(0906): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
24a0(0907): 6c 7c 7c c2 '  cmps r11,  #108 wz
24a4(0908): 13 00 7c 5c '  jmp #BR_Z
24a8(0909): 48 24 00 00 '  long @C__doprnt_119 ' EQI4
24ac(090a): 0e 00 7c 5c '  jmp #JMPA
24b0(090b): 60 24 00 00 '  long @C__doprnt_115 ' JUMPV addrg
24b4(090c):             ' C__doprnt_118
24b4(090c): 20 80 fc 68 '  or r13, #32 ' BORI4 coni
24b8(090d): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
24bc(090e): 0e 00 7c 5c '  jmp #JMPA
24c0(090f): 60 24 00 00 '  long @C__doprnt_116 ' JUMPV addrg
24c4(0910):             ' C__doprnt_119
24c4(0910): 40 80 fc 68 '  or r13, #64 ' BORI4 coni
24c8(0911): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
24cc(0912): 0e 00 7c 5c '  jmp #JMPA
24d0(0913): 60 24 00 00 '  long @C__doprnt_116 ' JUMPV addrg
24d4(0914):             ' C__doprnt_120
24d4(0914): 80 80 fc 68 '  or r13, #128 ' BORI4 coni
24d8(0915): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
24dc(0916):             ' C__doprnt_115
24dc(0916):             ' C__doprnt_116
24dc(0916): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
24e0(0917): 3e 88 bc a0 '  mov r17, r11
24e4(0918): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
24e8(0919): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
24ec(091a): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
24f0(091b): 05 00 7c 5c '  jmp #LODF
24f4(091c): f0 ff ff ff '  long -16
24f8(091d): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
24fc(091e): 05 00 7c 5c '  jmp #LODF
2500(091f): d4 fb ff ff '  long -1068
2504(0920): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2508(0921): 05 00 7c 5c '  jmp #LODF
250c(0922): d4 fb ff ff '  long -1068
2510(0923): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
2514(0924): 62 7c 7c c3 '  cmps r11,  #98 wz,wc
2518(0925): 18 00 7c 5c '  jmp #BR_B
251c(0926): cc 24 00 00 '  long @C__doprnt_160 ' LTI4
2520(0927): 75 7c 7c c3 '  cmps r11,  #117 wz,wc
2524(0928): 16 00 7c 5c '  jmp #BR_A
2528(0929): ec 24 00 00 '  long @C__doprnt_161 ' GTI4
252c(092a): 02 7c fc 2c '  shl r11, #2 ' LSHI4 coni
2530(092b): 04 00 7c 5c '  jmp #LODA
2534(092c): 0c 32 00 00 '  long @C__doprnt_162_L000164-392
2538(092d): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
253c(092e): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
2540(092f): 3e 5c bc 08 '  rdlong RI, r11
2544(0930): 0f 00 7c 5c '  jmp #JMPI ' JUMPV INDIR reg
2548(0931):             ' C__doprnt_160
2548(0931): 05 00 7c 5c '  jmp #LODF
254c(0932): d4 fb ff ff '  long -1068
2550(0933): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
2554(0934): 58 7c 7c c2 '  cmps r11,  #88 wz
2558(0935): 13 00 7c 5c '  jmp #BR_Z
255c(0936): 7c 27 00 00 '  long @C__doprnt_147 ' EQI4
2560(0937): 0e 00 7c 5c '  jmp #JMPA
2564(0938): 0c 25 00 00 '  long @C__doprnt_123 ' JUMPV addrg
2568(0939):             ' C__doprnt_161
2568(0939): 05 00 7c 5c '  jmp #LODF
256c(093a): d4 fb ff ff '  long -1068
2570(093b): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
2574(093c): 78 7c 7c c2 '  cmps r11,  #120 wz
2578(093d): 13 00 7c 5c '  jmp #BR_Z
257c(093e): 7c 27 00 00 '  long @C__doprnt_147 ' EQI4
2580(093f): 0e 00 7c 5c '  jmp #JMPA
2584(0940): 0c 25 00 00 '  long @C__doprnt_123 ' JUMPV addrg
2588(0941):             ' C__doprnt_123
2588(0941): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
258c(0942): 2d 5c bc a0 '  mov RI, FP
2590(0943): 10 5c fc 84 '  sub RI, #-(-16)
2594(0944): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRLi
2598(0945): 08 5e fc a0 '  mov BC, #8 ' arg size
259c(0946): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
25a0(0947): 0b 00 7c 5c '  jmp #CALA
25a4(0948): 58 31 00 00 '  long @C_putc
25a8(0949): 08 58 fc 80 '  add SP, #8 ' CALL addrg
25ac(094a): 04 00 7c 5c '  jmp #LODA
25b0(094b): 00 34 00 00 '  long @C__doprnt_L000071
25b4(094c): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
25b8(094d): 3d 66 3c c2 '  cmps r0, r10 wz
25bc(094e): 14 00 7c 5c '  jmp #BRNZ
25c0(094f): 98 25 00 00 '  long @C__doprnt_126 ' NEI4
25c4(0950): 00 7e 7c c2 '  cmps r12,  #0 wz
25c8(0951): 13 00 7c 5c '  jmp #BR_Z
25cc(0952): 6c 25 00 00 '  long @C__doprnt_129 ' EQI4
25d0(0953): 3f 7c bc a4 '  neg r11, r12 ' NEGI4
25d4(0954): 05 00 7c 5c '  jmp #LODF
25d8(0955): d0 fb ff ff '  long -1072
25dc(0956): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
25e0(0957): 0e 00 7c 5c '  jmp #JMPA
25e4(0958): 84 25 00 00 '  long @C__doprnt_130 ' JUMPV addrg
25e8(0959):             ' C__doprnt_129
25e8(0959): 04 00 7c 5c '  jmp #LODA
25ec(095a): 00 34 00 00 '  long @C__doprnt_L000071
25f0(095b): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
25f4(095c): 05 00 7c 5c '  jmp #LODF
25f8(095d): d0 fb ff ff '  long -1072
25fc(095e): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2600(095f):             ' C__doprnt_130
2600(095f): 05 00 7c 5c '  jmp #LODF
2604(0960): d0 fb ff ff '  long -1072
2608(0961): 2e 66 bc 08 '  rdlong r0, RI ' reg <- INDIRI4 addrl
260c(0962): 0e 00 7c 5c '  jmp #JMPA
2610(0963): a0 2f 00 00 '  long @C__doprnt_63 ' JUMPV addrg
2614(0964):             ' C__doprnt_126
2614(0964): 01 7e fc d0 '  adds r12, #1 ' ADDI4 coni
2618(0965): 0e 00 7c 5c '  jmp #JMPA
261c(0966): 70 2f 00 00 '  long @C__doprnt_65 ' JUMPV addrg
2620(0967):             ' C__doprnt_131
2620(0967): 40 7c bc a0 '  mov r11, r13
2624(0968): 20 7c fc 60 '  and r11, #32 ' BANDI4 coni
2628(0969): 00 7c 7c c2 '  cmps r11,  #0 wz
262c(096a): 13 00 7c 5c '  jmp #BR_Z
2630(096b): f8 25 00 00 '  long @C__doprnt_132 ' EQI4
2634(096c): 2d 7c bc a0 '  mov r11, FP
2638(096d): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
263c(096e): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
2640(096f): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
2644(0970): 05 00 7c 5c '  jmp #LODF
2648(0971): 0c 00 00 00 '  long 12
264c(0972): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
2650(0973): 04 00 7c 5c '  jmp #LODA
2654(0974): 04 34 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
2658(0975): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
265c(0976): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
2660(0977): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
2664(0978): 3f 7a bc a0 '  mov r10, r12 ' CVI, CVU or LOAD
2668(0979): 3e 7a 3c 04 '  wrword r10, r11 ' ASGNI2 reg
266c(097a): 0e 00 7c 5c '  jmp #JMPA
2670(097b): 70 2f 00 00 '  long @C__doprnt_65 ' JUMPV addrg
2674(097c):             ' C__doprnt_132
2674(097c): 40 7c bc a0 '  mov r11, r13
2678(097d): 40 7c fc 60 '  and r11, #64 ' BANDI4 coni
267c(097e): 00 7c 7c c2 '  cmps r11,  #0 wz
2680(097f): 13 00 7c 5c '  jmp #BR_Z
2684(0980): 48 26 00 00 '  long @C__doprnt_134 ' EQI4
2688(0981): 2d 7c bc a0 '  mov r11, FP
268c(0982): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
2690(0983): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
2694(0984): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
2698(0985): 05 00 7c 5c '  jmp #LODF
269c(0986): 0c 00 00 00 '  long 12
26a0(0987): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
26a4(0988): 04 00 7c 5c '  jmp #LODA
26a8(0989): 04 34 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
26ac(098a): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
26b0(098b): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
26b4(098c): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
26b8(098d): 3e 7e 3c 08 '  wrlong r12, r11 ' ASGNI4 reg
26bc(098e): 0e 00 7c 5c '  jmp #JMPA
26c0(098f): 70 2f 00 00 '  long @C__doprnt_65 ' JUMPV addrg
26c4(0990):             ' C__doprnt_134
26c4(0990): 2d 7c bc a0 '  mov r11, FP
26c8(0991): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
26cc(0992): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
26d0(0993): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
26d4(0994): 05 00 7c 5c '  jmp #LODF
26d8(0995): 0c 00 00 00 '  long 12
26dc(0996): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
26e0(0997): 04 00 7c 5c '  jmp #LODA
26e4(0998): 04 34 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
26e8(0999): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
26ec(099a): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
26f0(099b): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
26f4(099c): 3e 7e 3c 08 '  wrlong r12, r11 ' ASGNI4 reg
26f8(099d): 0e 00 7c 5c '  jmp #JMPA
26fc(099e): 70 2f 00 00 '  long @C__doprnt_65 ' JUMPV addrg
2700(099f):             ' C__doprnt_136
2700(099f): 2d 7c bc a0 '  mov r11, FP
2704(09a0): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
2708(09a1): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
270c(09a2): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
2710(09a3): 05 00 7c 5c '  jmp #LODF
2714(09a4): 0c 00 00 00 '  long 12
2718(09a5): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
271c(09a6): 04 00 7c 5c '  jmp #LODA
2720(09a7): 04 34 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
2724(09a8): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
2728(09a9): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
272c(09aa): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
2730(09ab): 05 00 7c 5c '  jmp #LODF
2734(09ac): fc ff ff ff '  long -4
2738(09ad): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
273c(09ae): 2d 7c bc a0 '  mov r11, FP
2740(09af): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
2744(09b0): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
2748(09b1): 00 7c 7c 86 '  cmp r11,  #0 wz
274c(09b2): 14 00 7c 5c '  jmp #BRNZ
2750(09b3): ec 26 00 00 '  long @C__doprnt_137 ' NEU4
2754(09b4): 04 00 7c 5c '  jmp #LODA
2758(09b5): e8 33 00 00 '  long @C__doprnt_139_L000140
275c(09b6): 2d 5e bc a0 '  mov BC, FP
2760(09b7): 04 5e fc 84 '  sub BC, #-(-4)
2764(09b8): 2f 5c 3c 08 '  wrlong RI, BC ' ASGNP4 addrli addrg
2768(09b9):             ' C__doprnt_137
2768(09b9): 2d 7c bc a0 '  mov r11, FP
276c(09ba): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
2770(09bb): 3e 84 bc 08 '  rdlong r15, r11 ' reg <- INDIRP4 reg
2774(09bc): 0e 00 7c 5c '  jmp #JMPA
2778(09bd): 3c 27 00 00 '  long @C__doprnt_142 ' JUMPV addrg
277c(09be):             ' C__doprnt_141
277c(09be): 42 7c bc 00 '  rdbyte r11, r15 ' reg <- INDIRU1 reg
2780(09bf): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
2784(09c0): 00 7c 7c c2 '  cmps r11,  #0 wz
2788(09c1): 14 00 7c 5c '  jmp #BRNZ
278c(09c2): 1c 27 00 00 '  long @C__doprnt_144 ' NEI4
2790(09c3): 0e 00 7c 5c '  jmp #JMPA
2794(09c4): 94 29 00 00 '  long @C__doprnt_124 ' JUMPV addrg
2798(09c5):             ' C__doprnt_144
2798(09c5): 01 84 fc d0 '  adds r15, #1 ' ADDP4 coni
279c(09c6): 2d 7c bc a0 '  mov r11, FP
27a0(09c7): 18 7c fc 84 '  sub r11, #-(-24) ' reg <- addrli
27a4(09c8): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
27a8(09c9): 01 7c fc d4 '  subs r11, #1 ' SUBI4 coni
27ac(09ca): 05 00 7c 5c '  jmp #LODF
27b0(09cb): e8 ff ff ff '  long -24
27b4(09cc): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
27b8(09cd):             ' C__doprnt_142
27b8(09cd): 00 7c fc a0 '  mov r11, #0 ' reg <- coni
27bc(09ce): 2d 7a bc a0 '  mov r10, FP
27c0(09cf): 18 7a fc 84 '  sub r10, #-(-24) ' reg <- addrli
27c4(09d0): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRI4 reg
27c8(09d1): 3e 7a 3c c2 '  cmps r10, r11 wz
27cc(09d2): 14 00 7c 5c '  jmp #BRNZ
27d0(09d3): 00 27 00 00 '  long @C__doprnt_141 ' NEI4
27d4(09d4): 04 00 7c 5c '  jmp #LODA
27d8(09d5): f8 33 00 00 '  long @C__doprnt_L000098
27dc(09d6): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
27e0(09d7): 40 7a bc 60 '  and r10, r13 ' BANDI/U (2)
27e4(09d8): 3e 7a 3c c2 '  cmps r10, r11 wz
27e8(09d9): 13 00 7c 5c '  jmp #BR_Z
27ec(09da): 00 27 00 00 '  long @C__doprnt_141 ' EQI4
27f0(09db): 0e 00 7c 5c '  jmp #JMPA
27f4(09dc): 94 29 00 00 '  long @C__doprnt_124 ' JUMPV addrg
27f8(09dd):             ' C__doprnt_146
27f8(09dd):             ' C__doprnt_147
27f8(09dd): 04 00 7c 5c '  jmp #LODA
27fc(09de): f8 33 00 00 '  long @C__doprnt_L000098
2800(09df): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
2804(09e0): 40 7c bc 60 '  and r11, r13 ' BANDI/U (2)
2808(09e1): 00 7c 7c c2 '  cmps r11,  #0 wz
280c(09e2): 14 00 7c 5c '  jmp #BRNZ
2810(09e3): b0 27 00 00 '  long @C__doprnt_148 ' NEI4
2814(09e4): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
2818(09e5): 05 00 7c 5c '  jmp #LODF
281c(09e6): e8 ff ff ff '  long -24
2820(09e7): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2824(09e8): 0e 00 7c 5c '  jmp #JMPA
2828(09e9): d8 27 00 00 '  long @C__doprnt_149 ' JUMPV addrg
282c(09ea):             ' C__doprnt_148
282c(09ea): 2d 7c bc a0 '  mov r11, FP
2830(09eb): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
2834(09ec): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
2838(09ed): 70 7c 7c c2 '  cmps r11,  #112 wz
283c(09ee): 13 00 7c 5c '  jmp #BR_Z
2840(09ef): d8 27 00 00 '  long @C__doprnt_150 ' EQI4
2844(09f0): 04 00 7c 5c '  jmp #LODA
2848(09f1): f0 33 00 00 '  long @C__doprnt_L000112
284c(09f2): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
2850(09f3): 3e 80 bc 60 '  and r13, r11 ' BANDI/U (1)
2854(09f4):             ' C__doprnt_150
2854(09f4):             ' C__doprnt_149
2854(09f4): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
2858(09f5): 2d 5c bc a0 '  mov RI, FP
285c(09f6): 18 5c fc 84 '  sub RI, #-(-24)
2860(09f7): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRLi
2864(09f8): 2d 7c bc a0 '  mov r11, FP
2868(09f9): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
286c(09fa): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
2870(09fb): 3e 6e bc a0 '  mov r4, r11 ' CVUI
2874(09fc): 4d 6e bc 60 '  and r4, cviu_m1 ' zero extend
2878(09fd): 42 70 bc a0 '  mov r5, r15 ' CVI, CVU or LOAD
287c(09fe): 10 58 fc 84 '  sub SP, #16 ' stack space for reg ARGs
2880(09ff): 40 5c bc a0 '  mov RI, r13
2884(0a00): 06 00 7c 5c '  jmp #PSHL ' stack ARG
2888(0a01): 2d 5c bc a0 '  mov RI, FP
288c(0a02): 0c 5c fc 80 '  add RI, #12
2890(0a03): 06 00 7c 5c '  jmp #PSHL ' stack ARG ADDRFi
2894(0a04): 18 5e fc a0 '  mov BC, #24 ' arg size
2898(0a05): 0b 00 7c 5c '  jmp #CALA
289c(0a06): 20 1a 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012
28a0(0a07): 18 58 fc 80 '  add SP, #24 ' CALL addrg
28a4(0a08): 33 84 bc a0 '  mov r15, r0 ' CVI, CVU or LOAD
28a8(0a09): 0e 00 7c 5c '  jmp #JMPA
28ac(0a0a): 94 29 00 00 '  long @C__doprnt_124 ' JUMPV addrg
28b0(0a0b):             ' C__doprnt_152
28b0(0a0b): 04 00 7c 5c '  jmp #LODA
28b4(0a0c): e4 33 00 00 '  long @C__doprnt_L000153
28b8(0a0d): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
28bc(0a0e): 3e 80 bc 68 '  or r13, r11 ' BORI/U (1)
28c0(0a0f): 04 00 7c 5c '  jmp #LODA
28c4(0a10): f8 33 00 00 '  long @C__doprnt_L000098
28c8(0a11): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
28cc(0a12): 40 7c bc 60 '  and r11, r13 ' BANDI/U (2)
28d0(0a13): 00 7c 7c c2 '  cmps r11,  #0 wz
28d4(0a14): 14 00 7c 5c '  jmp #BRNZ
28d8(0a15): 78 28 00 00 '  long @C__doprnt_156 ' NEI4
28dc(0a16): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
28e0(0a17): 05 00 7c 5c '  jmp #LODF
28e4(0a18): e8 ff ff ff '  long -24
28e8(0a19): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
28ec(0a1a): 0e 00 7c 5c '  jmp #JMPA
28f0(0a1b): 88 28 00 00 '  long @C__doprnt_157 ' JUMPV addrg
28f4(0a1c):             ' C__doprnt_156
28f4(0a1c): 04 00 7c 5c '  jmp #LODA
28f8(0a1d): f0 33 00 00 '  long @C__doprnt_L000112
28fc(0a1e): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
2900(0a1f): 3e 80 bc 60 '  and r13, r11 ' BANDI/U (1)
2904(0a20):             ' C__doprnt_157
2904(0a20): 01 6a fc a0 '  mov r2, #1 ' reg ARG coni
2908(0a21): 2d 5c bc a0 '  mov RI, FP
290c(0a22): 18 5c fc 84 '  sub RI, #-(-24)
2910(0a23): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRLi
2914(0a24): 2d 7c bc a0 '  mov r11, FP
2918(0a25): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
291c(0a26): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
2920(0a27): 3e 6e bc a0 '  mov r4, r11 ' CVUI
2924(0a28): 4d 6e bc 60 '  and r4, cviu_m1 ' zero extend
2928(0a29): 42 70 bc a0 '  mov r5, r15 ' CVI, CVU or LOAD
292c(0a2a): 10 58 fc 84 '  sub SP, #16 ' stack space for reg ARGs
2930(0a2b): 40 5c bc a0 '  mov RI, r13
2934(0a2c): 06 00 7c 5c '  jmp #PSHL ' stack ARG
2938(0a2d): 2d 5c bc a0 '  mov RI, FP
293c(0a2e): 0c 5c fc 80 '  add RI, #12
2940(0a2f): 06 00 7c 5c '  jmp #PSHL ' stack ARG ADDRFi
2944(0a30): 18 5e fc a0 '  mov BC, #24 ' arg size
2948(0a31): 0b 00 7c 5c '  jmp #CALA
294c(0a32): 20 1a 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012
2950(0a33): 18 58 fc 80 '  add SP, #24 ' CALL addrg
2954(0a34): 33 84 bc a0 '  mov r15, r0 ' CVI, CVU or LOAD
2958(0a35): 0e 00 7c 5c '  jmp #JMPA
295c(0a36): 94 29 00 00 '  long @C__doprnt_124 ' JUMPV addrg
2960(0a37):             ' C__doprnt_158
2960(0a37): 42 7c bc a0 '  mov r11, r15 ' CVI, CVU or LOAD
2964(0a38): 3e 84 bc a0 '  mov r15, r11
2968(0a39): 01 84 fc d0 '  adds r15, #1 ' ADDP4 coni
296c(0a3a): 2d 7a bc a0 '  mov r10, FP
2970(0a3b): 0c 7a fc 80 '  add r10, #12 ' reg <- addrfi
2974(0a3c): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRP4 reg
2978(0a3d): 04 7a fc d0 '  adds r10, #4 ' ADDP4 coni
297c(0a3e): 05 00 7c 5c '  jmp #LODF
2980(0a3f): 0c 00 00 00 '  long 12
2984(0a40): 2e 7a 3c 08 '  wrlong r10, RI ' ASGNP4 addrl
2988(0a41): 04 00 7c 5c '  jmp #LODA
298c(0a42): 04 34 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
2990(0a43): 2e 78 bc 08 '  rdlong  r9, RI ' reg <- con
2994(0a44): 3c 7a bc d0 '  adds r10, r9 ' ADDI/P (1)
2998(0a45): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRI4 reg
299c(0a46): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
29a0(0a47): 0e 00 7c 5c '  jmp #JMPA
29a4(0a48): 94 29 00 00 '  long @C__doprnt_124 ' JUMPV addrg
29a8(0a49):             ' C__doprnt_159
29a8(0a49): 2d 7c bc a0 '  mov r11, FP
29ac(0a4a): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
29b0(0a4b): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
29b4(0a4c): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
29b8(0a4d): 05 00 7c 5c '  jmp #LODF
29bc(0a4e): 0c 00 00 00 '  long 12
29c0(0a4f): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
29c4(0a50): 04 00 7c 5c '  jmp #LODA
29c8(0a51): 04 34 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
29cc(0a52): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
29d0(0a53): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
29d4(0a54): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
29d8(0a55): 05 00 7c 5c '  jmp #LODF
29dc(0a56): 0c 00 00 00 '  long 12
29e0(0a57): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
29e4(0a58): 2d 7c bc a0 '  mov r11, FP
29e8(0a59): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
29ec(0a5a): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
29f0(0a5b): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
29f4(0a5c): 05 00 7c 5c '  jmp #LODF
29f8(0a5d): 0c 00 00 00 '  long 12
29fc(0a5e): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
2a00(0a5f): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
2a04(0a60): 3e 88 bc 08 '  rdlong r17, r11 ' reg <- INDIRP4 reg
2a08(0a61): 0e 00 7c 5c '  jmp #JMPA
2a0c(0a62): 70 2f 00 00 '  long @C__doprnt_65 ' JUMPV addrg
2a10(0a63):             ' C__doprnt_124
2a10(0a63): 20 7c fc a0 '  mov r11, #32 ' reg <- coni
2a14(0a64): 05 00 7c 5c '  jmp #LODF
2a18(0a65): f4 ff ff ff '  long -12
2a1c(0a66): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2a20(0a67): 40 7c bc a0 '  mov r11, r13
2a24(0a68): 10 7c fc 60 '  and r11, #16 ' BANDI4 coni
2a28(0a69): 00 7c 7c c2 '  cmps r11,  #0 wz
2a2c(0a6a): 13 00 7c 5c '  jmp #BR_Z
2a30(0a6b): c8 29 00 00 '  long @C__doprnt_166 ' EQI4
2a34(0a6c): 30 7c fc a0 '  mov r11, #48 ' reg <- coni
2a38(0a6d): 05 00 7c 5c '  jmp #LODF
2a3c(0a6e): f4 ff ff ff '  long -12
2a40(0a6f): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2a44(0a70):             ' C__doprnt_166
2a44(0a70): 42 7c bc a0 '  mov r11, r15 ' CVI, CVU or LOAD
2a48(0a71): 2d 7a bc a0 '  mov r10, FP
2a4c(0a72): 04 7a fc 84 '  sub r10, #-(-4) ' reg <- addrli
2a50(0a73): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRP4 reg
2a54(0a74): 3d 7c bc 84 '  sub r11, r10 ' SUBU (1)
2a58(0a75): 3e 82 bc a0 '  mov r14, r11 ' CVI, CVU or LOAD
2a5c(0a76): 00 7c fc a0 '  mov r11, #0 ' reg <- coni
2a60(0a77): 05 00 7c 5c '  jmp #LODF
2a64(0a78): e0 ff ff ff '  long -32
2a68(0a79): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2a6c(0a7a): 40 7c bc a0 '  mov r11, r13
2a70(0a7b): 10 7c fc 60 '  and r11, #16 ' BANDI4 coni
2a74(0a7c): 00 7c 7c c2 '  cmps r11,  #0 wz
2a78(0a7d): 13 00 7c 5c '  jmp #BR_Z
2a7c(0a7e): c4 2a 00 00 '  long @C__doprnt_168 ' EQI4
2a80(0a7f): 2d 7c bc a0 '  mov r11, FP
2a84(0a80): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
2a88(0a81): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
2a8c(0a82): 78 7c 7c c2 '  cmps r11,  #120 wz
2a90(0a83): 13 00 7c 5c '  jmp #BR_Z
2a94(0a84): 28 2a 00 00 '  long @C__doprnt_172 ' EQI4
2a98(0a85): 58 7c 7c c2 '  cmps r11,  #88 wz
2a9c(0a86): 14 00 7c 5c '  jmp #BRNZ
2aa0(0a87): 3c 2a 00 00 '  long @C__doprnt_171 ' NEI4
2aa4(0a88):             ' C__doprnt_172
2aa4(0a88): 40 7c bc a0 '  mov r11, r13
2aa8(0a89): 08 7c fc 60 '  and r11, #8 ' BANDI4 coni
2aac(0a8a): 00 7c 7c c2 '  cmps r11,  #0 wz
2ab0(0a8b): 14 00 7c 5c '  jmp #BRNZ
2ab4(0a8c): a8 2a 00 00 '  long @C__doprnt_175 ' NEI4
2ab8(0a8d):             ' C__doprnt_171
2ab8(0a8d): 2d 7c bc a0 '  mov r11, FP
2abc(0a8e): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
2ac0(0a8f): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
2ac4(0a90): 70 7c 7c c2 '  cmps r11,  #112 wz
2ac8(0a91): 13 00 7c 5c '  jmp #BR_Z
2acc(0a92): a8 2a 00 00 '  long @C__doprnt_175 ' EQI4
2ad0(0a93): 04 00 7c 5c '  jmp #LODA
2ad4(0a94): e4 33 00 00 '  long @C__doprnt_L000153
2ad8(0a95): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
2adc(0a96): 40 7c bc 60 '  and r11, r13 ' BANDI/U (2)
2ae0(0a97): 00 7c 7c c2 '  cmps r11,  #0 wz
2ae4(0a98): 13 00 7c 5c '  jmp #BR_Z
2ae8(0a99): c4 2a 00 00 '  long @C__doprnt_168 ' EQI4
2aec(0a9a): 2d 7c bc a0 '  mov r11, FP
2af0(0a9b): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
2af4(0a9c): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
2af8(0a9d): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
2afc(0a9e): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
2b00(0a9f): 2b 7c 7c c2 '  cmps r11,  #43 wz
2b04(0aa0): 13 00 7c 5c '  jmp #BR_Z
2b08(0aa1): a8 2a 00 00 '  long @C__doprnt_175 ' EQI4
2b0c(0aa2): 2d 7c 7c c2 '  cmps r11,  #45 wz
2b10(0aa3): 13 00 7c 5c '  jmp #BR_Z
2b14(0aa4): a8 2a 00 00 '  long @C__doprnt_175 ' EQI4
2b18(0aa5): 20 7c 7c c2 '  cmps r11,  #32 wz
2b1c(0aa6): 14 00 7c 5c '  jmp #BRNZ
2b20(0aa7): c4 2a 00 00 '  long @C__doprnt_168 ' NEI4
2b24(0aa8):             ' C__doprnt_175
2b24(0aa8): 2d 7c bc a0 '  mov r11, FP
2b28(0aa9): 20 7c fc 84 '  sub r11, #-(-32) ' reg <- addrli
2b2c(0aaa): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
2b30(0aab): 01 7c fc d0 '  adds r11, #1 ' ADDI4 coni
2b34(0aac): 05 00 7c 5c '  jmp #LODF
2b38(0aad): e0 ff ff ff '  long -32
2b3c(0aae): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2b40(0aaf):             ' C__doprnt_168
2b40(0aaf): 2d 7c bc a0 '  mov r11, FP
2b44(0ab0): 14 7c fc 84 '  sub r11, #-(-20) ' reg <- addrli
2b48(0ab1): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
2b4c(0ab2): 41 7c bc d4 '  subs r11, r14 ' SUBI/P (1)
2b50(0ab3): 05 00 7c 5c '  jmp #LODF
2b54(0ab4): f8 ff ff ff '  long -8
2b58(0ab5): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2b5c(0ab6): 00 7c 7c c3 '  cmps r11,  #0 wz,wc
2b60(0ab7): 17 00 7c 5c '  jmp #BRBE
2b64(0ab8): bc 2d 00 00 '  long @C__doprnt_176 ' LEI4
2b68(0ab9): 40 7c bc a0 '  mov r11, r13
2b6c(0aba): 01 7c fc 60 '  and r11, #1 ' BANDI4 coni
2b70(0abb): 00 7c 7c c2 '  cmps r11,  #0 wz
2b74(0abc): 14 00 7c 5c '  jmp #BRNZ
2b78(0abd): bc 2d 00 00 '  long @C__doprnt_178 ' NEI4
2b7c(0abe): 2d 7c bc a0 '  mov r11, FP
2b80(0abf): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
2b84(0ac0): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
2b88(0ac1): 3e 7e bc d0 '  adds r12, r11 ' ADDI/P (1)
2b8c(0ac2): 2d 7c bc a0 '  mov r11, FP
2b90(0ac3): 20 7c fc 84 '  sub r11, #-(-32) ' reg <- addrli
2b94(0ac4): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
2b98(0ac5): 00 7c 7c c2 '  cmps r11,  #0 wz
2b9c(0ac6): 13 00 7c 5c '  jmp #BR_Z
2ba0(0ac7): 08 2d 00 00 '  long @C__doprnt_180 ' EQI4
2ba4(0ac8): 04 00 7c 5c '  jmp #LODA
2ba8(0ac9): e4 33 00 00 '  long @C__doprnt_L000153
2bac(0aca): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
2bb0(0acb): 40 7c bc 60 '  and r11, r13 ' BANDI/U (2)
2bb4(0acc): 00 7c 7c c2 '  cmps r11,  #0 wz
2bb8(0acd): 13 00 7c 5c '  jmp #BR_Z
2bbc(0ace): f8 2b 00 00 '  long @C__doprnt_182 ' EQI4
2bc0(0acf): 01 82 fc d4 '  subs r14, #1 ' SUBI4 coni
2bc4(0ad0): 01 7e fc d0 '  adds r12, #1 ' ADDI4 coni
2bc8(0ad1): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
2bcc(0ad2): 2d 7c bc a0 '  mov r11, FP
2bd0(0ad3): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
2bd4(0ad4): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
2bd8(0ad5): 3e 7a bc a0 '  mov r10, r11
2bdc(0ad6): 01 7a fc d0 '  adds r10, #1 ' ADDP4 coni
2be0(0ad7): 05 00 7c 5c '  jmp #LODF
2be4(0ad8): fc ff ff ff '  long -4
2be8(0ad9): 2e 7a 3c 08 '  wrlong r10, RI ' ASGNP4 addrl
2bec(0ada): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
2bf0(0adb): 3e 6c bc a0 '  mov r3, r11 ' CVUI
2bf4(0adc): 4d 6c bc 60 '  and r3, cviu_m1 ' zero extend
2bf8(0add): 08 5e fc a0 '  mov BC, #8 ' arg size
2bfc(0ade): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
2c00(0adf): 0b 00 7c 5c '  jmp #CALA
2c04(0ae0): 58 31 00 00 '  long @C_putc
2c08(0ae1): 08 58 fc 80 '  add SP, #8 ' CALL addrg
2c0c(0ae2): 04 00 7c 5c '  jmp #LODA
2c10(0ae3): 00 34 00 00 '  long @C__doprnt_L000071
2c14(0ae4): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
2c18(0ae5): 3d 66 3c c2 '  cmps r0, r10 wz
2c1c(0ae6): 14 00 7c 5c '  jmp #BRNZ
2c20(0ae7): 08 2d 00 00 '  long @C__doprnt_183 ' NEI4
2c24(0ae8): 00 7e 7c c2 '  cmps r12,  #0 wz
2c28(0ae9): 13 00 7c 5c '  jmp #BR_Z
2c2c(0aea): cc 2b 00 00 '  long @C__doprnt_187 ' EQI4
2c30(0aeb): 3f 7c bc a4 '  neg r11, r12 ' NEGI4
2c34(0aec): 05 00 7c 5c '  jmp #LODF
2c38(0aed): d0 fb ff ff '  long -1072
2c3c(0aee): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2c40(0aef): 0e 00 7c 5c '  jmp #JMPA
2c44(0af0): e4 2b 00 00 '  long @C__doprnt_188 ' JUMPV addrg
2c48(0af1):             ' C__doprnt_187
2c48(0af1): 04 00 7c 5c '  jmp #LODA
2c4c(0af2): 00 34 00 00 '  long @C__doprnt_L000071
2c50(0af3): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
2c54(0af4): 05 00 7c 5c '  jmp #LODF
2c58(0af5): d0 fb ff ff '  long -1072
2c5c(0af6): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2c60(0af7):             ' C__doprnt_188
2c60(0af7): 05 00 7c 5c '  jmp #LODF
2c64(0af8): d0 fb ff ff '  long -1072
2c68(0af9): 2e 66 bc 08 '  rdlong r0, RI ' reg <- INDIRI4 addrl
2c6c(0afa): 0e 00 7c 5c '  jmp #JMPA
2c70(0afb): a0 2f 00 00 '  long @C__doprnt_63 ' JUMPV addrg
2c74(0afc):             ' C__doprnt_182
2c74(0afc): 02 82 fc d4 '  subs r14, #2 ' SUBI4 coni
2c78(0afd): 02 7e fc d0 '  adds r12, #2 ' ADDI4 coni
2c7c(0afe): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
2c80(0aff): 2d 7c bc a0 '  mov r11, FP
2c84(0b00): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
2c88(0b01): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
2c8c(0b02): 3e 7a bc a0 '  mov r10, r11
2c90(0b03): 01 7a fc d0 '  adds r10, #1 ' ADDP4 coni
2c94(0b04): 05 00 7c 5c '  jmp #LODF
2c98(0b05): fc ff ff ff '  long -4
2c9c(0b06): 2e 7a 3c 08 '  wrlong r10, RI ' ASGNP4 addrl
2ca0(0b07): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
2ca4(0b08): 3e 6c bc a0 '  mov r3, r11 ' CVUI
2ca8(0b09): 4d 6c bc 60 '  and r3, cviu_m1 ' zero extend
2cac(0b0a): 08 5e fc a0 '  mov BC, #8 ' arg size
2cb0(0b0b): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
2cb4(0b0c): 0b 00 7c 5c '  jmp #CALA
2cb8(0b0d): 58 31 00 00 '  long @C_putc
2cbc(0b0e): 08 58 fc 80 '  add SP, #8 ' CALL addrg
2cc0(0b0f): 04 00 7c 5c '  jmp #LODA
2cc4(0b10): 00 34 00 00 '  long @C__doprnt_L000071
2cc8(0b11): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
2ccc(0b12): 3d 66 3c c2 '  cmps r0, r10 wz
2cd0(0b13): 13 00 7c 5c '  jmp #BR_Z
2cd4(0b14): b8 2c 00 00 '  long @C__doprnt_191 ' EQI4
2cd8(0b15): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
2cdc(0b16): 2d 7c bc a0 '  mov r11, FP
2ce0(0b17): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
2ce4(0b18): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
2ce8(0b19): 3e 7a bc a0 '  mov r10, r11
2cec(0b1a): 01 7a fc d0 '  adds r10, #1 ' ADDP4 coni
2cf0(0b1b): 05 00 7c 5c '  jmp #LODF
2cf4(0b1c): fc ff ff ff '  long -4
2cf8(0b1d): 2e 7a 3c 08 '  wrlong r10, RI ' ASGNP4 addrl
2cfc(0b1e): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
2d00(0b1f): 3e 6c bc a0 '  mov r3, r11 ' CVUI
2d04(0b20): 4d 6c bc 60 '  and r3, cviu_m1 ' zero extend
2d08(0b21): 08 5e fc a0 '  mov BC, #8 ' arg size
2d0c(0b22): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
2d10(0b23): 0b 00 7c 5c '  jmp #CALA
2d14(0b24): 58 31 00 00 '  long @C_putc
2d18(0b25): 08 58 fc 80 '  add SP, #8 ' CALL addrg
2d1c(0b26): 04 00 7c 5c '  jmp #LODA
2d20(0b27): 00 34 00 00 '  long @C__doprnt_L000071
2d24(0b28): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
2d28(0b29): 3d 66 3c c2 '  cmps r0, r10 wz
2d2c(0b2a): 14 00 7c 5c '  jmp #BRNZ
2d30(0b2b): 08 2d 00 00 '  long @C__doprnt_189 ' NEI4
2d34(0b2c):             ' C__doprnt_191
2d34(0b2c): 00 7e 7c c2 '  cmps r12,  #0 wz
2d38(0b2d): 13 00 7c 5c '  jmp #BR_Z
2d3c(0b2e): dc 2c 00 00 '  long @C__doprnt_193 ' EQI4
2d40(0b2f): 3f 7c bc a4 '  neg r11, r12 ' NEGI4
2d44(0b30): 05 00 7c 5c '  jmp #LODF
2d48(0b31): d0 fb ff ff '  long -1072
2d4c(0b32): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2d50(0b33): 0e 00 7c 5c '  jmp #JMPA
2d54(0b34): f4 2c 00 00 '  long @C__doprnt_194 ' JUMPV addrg
2d58(0b35):             ' C__doprnt_193
2d58(0b35): 04 00 7c 5c '  jmp #LODA
2d5c(0b36): 00 34 00 00 '  long @C__doprnt_L000071
2d60(0b37): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
2d64(0b38): 05 00 7c 5c '  jmp #LODF
2d68(0b39): d0 fb ff ff '  long -1072
2d6c(0b3a): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2d70(0b3b):             ' C__doprnt_194
2d70(0b3b): 05 00 7c 5c '  jmp #LODF
2d74(0b3c): d0 fb ff ff '  long -1072
2d78(0b3d): 2e 66 bc 08 '  rdlong r0, RI ' reg <- INDIRI4 addrl
2d7c(0b3e): 0e 00 7c 5c '  jmp #JMPA
2d80(0b3f): a0 2f 00 00 '  long @C__doprnt_63 ' JUMPV addrg
2d84(0b40):             ' C__doprnt_189
2d84(0b40):             ' C__doprnt_183
2d84(0b40):             ' C__doprnt_180
2d84(0b40):             ' C__doprnt_195
2d84(0b40): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
2d88(0b41): 2d 5c bc a0 '  mov RI, FP
2d8c(0b42): 0c 5c fc 84 '  sub RI, #-(-12)
2d90(0b43): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRLi
2d94(0b44): 08 5e fc a0 '  mov BC, #8 ' arg size
2d98(0b45): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
2d9c(0b46): 0b 00 7c 5c '  jmp #CALA
2da0(0b47): 58 31 00 00 '  long @C_putc
2da4(0b48): 08 58 fc 80 '  add SP, #8 ' CALL addrg
2da8(0b49): 04 00 7c 5c '  jmp #LODA
2dac(0b4a): 00 34 00 00 '  long @C__doprnt_L000071
2db0(0b4b): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
2db4(0b4c): 3d 66 3c c2 '  cmps r0, r10 wz
2db8(0b4d): 14 00 7c 5c '  jmp #BRNZ
2dbc(0b4e): 94 2d 00 00 '  long @C__doprnt_198 ' NEI4
2dc0(0b4f): 00 7e 7c c2 '  cmps r12,  #0 wz
2dc4(0b50): 13 00 7c 5c '  jmp #BR_Z
2dc8(0b51): 68 2d 00 00 '  long @C__doprnt_201 ' EQI4
2dcc(0b52): 3f 7c bc a4 '  neg r11, r12 ' NEGI4
2dd0(0b53): 05 00 7c 5c '  jmp #LODF
2dd4(0b54): d0 fb ff ff '  long -1072
2dd8(0b55): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2ddc(0b56): 0e 00 7c 5c '  jmp #JMPA
2de0(0b57): 80 2d 00 00 '  long @C__doprnt_202 ' JUMPV addrg
2de4(0b58):             ' C__doprnt_201
2de4(0b58): 04 00 7c 5c '  jmp #LODA
2de8(0b59): 00 34 00 00 '  long @C__doprnt_L000071
2dec(0b5a): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
2df0(0b5b): 05 00 7c 5c '  jmp #LODF
2df4(0b5c): d0 fb ff ff '  long -1072
2df8(0b5d): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2dfc(0b5e):             ' C__doprnt_202
2dfc(0b5e): 05 00 7c 5c '  jmp #LODF
2e00(0b5f): d0 fb ff ff '  long -1072
2e04(0b60): 2e 66 bc 08 '  rdlong r0, RI ' reg <- INDIRI4 addrl
2e08(0b61): 0e 00 7c 5c '  jmp #JMPA
2e0c(0b62): a0 2f 00 00 '  long @C__doprnt_63 ' JUMPV addrg
2e10(0b63):             ' C__doprnt_198
2e10(0b63): 2d 7c bc a0 '  mov r11, FP
2e14(0b64): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
2e18(0b65): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
2e1c(0b66): 01 7c fc d4 '  subs r11, #1 ' SUBI4 coni
2e20(0b67): 05 00 7c 5c '  jmp #LODF
2e24(0b68): f8 ff ff ff '  long -8
2e28(0b69): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2e2c(0b6a): 00 7c 7c c2 '  cmps r11,  #0 wz
2e30(0b6b): 14 00 7c 5c '  jmp #BRNZ
2e34(0b6c): 08 2d 00 00 '  long @C__doprnt_195 ' NEI4
2e38(0b6d):             ' C__doprnt_178
2e38(0b6d):             ' C__doprnt_176
2e38(0b6d): 41 7e bc d0 '  adds r12, r14 ' ADDI/P (1)
2e3c(0b6e): 0e 00 7c 5c '  jmp #JMPA
2e40(0b6f): 74 2e 00 00 '  long @C__doprnt_204 ' JUMPV addrg
2e44(0b70):             ' C__doprnt_203
2e44(0b70): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
2e48(0b71): 2d 7c bc a0 '  mov r11, FP
2e4c(0b72): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
2e50(0b73): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
2e54(0b74): 3e 7a bc a0 '  mov r10, r11
2e58(0b75): 01 7a fc d0 '  adds r10, #1 ' ADDP4 coni
2e5c(0b76): 05 00 7c 5c '  jmp #LODF
2e60(0b77): fc ff ff ff '  long -4
2e64(0b78): 2e 7a 3c 08 '  wrlong r10, RI ' ASGNP4 addrl
2e68(0b79): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
2e6c(0b7a): 3e 6c bc a0 '  mov r3, r11 ' CVUI
2e70(0b7b): 4d 6c bc 60 '  and r3, cviu_m1 ' zero extend
2e74(0b7c): 08 5e fc a0 '  mov BC, #8 ' arg size
2e78(0b7d): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
2e7c(0b7e): 0b 00 7c 5c '  jmp #CALA
2e80(0b7f): 58 31 00 00 '  long @C_putc
2e84(0b80): 08 58 fc 80 '  add SP, #8 ' CALL addrg
2e88(0b81): 04 00 7c 5c '  jmp #LODA
2e8c(0b82): 00 34 00 00 '  long @C__doprnt_L000071
2e90(0b83): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
2e94(0b84): 3d 66 3c c2 '  cmps r0, r10 wz
2e98(0b85): 14 00 7c 5c '  jmp #BRNZ
2e9c(0b86): 74 2e 00 00 '  long @C__doprnt_206 ' NEI4
2ea0(0b87): 00 7e 7c c2 '  cmps r12,  #0 wz
2ea4(0b88): 13 00 7c 5c '  jmp #BR_Z
2ea8(0b89): 48 2e 00 00 '  long @C__doprnt_209 ' EQI4
2eac(0b8a): 3f 7c bc a4 '  neg r11, r12 ' NEGI4
2eb0(0b8b): 05 00 7c 5c '  jmp #LODF
2eb4(0b8c): d0 fb ff ff '  long -1072
2eb8(0b8d): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2ebc(0b8e): 0e 00 7c 5c '  jmp #JMPA
2ec0(0b8f): 60 2e 00 00 '  long @C__doprnt_210 ' JUMPV addrg
2ec4(0b90):             ' C__doprnt_209
2ec4(0b90): 04 00 7c 5c '  jmp #LODA
2ec8(0b91): 00 34 00 00 '  long @C__doprnt_L000071
2ecc(0b92): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
2ed0(0b93): 05 00 7c 5c '  jmp #LODF
2ed4(0b94): d0 fb ff ff '  long -1072
2ed8(0b95): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2edc(0b96):             ' C__doprnt_210
2edc(0b96): 05 00 7c 5c '  jmp #LODF
2ee0(0b97): d0 fb ff ff '  long -1072
2ee4(0b98): 2e 66 bc 08 '  rdlong r0, RI ' reg <- INDIRI4 addrl
2ee8(0b99): 0e 00 7c 5c '  jmp #JMPA
2eec(0b9a): a0 2f 00 00 '  long @C__doprnt_63 ' JUMPV addrg
2ef0(0b9b):             ' C__doprnt_206
2ef0(0b9b):             ' C__doprnt_204
2ef0(0b9b): 41 7c bc a0 '  mov r11, r14
2ef4(0b9c): 01 7c fc d4 '  subs r11, #1 ' SUBI4 coni
2ef8(0b9d): 3e 82 bc a0 '  mov r14, r11 ' CVI, CVU or LOAD
2efc(0b9e): 00 7c 7c c3 '  cmps r11,  #0 wz,wc
2f00(0b9f): 15 00 7c 5c '  jmp #BRAE
2f04(0ba0): c8 2d 00 00 '  long @C__doprnt_203 ' GEI4
2f08(0ba1): 2d 7c bc a0 '  mov r11, FP
2f0c(0ba2): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
2f10(0ba3): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
2f14(0ba4): 00 7c 7c c3 '  cmps r11,  #0 wz,wc
2f18(0ba5): 17 00 7c 5c '  jmp #BRBE
2f1c(0ba6): 48 2f 00 00 '  long @C__doprnt_214 ' LEI4
2f20(0ba7): 2d 7c bc a0 '  mov r11, FP
2f24(0ba8): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
2f28(0ba9): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
2f2c(0baa): 3e 7e bc d0 '  adds r12, r11 ' ADDI/P (1)
2f30(0bab): 0e 00 7c 5c '  jmp #JMPA
2f34(0bac): 48 2f 00 00 '  long @C__doprnt_214 ' JUMPV addrg
2f38(0bad):             ' C__doprnt_213
2f38(0bad): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
2f3c(0bae): 2d 5c bc a0 '  mov RI, FP
2f40(0baf): 0c 5c fc 84 '  sub RI, #-(-12)
2f44(0bb0): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRLi
2f48(0bb1): 08 5e fc a0 '  mov BC, #8 ' arg size
2f4c(0bb2): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
2f50(0bb3): 0b 00 7c 5c '  jmp #CALA
2f54(0bb4): 58 31 00 00 '  long @C_putc
2f58(0bb5): 08 58 fc 80 '  add SP, #8 ' CALL addrg
2f5c(0bb6): 04 00 7c 5c '  jmp #LODA
2f60(0bb7): 00 34 00 00 '  long @C__doprnt_L000071
2f64(0bb8): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
2f68(0bb9): 3d 66 3c c2 '  cmps r0, r10 wz
2f6c(0bba): 14 00 7c 5c '  jmp #BRNZ
2f70(0bbb): 48 2f 00 00 '  long @C__doprnt_216 ' NEI4
2f74(0bbc): 00 7e 7c c2 '  cmps r12,  #0 wz
2f78(0bbd): 13 00 7c 5c '  jmp #BR_Z
2f7c(0bbe): 1c 2f 00 00 '  long @C__doprnt_219 ' EQI4
2f80(0bbf): 3f 7c bc a4 '  neg r11, r12 ' NEGI4
2f84(0bc0): 05 00 7c 5c '  jmp #LODF
2f88(0bc1): d0 fb ff ff '  long -1072
2f8c(0bc2): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2f90(0bc3): 0e 00 7c 5c '  jmp #JMPA
2f94(0bc4): 34 2f 00 00 '  long @C__doprnt_220 ' JUMPV addrg
2f98(0bc5):             ' C__doprnt_219
2f98(0bc5): 04 00 7c 5c '  jmp #LODA
2f9c(0bc6): 00 34 00 00 '  long @C__doprnt_L000071
2fa0(0bc7): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
2fa4(0bc8): 05 00 7c 5c '  jmp #LODF
2fa8(0bc9): d0 fb ff ff '  long -1072
2fac(0bca): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2fb0(0bcb):             ' C__doprnt_220
2fb0(0bcb): 05 00 7c 5c '  jmp #LODF
2fb4(0bcc): d0 fb ff ff '  long -1072
2fb8(0bcd): 2e 66 bc 08 '  rdlong r0, RI ' reg <- INDIRI4 addrl
2fbc(0bce): 0e 00 7c 5c '  jmp #JMPA
2fc0(0bcf): a0 2f 00 00 '  long @C__doprnt_63 ' JUMPV addrg
2fc4(0bd0):             ' C__doprnt_216
2fc4(0bd0):             ' C__doprnt_214
2fc4(0bd0): 2d 7c bc a0 '  mov r11, FP
2fc8(0bd1): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
2fcc(0bd2): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
2fd0(0bd3): 01 7c fc d4 '  subs r11, #1 ' SUBI4 coni
2fd4(0bd4): 05 00 7c 5c '  jmp #LODF
2fd8(0bd5): f8 ff ff ff '  long -8
2fdc(0bd6): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2fe0(0bd7): 00 7c 7c c3 '  cmps r11,  #0 wz,wc
2fe4(0bd8): 15 00 7c 5c '  jmp #BRAE
2fe8(0bd9): bc 2e 00 00 '  long @C__doprnt_213 ' GEI4
2fec(0bda):             ' C__doprnt_65
2fec(0bda): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
2ff0(0bdb): 3e 88 bc a0 '  mov r17, r11
2ff4(0bdc): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
2ff8(0bdd): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
2ffc(0bde): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
3000(0bdf): 05 00 7c 5c '  jmp #LODF
3004(0be0): f0 ff ff ff '  long -16
3008(0be1): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
300c(0be2): 00 7c 7c c2 '  cmps r11,  #0 wz
3010(0be3): 14 00 7c 5c '  jmp #BRNZ
3014(0be4): 64 20 00 00 '  long @C__doprnt_64 ' NEI4
3018(0be5): 3f 66 bc a0 '  mov r0, r12 ' CVI, CVU or LOAD
301c(0be6):             ' C__doprnt_63
301c(0be6): 23 00 7c 5c '  jmp #POPM
3020(0be7): 00 fe 03 00 '  long $3fe00 ' restore registers
3024(0be8): 03 00 7c 5c '  jmp #LODL
3028(0be9): 30 04 00 00 '  long 1072
302c(0bea): 2e 58 bc 80 '  add SP, RI ' framesize
3030(0beb): 0a 00 7c 5c '  jmp #RETF
3034(0bec):             '  long ' align long
3034(0bec):             ' C__i_compute ' <symbol:_i_compute>
3034(0bec): 22 00 7c 5c '  jmp #PSHM
3038(0bed): 00 fc 03 00 '  long $3fc00 ' save registers
303c(0bee): 38 88 bc a0 '  mov r17, r5 ' reg var <- reg arg
3040(0bef): 37 86 bc a0 '  mov r16, r4 ' reg var <- reg arg
3044(0bf0): 36 84 bc a0 '  mov r15, r3 ' reg var <- reg arg
3048(0bf1): 35 82 bc a0 '  mov r14, r2 ' reg var <- reg arg
304c(0bf2): 44 66 bc a0 '  mov r0, r17 ' setup r0/r1 (2)
3050(0bf3): 43 68 bc a0 '  mov r1, r16 ' setup r0/r1 (2)
3054(0bf4): 11 00 7c 5c '  jmp #DIVU ' DIVU
3058(0bf5): 34 80 bc a0 '  mov r13, r1 ' CVI, CVU or LOAD
305c(0bf6): 44 66 bc a0 '  mov r0, r17 ' setup r0/r1 (2)
3060(0bf7): 43 68 bc a0 '  mov r1, r16 ' setup r0/r1 (2)
3064(0bf8): 11 00 7c 5c '  jmp #DIVU ' DIVU
3068(0bf9): 33 88 bc a0 '  mov r17, r0 ' CVI, CVU or LOAD
306c(0bfa): 00 88 7c 86 '  cmp r17,  #0 wz
3070(0bfb): 14 00 7c 5c '  jmp #BRNZ
3074(0bfc): 08 30 00 00 '  long @C__i_compute_4 ' NEU4
3078(0bfd): 01 82 7c c3 '  cmps r14,  #1 wz,wc
307c(0bfe): 17 00 7c 5c '  jmp #BRBE
3080(0bff): 34 30 00 00 '  long @C__i_compute_2 ' LEI4
3084(0c00):             ' C__i_compute_4
3084(0c00): 41 6a bc a0 '  mov r2, r14
3088(0c01): 01 6a fc d4 '  subs r2, #1 ' SUBI4 coni
308c(0c02): 42 6c bc a0 '  mov r3, r15 ' CVI, CVU or LOAD
3090(0c03): 43 6e bc a0 '  mov r4, r16 ' CVI, CVU or LOAD
3094(0c04): 44 70 bc a0 '  mov r5, r17 ' CVI, CVU or LOAD
3098(0c05): 10 5e fc a0 '  mov BC, #16 ' arg size
309c(0c06): 10 58 fc 84 '  sub SP, #16 ' stack space for reg ARGs
30a0(0c07): 0b 00 7c 5c '  jmp #CALA
30a4(0c08): b8 2f 00 00 '  long @C__i_compute
30a8(0c09): 10 58 fc 80 '  add SP, #16 ' CALL addrg
30ac(0c0a): 33 84 bc a0 '  mov r15, r0 ' CVI, CVU or LOAD
30b0(0c0b):             ' C__i_compute_2
30b0(0c0b): 42 7c bc a0 '  mov r11, r15 ' CVI, CVU or LOAD
30b4(0c0c): 3e 84 bc a0 '  mov r15, r11
30b8(0c0d): 01 84 fc d0 '  adds r15, #1 ' ADDP4 coni
30bc(0c0e): 09 80 7c c3 '  cmps r13,  #9 wz,wc
30c0(0c0f): 17 00 7c 5c '  jmp #BRBE
30c4(0c10): 64 30 00 00 '  long @C__i_compute_6 ' LEI4
30c8(0c11): 40 7a bc a0 '  mov r10, r13
30cc(0c12): 0a 7a fc d4 '  subs r10, #10 ' SUBI4 coni
30d0(0c13): 3d 7e bc a0 '  mov r12, r10
30d4(0c14): 61 7e fc d0 '  adds r12, #97 ' ADDI4 coni
30d8(0c15): 0e 00 7c 5c '  jmp #JMPA
30dc(0c16): 6c 30 00 00 '  long @C__i_compute_7 ' JUMPV addrg
30e0(0c17):             ' C__i_compute_6
30e0(0c17): 40 7e bc a0 '  mov r12, r13
30e4(0c18): 30 7e fc d0 '  adds r12, #48 ' ADDI4 coni
30e8(0c19):             ' C__i_compute_7
30e8(0c19): 3f 7a bc a0 '  mov r10, r12 ' CVI, CVU or LOAD
30ec(0c1a): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
30f0(0c1b): 42 66 bc a0 '  mov r0, r15 ' CVI, CVU or LOAD
30f4(0c1c): 23 00 7c 5c '  jmp #POPM
30f8(0c1d): 00 fc 03 00 '  long $3fc00 ' restore registers
30fc(0c1e): 0c 00 7c 5c '  jmp #RETN
3100(0c1f):             '  long ' align long
3100(0c1f):             ' C__ina
3100(0c1f): f2 67 bc a0 '  mov r0, INA
3104(0c20): 0c 00 7c 5c '  jmp #RETN
3108(0c21):             '  long ' align long
3108(0c21):             ' C__outa
3108(0c21): f4 67 bc a0 '  mov r0, OUTA
310c(0c22): 36 e8 bf 64 '  andn OUTA, r3
3110(0c23): 35 e8 bf 68 '  or OUTA, r2
3114(0c24): 0c 00 7c 5c '  jmp #RETN
3118(0c25):             '  long ' align long
3118(0c25):             ' C_printf ' <symbol:printf>
3118(0c25): 09 00 7c 5c '  jmp #NEWF
311c(0c26): 08 58 fc 84 '  sub SP, #8
3120(0c27): 22 00 7c 5c '  jmp #PSHM
3124(0c28): 00 08 00 00 '  long $800 ' save registers
3128(0c29): 2d 5c bc a0 '  mov RI, FP
312c(0c2a): 08 5c fc 80 '  add RI, #8
3130(0c2b): 04 5e fc 84 '  sub BC, #4
3134(0c2c): 2e 5e 3c 87 '  cmp BC, RI wz,wc
3138(0c2d): 2f 6a 0c 08 '  if_ae wrlong r2, BC ' spill reg (varadic)
313c(0c2e): 04 5e fc 84 '  sub BC, #4
3140(0c2f): 2e 5e 3c 87 '  cmp BC, RI wz,wc
3144(0c30): 2f 6c 0c 08 '  if_ae wrlong r3, BC ' spill reg (varadic)
3148(0c31): 04 5e fc 84 '  sub BC, #4
314c(0c32): 2e 5e 3c 87 '  cmp BC, RI wz,wc
3150(0c33): 2f 6e 0c 08 '  if_ae wrlong r4, BC ' spill reg (varadic)
3154(0c34): 04 5e fc 84 '  sub BC, #4
3158(0c35): 2e 5e 3c 87 '  cmp BC, RI wz,wc
315c(0c36): 2f 70 0c 08 '  if_ae wrlong r5, BC ' spill reg (varadic)
3160(0c37): 2d 7c bc a0 '  mov r11, FP
3164(0c38): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
3168(0c39): 05 00 7c 5c '  jmp #LODF
316c(0c3a): fc ff ff ff '  long -4
3170(0c3b): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
3174(0c3c): 04 00 7c 5c '  jmp #LODA
3178(0c3d): 38 34 00 00 '  long @C___stdout
317c(0c3e): 2e 6a bc a0 '  mov r2, RI ' reg ARG ADDRG
3180(0c3f): 2d 5c bc a0 '  mov RI, FP
3184(0c40): 04 5c fc 84 '  sub RI, #-(-4)
3188(0c41): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRLi
318c(0c42): 2d 5c bc a0 '  mov RI, FP
3190(0c43): 08 5c fc 80 '  add RI, #8
3194(0c44): 2e 6e bc 08 '  rdlong r4, RI ' reg ARG INDIR ADDRFi
3198(0c45): 0c 5e fc a0 '  mov BC, #12 ' arg size
319c(0c46): 0c 58 fc 84 '  sub SP, #12 ' stack space for reg ARGs
31a0(0c47): 0b 00 7c 5c '  jmp #CALA
31a4(0c48): 2c 20 00 00 '  long @C__doprnt
31a8(0c49): 0c 58 fc 80 '  add SP, #12 ' CALL addrg
31ac(0c4a): 05 00 7c 5c '  jmp #LODF
31b0(0c4b): f8 ff ff ff '  long -8
31b4(0c4c): 2e 66 3c 08 '  wrlong r0, RI ' ASGNI4 addrl
31b8(0c4d): 2d 7c bc a0 '  mov r11, FP
31bc(0c4e): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
31c0(0c4f): 3e 66 bc 08 '  rdlong r0, r11 ' reg <- INDIRI4 reg
31c4(0c50): 23 00 7c 5c '  jmp #POPM
31c8(0c51): 00 08 00 00 '  long $800 ' restore registers
31cc(0c52): 08 58 fc 80 '  add SP, #8 ' framesize
31d0(0c53): 0a 00 7c 5c '  jmp #RETF
31d4(0c54):             '  long ' align long
31d4(0c54):             ' C_putc ' <symbol:putc>
31d4(0c54): 22 00 7c 5c '  jmp #PSHM
31d8(0c55): 00 08 03 00 '  long $30800 ' save registers
31dc(0c56): 36 88 bc a0 '  mov r17, r3 ' reg var <- reg arg
31e0(0c57): 35 86 bc a0 '  mov r16, r2 ' reg var <- reg arg
31e4(0c58): 44 6c bc a0 '  mov r3, r17 ' CVI, CVU or LOAD
31e8(0c59): 08 5e fc a0 '  mov BC, #8 ' arg size
31ec(0c5a): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
31f0(0c5b): 0b 00 7c 5c '  jmp #CALA
31f4(0c5c): b4 18 00 00 '  long @C_catalina_putc
31f8(0c5d): 08 58 fc 80 '  add SP, #8 ' CALL addrg
31fc(0c5e): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
3200(0c5f): 23 00 7c 5c '  jmp #POPM
3204(0c60): 00 08 03 00 '  long $30800 ' restore registers
3208(0c61): 0c 00 7c 5c '  jmp #RETN
320c(0c62):             '  long ' align long
320c(0c62):             ' C_toupper ' <symbol:toupper>
320c(0c62): 22 00 7c 5c '  jmp #PSHM
3210(0c63): 00 08 02 00 '  long $20800 ' save registers
3214(0c64): 35 7c bc a0 '  mov r11, r2
3218(0c65): 61 7c fc d4 '  subs r11, #97 ' SUBI4 coni
321c(0c66): 1a 7c 7c 87 '  cmp r11,  #26 wz,wc 
3220(0c67): 15 00 7c 5c '  jmp #BRAE
3224(0c68): c4 31 00 00 '  long @C_toupper_3 ' GEU4
3228(0c69): 35 7c bc a0 '  mov r11, r2
322c(0c6a): 61 7c fc d4 '  subs r11, #97 ' SUBI4 coni
3230(0c6b): 3e 88 bc a0 '  mov r17, r11
3234(0c6c): 41 88 fc d0 '  adds r17, #65 ' ADDI4 coni
3238(0c6d): 0e 00 7c 5c '  jmp #JMPA
323c(0c6e): c8 31 00 00 '  long @C_toupper_4 ' JUMPV addrg
3240(0c6f):             ' C_toupper_3
3240(0c6f): 35 88 bc a0 '  mov r17, r2 ' CVI, CVU or LOAD
3244(0c70):             ' C_toupper_4
3244(0c70): 44 66 bc a0 '  mov r0, r17 ' CVI, CVU or LOAD
3248(0c71): 23 00 7c 5c '  jmp #POPM
324c(0c72): 00 08 02 00 '  long $20800 ' restore registers
3250(0c73): 0c 00 7c 5c '  jmp #RETN
3254(0c74):             '  long ' align long
3254(0c74):             ' C__waitcnt
3254(0c74): 00 6a fc f8 '  waitcnt r2, #0
3258(0c75): 0c 00 7c 5c '  jmp #RETN
325c(0c76):             '  long ' align long
325c(0c76):             ' Catalina_Cnst
325c(0c76):             '  long ' align long
325c(0c76):             ' C___bbos_port_init_L000005 ' <symbol:6>
325c(0c76): 00 00 00 00 '  long 0
3260(0c77):             '  long ' align long
3260(0c77):             ' C_bbos_start_24_L000025 ' <symbol:24>
3260(0c77): 53          '  byte 83
3261(----): 74          '  byte 116
3262(----): 61          '  byte 97
3263(----): 72          '  byte 114
3264(0c78): 74          '  byte 116
3265(----): 20          '  byte 32
3266(----): 42          '  byte 66
3267(----): 42          '  byte 66
3268(0c79): 4f          '  byte 79
3269(----): 53          '  byte 83
326a(----): 0a          '  byte 10
326b(----): 00          '  byte 0
326c(0c7a):             '  long ' align long
326c(0c7a):             ' C_bbos_start_22_L000023 ' <symbol:22>
326c(0c7a): 42          '  byte 66
326d(----): 42          '  byte 66
326e(----): 4f          '  byte 79
326f(----): 53          '  byte 83
3270(0c7b): 20          '  byte 32
3271(----): 77          '  byte 119
3272(----): 61          '  byte 97
3273(----): 73          '  byte 115
3274(0c7c): 20          '  byte 32
3275(----): 6e          '  byte 110
3276(----): 6f          '  byte 111
3277(----): 74          '  byte 116
3278(0c7d): 20          '  byte 32
3279(----): 69          '  byte 105
327a(----): 6e          '  byte 110
327b(----): 69          '  byte 105
327c(0c7e): 74          '  byte 116
327d(----): 69          '  byte 105
327e(----): 61          '  byte 97
327f(----): 6c          '  byte 108
3280(0c7f): 69          '  byte 105
3281(----): 7a          '  byte 122
3282(----): 65          '  byte 101
3283(----): 64          '  byte 100
3284(0c80): 21          '  byte 33
3285(----): 0a          '  byte 10
3286(----): 00          '  byte 0
3287(----): 00          
3288(0c81):             '  long ' align long
3288(0c81):             ' C_bbos_init_17_L000018 ' <symbol:17>
3288(0c81): 53          '  byte 83
3289(----): 63          '  byte 99
328a(----): 68          '  byte 104
328b(----): 65          '  byte 101
328c(0c82): 64          '  byte 100
328d(----): 75          '  byte 117
328e(----): 6c          '  byte 108
328f(----): 65          '  byte 101
3290(0c83): 72          '  byte 114
3291(----): 20          '  byte 32
3292(----): 77          '  byte 119
3293(----): 61          '  byte 97
3294(0c84): 73          '  byte 115
3295(----): 20          '  byte 32
3296(----): 64          '  byte 100
3297(----): 69          '  byte 105
3298(0c85): 73          '  byte 115
3299(----): 61          '  byte 97
329a(----): 62          '  byte 98
329b(----): 6c          '  byte 108
329c(0c86): 65          '  byte 101
329d(----): 64          '  byte 100
329e(----): 2e          '  byte 46
329f(----): 0a          '  byte 10
32a0(0c87): 00          '  byte 0
32a1(----): 00 00 00    
32a4(0c88):             '  long ' align long
32a4(0c88):             ' C_bbos_init_15_L000016 ' <symbol:15>
32a4(0c88): 49          '  byte 73
32a5(----): 6e          '  byte 110
32a6(----): 69          '  byte 105
32a7(----): 74          '  byte 116
32a8(0c89): 69          '  byte 105
32a9(----): 61          '  byte 97
32aa(----): 6c          '  byte 108
32ab(----): 69          '  byte 105
32ac(0c8a): 7a          '  byte 122
32ad(----): 65          '  byte 101
32ae(----): 20          '  byte 32
32af(----): 42          '  byte 66
32b0(0c8b): 42          '  byte 66
32b1(----): 4f          '  byte 79
32b2(----): 53          '  byte 83
32b3(----): 0a          '  byte 10
32b4(0c8c): 00          '  byte 0
32b5(----): 00 00 00    
32b8(0c8d):             '  long ' align long
32b8(0c8d):             ' C_bbos_panic_12_L000013 ' <symbol:12>
32b8(0c8d): 50          '  byte 80
32b9(----): 61          '  byte 97
32ba(----): 6e          '  byte 110
32bb(----): 69          '  byte 105
32bc(0c8e): 63          '  byte 99
32bd(----): 3a          '  byte 58
32be(----): 20          '  byte 32
32bf(----): 25          '  byte 37
32c0(0c8f): 73          '  byte 115
32c1(----): 0a          '  byte 10
32c2(----): 00          '  byte 0
32c3(----): 00          
32c4(0c90):             '  long ' align long
32c4(0c90):             ' C_bbos_banner_6_L000007 ' <symbol:6>
32c4(0c90): 30          '  byte 48
32c5(----): 2e          '  byte 46
32c6(----): 31          '  byte 49
32c7(----): 2e          '  byte 46
32c8(0c91): 38          '  byte 56
32c9(----): 2d          '  byte 45
32ca(----): 41          '  byte 65
32cb(----): 6c          '  byte 108
32cc(0c92): 70          '  byte 112
32cd(----): 68          '  byte 104
32ce(----): 61          '  byte 97
32cf(----): 31          '  byte 49
32d0(0c93): 00          '  byte 0
32d1(----): 00 00 00    
32d4(0c94):             '  long ' align long
32d4(0c94):             ' C_bbos_banner_4_L000005 ' <symbol:4>
32d4(0c94): 42          '  byte 66
32d5(----): 42          '  byte 66
32d6(----): 4f          '  byte 79
32d7(----): 53          '  byte 83
32d8(0c95): 20          '  byte 32
32d9(----): 76          '  byte 118
32da(----): 65          '  byte 101
32db(----): 72          '  byte 114
32dc(0c96): 73          '  byte 115
32dd(----): 69          '  byte 105
32de(----): 6f          '  byte 111
32df(----): 6e          '  byte 110
32e0(0c97): 20          '  byte 32
32e1(----): 25          '  byte 37
32e2(----): 73          '  byte 115
32e3(----): 0a          '  byte 10
32e4(0c98): 43          '  byte 67
32e5(----): 6f          '  byte 111
32e6(----): 70          '  byte 112
32e7(----): 79          '  byte 121
32e8(0c99): 72          '  byte 114
32e9(----): 69          '  byte 105
32ea(----): 67          '  byte 103
32eb(----): 68          '  byte 104
32ec(0c9a): 74          '  byte 116
32ed(----): 20          '  byte 32
32ee(----): 28          '  byte 40
32ef(----): 63          '  byte 99
32f0(0c9b): 29          '  byte 41
32f1(----): 20          '  byte 32
32f2(----): 32          '  byte 50
32f3(----): 30          '  byte 48
32f4(0c9c): 31          '  byte 49
32f5(----): 31          '  byte 49
32f6(----): 20          '  byte 32
32f7(----): 53          '  byte 83
32f8(0c9d): 6c          '  byte 108
32f9(----): 61          '  byte 97
32fa(----): 64          '  byte 100
32fb(----): 65          '  byte 101
32fc(0c9e): 20          '  byte 32
32fd(----): 4d          '  byte 77
32fe(----): 61          '  byte 97
32ff(----): 75          '  byte 117
3300(0c9f): 72          '  byte 114
3301(----): 65          '  byte 101
3302(----): 72          '  byte 114
3303(----): 2c          '  byte 44
3304(0ca0): 20          '  byte 32
3305(----): 41          '  byte 65
3306(----): 6c          '  byte 108
3307(----): 65          '  byte 101
3308(0ca1): 78          '  byte 120
3309(----): 61          '  byte 97
330a(----): 6e          '  byte 110
330b(----): 64          '  byte 100
330c(0ca2): 65          '  byte 101
330d(----): 72          '  byte 114
330e(----): 20          '  byte 32
330f(----): 53          '  byte 83
3310(0ca3): 76          '  byte 118
3311(----): 69          '  byte 105
3312(----): 72          '  byte 114
3313(----): 69          '  byte 105
3314(0ca4): 64          '  byte 100
3315(----): 65          '  byte 101
3316(----): 6e          '  byte 110
3317(----): 6b          '  byte 107
3318(0ca5): 6f          '  byte 111
3319(----): 0a          '  byte 10
331a(----): 00          '  byte 0
331b(----): 00          
331c(0ca6):             '  long ' align long
331c(0ca6):             ' C_bbos_L000053 ' <symbol:54>
331c(0ca6): 80 f0 fa 02 '  long 50000000
3320(0ca7):             '  long ' align long
3320(0ca7):             ' C_bbos_L000049 ' <symbol:50>
3320(0ca7): 00 00 ff 00 '  long 16711680
3324(0ca8):             '  long ' align long
3324(0ca8):             ' C_blinker_35_L000036 ' <symbol:35>
3324(0ca8): 43          '  byte 67
3325(----): 61          '  byte 97
3326(----): 6e          '  byte 110
3327(----): 6e          '  byte 110
3328(0ca9): 6f          '  byte 111
3329(----): 74          '  byte 116
332a(----): 20          '  byte 32
332b(----): 73          '  byte 115
332c(0caa): 65          '  byte 101
332d(----): 74          '  byte 116
332e(----): 20          '  byte 32
332f(----): 6f          '  byte 111
3330(0cab): 75          '  byte 117
3331(----): 74          '  byte 116
3332(----): 70          '  byte 112
3333(----): 75          '  byte 117
3334(0cac): 74          '  byte 116
3335(----): 20          '  byte 32
3336(----): 64          '  byte 100
3337(----): 69          '  byte 105
3338(0cad): 72          '  byte 114
3339(----): 65          '  byte 101
333a(----): 63          '  byte 99
333b(----): 74          '  byte 116
333c(0cae): 69          '  byte 105
333d(----): 6f          '  byte 111
333e(----): 6e          '  byte 110
333f(----): 3a          '  byte 58
3340(0caf): 20          '  byte 32
3341(----): 25          '  byte 37
3342(----): 64          '  byte 100
3343(----): 0a          '  byte 10
3344(0cb0): 00          '  byte 0
3345(----): 00 00 00    
3348(0cb1):             '  long ' align long
3348(0cb1):             ' C_blinker_33_L000034 ' <symbol:33>
3348(0cb1): 4f          '  byte 79
3349(----): 75          '  byte 117
334a(----): 74          '  byte 116
334b(----): 70          '  byte 112
334c(0cb2): 75          '  byte 117
334d(----): 74          '  byte 116
334e(----): 20          '  byte 32
334f(----): 64          '  byte 100
3350(0cb3): 69          '  byte 105
3351(----): 72          '  byte 114
3352(----): 65          '  byte 101
3353(----): 63          '  byte 99
3354(0cb4): 74          '  byte 116
3355(----): 69          '  byte 105
3356(----): 6f          '  byte 111
3357(----): 6e          '  byte 110
3358(0cb5): 20          '  byte 32
3359(----): 77          '  byte 119
335a(----): 61          '  byte 97
335b(----): 73          '  byte 115
335c(0cb6): 20          '  byte 32
335d(----): 73          '  byte 115
335e(----): 65          '  byte 101
335f(----): 74          '  byte 116
3360(0cb7): 0a          '  byte 10
3361(----): 00          '  byte 0
3362(----): 00 00       
3364(0cb8):             '  long ' align long
3364(0cb8):             ' C_blinker_26_L000027 ' <symbol:26>
3364(0cb8): 43          '  byte 67
3365(----): 61          '  byte 97
3366(----): 6e          '  byte 110
3367(----): 6e          '  byte 110
3368(0cb9): 6f          '  byte 111
3369(----): 74          '  byte 116
336a(----): 20          '  byte 32
336b(----): 6f          '  byte 111
336c(0cba): 70          '  byte 112
336d(----): 65          '  byte 101
336e(----): 6e          '  byte 110
336f(----): 20          '  byte 32
3370(0cbb): 72          '  byte 114
3371(----): 65          '  byte 101
3372(----): 71          '  byte 113
3373(----): 75          '  byte 117
3374(0cbc): 69          '  byte 105
3375(----): 72          '  byte 114
3376(----): 65          '  byte 101
3377(----): 64          '  byte 100
3378(0cbd): 20          '  byte 32
3379(----): 70          '  byte 112
337a(----): 69          '  byte 105
337b(----): 6e          '  byte 110
337c(0cbe): 3a          '  byte 58
337d(----): 20          '  byte 32
337e(----): 25          '  byte 37
337f(----): 64          '  byte 100
3380(0cbf): 0a          '  byte 10
3381(----): 00          '  byte 0
3382(----): 00 00       
3384(0cc0):             '  long ' align long
3384(0cc0):             ' C_blinker_24_L000025 ' <symbol:24>
3384(0cc0): 50          '  byte 80
3385(----): 69          '  byte 105
3386(----): 6e          '  byte 110
3387(----): 20          '  byte 32
3388(0cc1): 25          '  byte 37
3389(----): 64          '  byte 100
338a(----): 20          '  byte 32
338b(----): 77          '  byte 119
338c(0cc2): 61          '  byte 97
338d(----): 73          '  byte 115
338e(----): 20          '  byte 32
338f(----): 73          '  byte 115
3390(0cc3): 75          '  byte 117
3391(----): 63          '  byte 99
3392(----): 63          '  byte 99
3393(----): 65          '  byte 101
3394(0cc4): 73          '  byte 115
3395(----): 73          '  byte 115
3396(----): 66          '  byte 102
3397(----): 75          '  byte 117
3398(0cc5): 6c          '  byte 108
3399(----): 6c          '  byte 108
339a(----): 79          '  byte 121
339b(----): 20          '  byte 32
339c(0cc6): 6f          '  byte 111
339d(----): 77          '  byte 119
339e(----): 6e          '  byte 110
339f(----): 65          '  byte 101
33a0(0cc7): 64          '  byte 100
33a1(----): 2e          '  byte 46
33a2(----): 0a          '  byte 10
33a3(----): 00          '  byte 0
33a4(0cc8):             '  long ' align long
33a4(0cc8):             ' C_gpio_unregister_chip_L000025 ' <symbol:26>
33a4(0cc8): 00 00 00 00 '  long 0
33a8(0cc9):             '  long ' align long
33a8(0cc9):             ' C_gpio_register_chip_L000016 ' <symbol:17>
33a8(0cc9): ff ff ff ff '  long -1
33ac(0cca):             '  long ' align long
33ac(0cca):             ' C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L00000_L000074 ' <symbol:72>
33ac(0cca): 14 16 00 00 '  long @C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_68
33b0(0ccb): 4c 16 00 00 '  long @C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_69
33b4(0ccc): 94 16 00 00 '  long @C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_70
33b8(0ccd): dc 16 00 00 '  long @C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L000007_71
33bc(0cce):             '  long ' align long
33bc(0cce):             ' C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L00000_L000056 ' <symbol:55>
33bc(0cce): 50          '  byte 80
33bd(----): 69          '  byte 105
33be(----): 6e          '  byte 110
33bf(----): 20          '  byte 32
33c0(0ccf): 25          '  byte 37
33c1(----): 64          '  byte 100
33c2(----): 20          '  byte 32
33c3(----): 69          '  byte 105
33c4(0cd0): 73          '  byte 115
33c5(----): 20          '  byte 32
33c6(----): 6f          '  byte 111
33c7(----): 77          '  byte 119
33c8(0cd1): 6e          '  byte 110
33c9(----): 65          '  byte 101
33ca(----): 64          '  byte 100
33cb(----): 20          '  byte 32
33cc(0cd2): 62          '  byte 98
33cd(----): 79          '  byte 121
33ce(----): 20          '  byte 32
33cf(----): 25          '  byte 37
33d0(0cd3): 64          '  byte 100
33d1(----): 0a          '  byte 10
33d2(----): 00          '  byte 0
33d3(----): 00          
33d4(0cd4):             '  long ' align long
33d4(0cd4):             ' C_tmpfile7Agtqh_4d07ee05_bbos_driver_demultiplexer_L00000_L000051 ' <symbol:52>
33d4(0cd4): ff ff ff ff '  long -1
33d8(0cd5):             '  long ' align long
33d8(0cd5):             ' C_p8x32a_gpio_init_41_L000042 ' <symbol:41>
33d8(0cd5): 50          '  byte 80
33d9(----): 38          '  byte 56
33da(----): 58          '  byte 88
33db(----): 33          '  byte 51
33dc(0cd6): 32          '  byte 50
33dd(----): 41          '  byte 65
33de(----): 20          '  byte 32
33df(----): 47          '  byte 71
33e0(0cd7): 50          '  byte 80
33e1(----): 49          '  byte 73
33e2(----): 4f          '  byte 79
33e3(----): 20          '  byte 32
33e4(0cd8): 64          '  byte 100
33e5(----): 72          '  byte 114
33e6(----): 69          '  byte 105
33e7(----): 76          '  byte 118
33e8(0cd9): 65          '  byte 101
33e9(----): 72          '  byte 114
33ea(----): 20          '  byte 32
33eb(----): 63          '  byte 99
33ec(0cda): 61          '  byte 97
33ed(----): 6e          '  byte 110
33ee(----): 20          '  byte 32
33ef(----): 6e          '  byte 110
33f0(0cdb): 6f          '  byte 111
33f1(----): 74          '  byte 116
33f2(----): 20          '  byte 32
33f3(----): 69          '  byte 105
33f4(0cdc): 6e          '  byte 110
33f5(----): 69          '  byte 105
33f6(----): 74          '  byte 116
33f7(----): 69          '  byte 105
33f8(0cdd): 61          '  byte 97
33f9(----): 6c          '  byte 108
33fa(----): 69          '  byte 105
33fb(----): 7a          '  byte 122
33fc(0cde): 65          '  byte 101
33fd(----): 20          '  byte 32
33fe(----): 67          '  byte 103
33ff(----): 70          '  byte 112
3400(0cdf): 69          '  byte 105
3401(----): 6f          '  byte 111
3402(----): 20          '  byte 32
3403(----): 62          '  byte 98
3404(0ce0): 61          '  byte 97
3405(----): 6e          '  byte 110
3406(----): 6b          '  byte 107
3407(----): 73          '  byte 115
3408(0ce1): 2e          '  byte 46
3409(----): 0a          '  byte 10
340a(----): 00          '  byte 0
340b(----): 00          
340c(0ce2):             '  long ' align long
340c(0ce2):             ' C_tmpfileNvAjBQ_4d07ee05_19_L000020 ' <symbol:19>
340c(0ce2): 41          '  byte 65
340d(----): 00          '  byte 0
340e(----): 00 00       
3410(0ce3):             '  long ' align long
3410(0ce3):             ' C__doprnt_162_L000164 ' <symbol:162>
3410(0ce3): 7c 27 00 00 '  long @C__doprnt_147
3414(0ce4): e4 28 00 00 '  long @C__doprnt_158
3418(0ce5): 34 28 00 00 '  long @C__doprnt_152
341c(0ce6): 0c 25 00 00 '  long @C__doprnt_123
3420(0ce7): 0c 25 00 00 '  long @C__doprnt_123
3424(0ce8): 0c 25 00 00 '  long @C__doprnt_123
3428(0ce9): 0c 25 00 00 '  long @C__doprnt_123
342c(0cea): 34 28 00 00 '  long @C__doprnt_152
3430(0ceb): 0c 25 00 00 '  long @C__doprnt_123
3434(0cec): 0c 25 00 00 '  long @C__doprnt_123
3438(0ced): 0c 25 00 00 '  long @C__doprnt_123
343c(0cee): 0c 25 00 00 '  long @C__doprnt_123
3440(0cef): a4 25 00 00 '  long @C__doprnt_131
3444(0cf0): 7c 27 00 00 '  long @C__doprnt_147
3448(0cf1): 7c 27 00 00 '  long @C__doprnt_146
344c(0cf2): 0c 25 00 00 '  long @C__doprnt_123
3450(0cf3): 2c 29 00 00 '  long @C__doprnt_159
3454(0cf4): 84 26 00 00 '  long @C__doprnt_136
3458(0cf5): 0c 25 00 00 '  long @C__doprnt_123
345c(0cf6): 7c 27 00 00 '  long @C__doprnt_147
3460(0cf7):             '  long ' align long
3460(0cf7):             ' C__doprnt_L000153 ' <symbol:154>
3460(0cf7): 00 04 00 00 '  long 1024
3464(0cf8):             '  long ' align long
3464(0cf8):             ' C__doprnt_139_L000140 ' <symbol:139>
3464(0cf8): 28          '  byte 40
3465(----): 6e          '  byte 110
3466(----): 75          '  byte 117
3467(----): 6c          '  byte 108
3468(0cf9): 6c          '  byte 108
3469(----): 29          '  byte 41
346a(----): 00          '  byte 0
346b(----): 00          
346c(0cfa):             '  long ' align long
346c(0cfa):             ' C__doprnt_L000112 ' <symbol:113>
346c(0cfa): ef ff ff ff '  long -17
3470(0cfb):             '  long ' align long
3470(0cfb):             ' C__doprnt_L000107 ' <symbol:108>
3470(0cfb): fb ff ff ff '  long -5
3474(0cfc):             '  long ' align long
3474(0cfc):             ' C__doprnt_L000098 ' <symbol:99>
3474(0cfc): 00 02 00 00 '  long 512
3478(0cfd):             '  long ' align long
3478(0cfd):             ' C__doprnt_L000088 ' <symbol:89>
3478(0cfd): 00 10 00 00 '  long 4096
347c(0cfe):             '  long ' align long
347c(0cfe):             ' C__doprnt_L000071 ' <symbol:72>
347c(0cfe): ff ff ff ff '  long -1
3480(0cff):             '  long ' align long
3480(0cff):             ' C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005 ' <symbol:6>
3480(0cff): fc ff ff ff '  long -4
3484(0d00):             '  long ' align long
3484(0d00):             ' Catalina_Init
3484(0d00):             '  long ' align long
3484(0d00): 00 00 00 00 ' C_errno long 0
3488(0d01):             '  long ' align long
3488(0d01):             ' C_blinker_init_complete_L000007 ' <symbol:init_complete>
3488(0d01): 00          '  byte $0
3489(----): 00 00 00    
348c(0d02):             '  long ' align long
348c(0d02):             ' C_blinker_mask_L000011 ' <symbol:mask>
348c(0d02): 00 00 04 00 '  long $40000
3490(0d03):             '  long ' align long
3490(0d03):             ' C_blinker_indicator_L000013 ' <symbol:indicator>
3490(0d03): 00 00 04 00 '  long $40000
3494(0d04):             '  long ' align long
3494(0d04):             ' C_p8x32a_gpio_banks ' <symbol:p8x32a_gpio_banks>
3494(0d04): 90 33 00 00 '  long @C_tmpfileNvAjBQ_4d07ee05_19_L000020
3498(0d05): 00 00       '  word 0
349a(----): 20 00       '  word $20
349c(0d06):             '  long ' align long
349c(0d06):             ' C___stdin ' <symbol:__stdin>
349c(0d06): 00 00 00 00 '  long 0
34a0(0d07): 00 00 00 00 '  long 0
34a4(0d08): 01 00 00 00 '  long 1
34a8(0d09): 00 00 00 00 '  long 0
34ac(0d0a): 00 00 00 00 '  long $0
34b0(0d0b): 00 00 00 00 '  long $0
34b4(0d0c):             '  long ' align long
34b4(0d0c):             ' C___stdout ' <symbol:__stdout>
34b4(0d0c): 00 00 00 00 '  long 0
34b8(0d0d): 01 00 00 00 '  long 1
34bc(0d0e): 02 00 00 00 '  long 2
34c0(0d0f): 00 00 00 00 '  long 0
34c4(0d10): 00 00 00 00 '  long $0
34c8(0d11): 00 00 00 00 '  long $0
34cc(0d12):             '  long ' align long
34cc(0d12):             ' C___stderr ' <symbol:__stderr>
34cc(0d12): 00 00 00 00 '  long 0
34d0(0d13): 02 00 00 00 '  long 2
34d4(0d14): 42 00 00 00 '  long 66
34d8(0d15): 00 00 00 00 '  long 0
34dc(0d16): 00 00 00 00 '  long $0
34e0(0d17): 00 00 00 00 '  long $0
34e4(0d18):             '  long ' align long
34e4(0d18):             ' C___iotab ' <symbol:__iotab>
34e4(0d18): 20 34 00 00 '  long @C___stdin
34e8(0d19): 38 34 00 00 '  long @C___stdout
34ec(0d1a): 50 34 00 00 '  long @C___stderr
34f0(0d1b): 00 00 00 00 '  long $0
34f4(0d1c): 00 00 00 00 '  byte 0[64]
34f8(0d1d): 00 00 00 00 ' 
34fc(0d1e): 00 00 00 00 ' 
3500(0d1f): 00 00 00 00 ' 
3504(0d20): 00 00 00 00 ' 
3508(0d21): 00 00 00 00 ' 
350c(0d22): 00 00 00 00 ' 
3510(0d23): 00 00 00 00 ' 
3514(0d24): 00 00 00 00 ' 
3518(0d25): 00 00 00 00 ' 
351c(0d26): 00 00 00 00 ' 
3520(0d27): 00 00 00 00 ' 
3524(0d28): 00 00 00 00 ' 
3528(0d29): 00 00 00 00 ' 
352c(0d2a): 00 00 00 00 ' 
3530(0d2b): 00 00 00 00 ' 
3534(0d2c):             '  long ' align long
3534(0d2c):             ' Catalina_Data
3534(0d2c):             '  long ' align long
3534(0d2c):             ' C_port_table ' <symbol:port_table>
3534(0d2c): 00 00 00 00 '  byte 0[24]
3538(0d2d): 00 00 00 00 ' 
353c(0d2e): 00 00 00 00 ' 
3540(0d2f): 00 00 00 00 ' 
3544(0d30): 00 00 00 00 ' 
3548(0d31): 00 00 00 00 ' 
354c(0d32):             '  long ' align long
354c(0d32):             ' C_bbos_panic_buf_L000010 ' <symbol:buf>
354c(0d32): 00 00 00 00 '  byte 0[128]
3550(0d33): 00 00 00 00 ' 
3554(0d34): 00 00 00 00 ' 
3558(0d35): 00 00 00 00 ' 
355c(0d36): 00 00 00 00 ' 
3560(0d37): 00 00 00 00 ' 
3564(0d38): 00 00 00 00 ' 
3568(0d39): 00 00 00 00 ' 
356c(0d3a): 00 00 00 00 ' 
3570(0d3b): 00 00 00 00 ' 
3574(0d3c): 00 00 00 00 ' 
3578(0d3d): 00 00 00 00 ' 
357c(0d3e): 00 00 00 00 ' 
3580(0d3f): 00 00 00 00 ' 
3584(0d40): 00 00 00 00 ' 
3588(0d41): 00 00 00 00 ' 
358c(0d42): 00 00 00 00 ' 
3590(0d43): 00 00 00 00 ' 
3594(0d44): 00 00 00 00 ' 
3598(0d45): 00 00 00 00 ' 
359c(0d46): 00 00 00 00 ' 
35a0(0d47): 00 00 00 00 ' 
35a4(0d48): 00 00 00 00 ' 
35a8(0d49): 00 00 00 00 ' 
35ac(0d4a): 00 00 00 00 ' 
35b0(0d4b): 00 00 00 00 ' 
35b4(0d4c): 00 00 00 00 ' 
35b8(0d4d): 00 00 00 00 ' 
35bc(0d4e): 00 00 00 00 ' 
35c0(0d4f): 00 00 00 00 ' 
35c4(0d50): 00 00 00 00 ' 
35c8(0d51): 00 00 00 00 ' 
35cc(0d52):             '  long ' align long
35cc(0d52):             ' C_bbos_system_state ' <symbol:bbos_system_state>
35cc(0d52): 00 00 00 00 '  byte 0[4]
35d0(0d53):             '  long ' align long
35d0(0d53):             ' C_blinker_message_L000005 ' <symbol:message>
35d0(0d53): 00 00 00 00 '  byte 0[20]
35d4(0d54): 00 00 00 00 ' 
35d8(0d55): 00 00 00 00 ' 
35dc(0d56): 00 00 00 00 ' 
35e0(0d57): 00 00 00 00 ' 
35e4(0d58):             '  long ' align long
35e4(0d58):             ' C_blinker_request_L000009 ' <symbol:request>
35e4(0d58): 00 00 00 00 '  byte 0[16]
35e8(0d59): 00 00 00 00 ' 
35ec(0d5a): 00 00 00 00 ' 
35f0(0d5b): 00 00 00 00 ' 
35f4(0d5c):             '  long ' align long
35f4(0d5c):             ' C_gpio_table ' <symbol:gpio_table>
35f4(0d5c): 00 00 00 00 '  byte 0[2048]
35f8(0d5d): 00 00 00 00 ' 
35fc(0d5e): 00 00 00 00 ' 
3600(0d5f): 00 00 00 00 ' 
3604(0d60): 00 00 00 00 ' 
3608(0d61): 00 00 00 00 ' 
360c(0d62): 00 00 00 00 ' 
3610(0d63): 00 00 00 00 ' 
3614(0d64): 00 00 00 00 ' 
3618(0d65): 00 00 00 00 ' 
361c(0d66): 00 00 00 00 ' 
3620(0d67): 00 00 00 00 ' 
3624(0d68): 00 00 00 00 ' 
3628(0d69): 00 00 00 00 ' 
362c(0d6a): 00 00 00 00 ' 
3630(0d6b): 00 00 00 00 ' 
3634(0d6c): 00 00 00 00 ' 
3638(0d6d): 00 00 00 00 ' 
363c(0d6e): 00 00 00 00 ' 
3640(0d6f): 00 00 00 00 ' 
3644(0d70): 00 00 00 00 ' 
3648(0d71): 00 00 00 00 ' 
364c(0d72): 00 00 00 00 ' 
3650(0d73): 00 00 00 00 ' 
3654(0d74): 00 00 00 00 ' 
3658(0d75): 00 00 00 00 ' 
365c(0d76): 00 00 00 00 ' 
3660(0d77): 00 00 00 00 ' 
3664(0d78): 00 00 00 00 ' 
3668(0d79): 00 00 00 00 ' 
366c(0d7a): 00 00 00 00 ' 
3670(0d7b): 00 00 00 00 ' 
3674(0d7c): 00 00 00 00 ' 
3678(0d7d): 00 00 00 00 ' 
367c(0d7e): 00 00 00 00 ' 
3680(0d7f): 00 00 00 00 ' 
3684(0d80): 00 00 00 00 ' 
3688(0d81): 00 00 00 00 ' 
368c(0d82): 00 00 00 00 ' 
3690(0d83): 00 00 00 00 ' 
3694(0d84): 00 00 00 00 ' 
3698(0d85): 00 00 00 00 ' 
369c(0d86): 00 00 00 00 ' 
36a0(0d87): 00 00 00 00 ' 
36a4(0d88): 00 00 00 00 ' 
36a8(0d89): 00 00 00 00 ' 
36ac(0d8a): 00 00 00 00 ' 
36b0(0d8b): 00 00 00 00 ' 
36b4(0d8c): 00 00 00 00 ' 
36b8(0d8d): 00 00 00 00 ' 
36bc(0d8e): 00 00 00 00 ' 
36c0(0d8f): 00 00 00 00 ' 
36c4(0d90): 00 00 00 00 ' 
36c8(0d91): 00 00 00 00 ' 
36cc(0d92): 00 00 00 00 ' 
36d0(0d93): 00 00 00 00 ' 
36d4(0d94): 00 00 00 00 ' 
36d8(0d95): 00 00 00 00 ' 
36dc(0d96): 00 00 00 00 ' 
36e0(0d97): 00 00 00 00 ' 
36e4(0d98): 00 00 00 00 ' 
36e8(0d99): 00 00 00 00 ' 
36ec(0d9a): 00 00 00 00 ' 
36f0(0d9b): 00 00 00 00 ' 
36f4(0d9c): 00 00 00 00 ' 
36f8(0d9d): 00 00 00 00 ' 
36fc(0d9e): 00 00 00 00 ' 
3700(0d9f): 00 00 00 00 ' 
3704(0da0): 00 00 00 00 ' 
3708(0da1): 00 00 00 00 ' 
370c(0da2): 00 00 00 00 ' 
3710(0da3): 00 00 00 00 ' 
3714(0da4): 00 00 00 00 ' 
3718(0da5): 00 00 00 00 ' 
371c(0da6): 00 00 00 00 ' 
3720(0da7): 00 00 00 00 ' 
3724(0da8): 00 00 00 00 ' 
3728(0da9): 00 00 00 00 ' 
372c(0daa): 00 00 00 00 ' 
3730(0dab): 00 00 00 00 ' 
3734(0dac): 00 00 00 00 ' 
3738(0dad): 00 00 00 00 ' 
373c(0dae): 00 00 00 00 ' 
3740(0daf): 00 00 00 00 ' 
3744(0db0): 00 00 00 00 ' 
3748(0db1): 00 00 00 00 ' 
374c(0db2): 00 00 00 00 ' 
3750(0db3): 00 00 00 00 ' 
3754(0db4): 00 00 00 00 ' 
3758(0db5): 00 00 00 00 ' 
375c(0db6): 00 00 00 00 ' 
3760(0db7): 00 00 00 00 ' 
3764(0db8): 00 00 00 00 ' 
3768(0db9): 00 00 00 00 ' 
376c(0dba): 00 00 00 00 ' 
3770(0dbb): 00 00 00 00 ' 
3774(0dbc): 00 00 00 00 ' 
3778(0dbd): 00 00 00 00 ' 
377c(0dbe): 00 00 00 00 ' 
3780(0dbf): 00 00 00 00 ' 
3784(0dc0): 00 00 00 00 ' 
3788(0dc1): 00 00 00 00 ' 
378c(0dc2): 00 00 00 00 ' 
3790(0dc3): 00 00 00 00 ' 
3794(0dc4): 00 00 00 00 ' 
3798(0dc5): 00 00 00 00 ' 
379c(0dc6): 00 00 00 00 ' 
37a0(0dc7): 00 00 00 00 ' 
37a4(0dc8): 00 00 00 00 ' 
37a8(0dc9): 00 00 00 00 ' 
37ac(0dca): 00 00 00 00 ' 
37b0(0dcb): 00 00 00 00 ' 
37b4(0dcc): 00 00 00 00 ' 
37b8(0dcd): 00 00 00 00 ' 
37bc(0dce): 00 00 00 00 ' 
37c0(0dcf): 00 00 00 00 ' 
37c4(0dd0): 00 00 00 00 ' 
37c8(0dd1): 00 00 00 00 ' 
37cc(0dd2): 00 00 00 00 ' 
37d0(0dd3): 00 00 00 00 ' 
37d4(0dd4): 00 00 00 00 ' 
37d8(0dd5): 00 00 00 00 ' 
37dc(0dd6): 00 00 00 00 ' 
37e0(0dd7): 00 00 00 00 ' 
37e4(0dd8): 00 00 00 00 ' 
37e8(0dd9): 00 00 00 00 ' 
37ec(0dda): 00 00 00 00 ' 
37f0(0ddb): 00 00 00 00 ' 
37f4(0ddc): 00 00 00 00 ' 
37f8(0ddd): 00 00 00 00 ' 
37fc(0dde): 00 00 00 00 ' 
3800(0ddf): 00 00 00 00 ' 
3804(0de0): 00 00 00 00 ' 
3808(0de1): 00 00 00 00 ' 
380c(0de2): 00 00 00 00 ' 
3810(0de3): 00 00 00 00 ' 
3814(0de4): 00 00 00 00 ' 
3818(0de5): 00 00 00 00 ' 
381c(0de6): 00 00 00 00 ' 
3820(0de7): 00 00 00 00 ' 
3824(0de8): 00 00 00 00 ' 
3828(0de9): 00 00 00 00 ' 
382c(0dea): 00 00 00 00 ' 
3830(0deb): 00 00 00 00 ' 
3834(0dec): 00 00 00 00 ' 
3838(0ded): 00 00 00 00 ' 
383c(0dee): 00 00 00 00 ' 
3840(0def): 00 00 00 00 ' 
3844(0df0): 00 00 00 00 ' 
3848(0df1): 00 00 00 00 ' 
384c(0df2): 00 00 00 00 ' 
3850(0df3): 00 00 00 00 ' 
3854(0df4): 00 00 00 00 ' 
3858(0df5): 00 00 00 00 ' 
385c(0df6): 00 00 00 00 ' 
3860(0df7): 00 00 00 00 ' 
3864(0df8): 00 00 00 00 ' 
3868(0df9): 00 00 00 00 ' 
386c(0dfa): 00 00 00 00 ' 
3870(0dfb): 00 00 00 00 ' 
3874(0dfc): 00 00 00 00 ' 
3878(0dfd): 00 00 00 00 ' 
387c(0dfe): 00 00 00 00 ' 
3880(0dff): 00 00 00 00 ' 
3884(0e00): 00 00 00 00 ' 
3888(0e01): 00 00 00 00 ' 
388c(0e02): 00 00 00 00 ' 
3890(0e03): 00 00 00 00 ' 
3894(0e04): 00 00 00 00 ' 
3898(0e05): 00 00 00 00 ' 
389c(0e06): 00 00 00 00 ' 
38a0(0e07): 00 00 00 00 ' 
38a4(0e08): 00 00 00 00 ' 
38a8(0e09): 00 00 00 00 ' 
38ac(0e0a): 00 00 00 00 ' 
38b0(0e0b): 00 00 00 00 ' 
38b4(0e0c): 00 00 00 00 ' 
38b8(0e0d): 00 00 00 00 ' 
38bc(0e0e): 00 00 00 00 ' 
38c0(0e0f): 00 00 00 00 ' 
38c4(0e10): 00 00 00 00 ' 
38c8(0e11): 00 00 00 00 ' 
38cc(0e12): 00 00 00 00 ' 
38d0(0e13): 00 00 00 00 ' 
38d4(0e14): 00 00 00 00 ' 
38d8(0e15): 00 00 00 00 ' 
38dc(0e16): 00 00 00 00 ' 
38e0(0e17): 00 00 00 00 ' 
38e4(0e18): 00 00 00 00 ' 
38e8(0e19): 00 00 00 00 ' 
38ec(0e1a): 00 00 00 00 ' 
38f0(0e1b): 00 00 00 00 ' 
38f4(0e1c): 00 00 00 00 ' 
38f8(0e1d): 00 00 00 00 ' 
38fc(0e1e): 00 00 00 00 ' 
3900(0e1f): 00 00 00 00 ' 
3904(0e20): 00 00 00 00 ' 
3908(0e21): 00 00 00 00 ' 
390c(0e22): 00 00 00 00 ' 
3910(0e23): 00 00 00 00 ' 
3914(0e24): 00 00 00 00 ' 
3918(0e25): 00 00 00 00 ' 
391c(0e26): 00 00 00 00 ' 
3920(0e27): 00 00 00 00 ' 
3924(0e28): 00 00 00 00 ' 
3928(0e29): 00 00 00 00 ' 
392c(0e2a): 00 00 00 00 ' 
3930(0e2b): 00 00 00 00 ' 
3934(0e2c): 00 00 00 00 ' 
3938(0e2d): 00 00 00 00 ' 
393c(0e2e): 00 00 00 00 ' 
3940(0e2f): 00 00 00 00 ' 
3944(0e30): 00 00 00 00 ' 
3948(0e31): 00 00 00 00 ' 
394c(0e32): 00 00 00 00 ' 
3950(0e33): 00 00 00 00 ' 
3954(0e34): 00 00 00 00 ' 
3958(0e35): 00 00 00 00 ' 
395c(0e36): 00 00 00 00 ' 
3960(0e37): 00 00 00 00 ' 
3964(0e38): 00 00 00 00 ' 
3968(0e39): 00 00 00 00 ' 
396c(0e3a): 00 00 00 00 ' 
3970(0e3b): 00 00 00 00 ' 
3974(0e3c): 00 00 00 00 ' 
3978(0e3d): 00 00 00 00 ' 
397c(0e3e): 00 00 00 00 ' 
3980(0e3f): 00 00 00 00 ' 
3984(0e40): 00 00 00 00 ' 
3988(0e41): 00 00 00 00 ' 
398c(0e42): 00 00 00 00 ' 
3990(0e43): 00 00 00 00 ' 
3994(0e44): 00 00 00 00 ' 
3998(0e45): 00 00 00 00 ' 
399c(0e46): 00 00 00 00 ' 
39a0(0e47): 00 00 00 00 ' 
39a4(0e48): 00 00 00 00 ' 
39a8(0e49): 00 00 00 00 ' 
39ac(0e4a): 00 00 00 00 ' 
39b0(0e4b): 00 00 00 00 ' 
39b4(0e4c): 00 00 00 00 ' 
39b8(0e4d): 00 00 00 00 ' 
39bc(0e4e): 00 00 00 00 ' 
39c0(0e4f): 00 00 00 00 ' 
39c4(0e50): 00 00 00 00 ' 
39c8(0e51): 00 00 00 00 ' 
39cc(0e52): 00 00 00 00 ' 
39d0(0e53): 00 00 00 00 ' 
39d4(0e54): 00 00 00 00 ' 
39d8(0e55): 00 00 00 00 ' 
39dc(0e56): 00 00 00 00 ' 
39e0(0e57): 00 00 00 00 ' 
39e4(0e58): 00 00 00 00 ' 
39e8(0e59): 00 00 00 00 ' 
39ec(0e5a): 00 00 00 00 ' 
39f0(0e5b): 00 00 00 00 ' 
39f4(0e5c): 00 00 00 00 ' 
39f8(0e5d): 00 00 00 00 ' 
39fc(0e5e): 00 00 00 00 ' 
3a00(0e5f): 00 00 00 00 ' 
3a04(0e60): 00 00 00 00 ' 
3a08(0e61): 00 00 00 00 ' 
3a0c(0e62): 00 00 00 00 ' 
3a10(0e63): 00 00 00 00 ' 
3a14(0e64): 00 00 00 00 ' 
3a18(0e65): 00 00 00 00 ' 
3a1c(0e66): 00 00 00 00 ' 
3a20(0e67): 00 00 00 00 ' 
3a24(0e68): 00 00 00 00 ' 
3a28(0e69): 00 00 00 00 ' 
3a2c(0e6a): 00 00 00 00 ' 
3a30(0e6b): 00 00 00 00 ' 
3a34(0e6c): 00 00 00 00 ' 
3a38(0e6d): 00 00 00 00 ' 
3a3c(0e6e): 00 00 00 00 ' 
3a40(0e6f): 00 00 00 00 ' 
3a44(0e70): 00 00 00 00 ' 
3a48(0e71): 00 00 00 00 ' 
3a4c(0e72): 00 00 00 00 ' 
3a50(0e73): 00 00 00 00 ' 
3a54(0e74): 00 00 00 00 ' 
3a58(0e75): 00 00 00 00 ' 
3a5c(0e76): 00 00 00 00 ' 
3a60(0e77): 00 00 00 00 ' 
3a64(0e78): 00 00 00 00 ' 
3a68(0e79): 00 00 00 00 ' 
3a6c(0e7a): 00 00 00 00 ' 
3a70(0e7b): 00 00 00 00 ' 
3a74(0e7c): 00 00 00 00 ' 
3a78(0e7d): 00 00 00 00 ' 
3a7c(0e7e): 00 00 00 00 ' 
3a80(0e7f): 00 00 00 00 ' 
3a84(0e80): 00 00 00 00 ' 
3a88(0e81): 00 00 00 00 ' 
3a8c(0e82): 00 00 00 00 ' 
3a90(0e83): 00 00 00 00 ' 
3a94(0e84): 00 00 00 00 ' 
3a98(0e85): 00 00 00 00 ' 
3a9c(0e86): 00 00 00 00 ' 
3aa0(0e87): 00 00 00 00 ' 
3aa4(0e88): 00 00 00 00 ' 
3aa8(0e89): 00 00 00 00 ' 
3aac(0e8a): 00 00 00 00 ' 
3ab0(0e8b): 00 00 00 00 ' 
3ab4(0e8c): 00 00 00 00 ' 
3ab8(0e8d): 00 00 00 00 ' 
3abc(0e8e): 00 00 00 00 ' 
3ac0(0e8f): 00 00 00 00 ' 
3ac4(0e90): 00 00 00 00 ' 
3ac8(0e91): 00 00 00 00 ' 
3acc(0e92): 00 00 00 00 ' 
3ad0(0e93): 00 00 00 00 ' 
3ad4(0e94): 00 00 00 00 ' 
3ad8(0e95): 00 00 00 00 ' 
3adc(0e96): 00 00 00 00 ' 
3ae0(0e97): 00 00 00 00 ' 
3ae4(0e98): 00 00 00 00 ' 
3ae8(0e99): 00 00 00 00 ' 
3aec(0e9a): 00 00 00 00 ' 
3af0(0e9b): 00 00 00 00 ' 
3af4(0e9c): 00 00 00 00 ' 
3af8(0e9d): 00 00 00 00 ' 
3afc(0e9e): 00 00 00 00 ' 
3b00(0e9f): 00 00 00 00 ' 
3b04(0ea0): 00 00 00 00 ' 
3b08(0ea1): 00 00 00 00 ' 
3b0c(0ea2): 00 00 00 00 ' 
3b10(0ea3): 00 00 00 00 ' 
3b14(0ea4): 00 00 00 00 ' 
3b18(0ea5): 00 00 00 00 ' 
3b1c(0ea6): 00 00 00 00 ' 
3b20(0ea7): 00 00 00 00 ' 
3b24(0ea8): 00 00 00 00 ' 
3b28(0ea9): 00 00 00 00 ' 
3b2c(0eaa): 00 00 00 00 ' 
3b30(0eab): 00 00 00 00 ' 
3b34(0eac): 00 00 00 00 ' 
3b38(0ead): 00 00 00 00 ' 
3b3c(0eae): 00 00 00 00 ' 
3b40(0eaf): 00 00 00 00 ' 
3b44(0eb0): 00 00 00 00 ' 
3b48(0eb1): 00 00 00 00 ' 
3b4c(0eb2): 00 00 00 00 ' 
3b50(0eb3): 00 00 00 00 ' 
3b54(0eb4): 00 00 00 00 ' 
3b58(0eb5): 00 00 00 00 ' 
3b5c(0eb6): 00 00 00 00 ' 
3b60(0eb7): 00 00 00 00 ' 
3b64(0eb8): 00 00 00 00 ' 
3b68(0eb9): 00 00 00 00 ' 
3b6c(0eba): 00 00 00 00 ' 
3b70(0ebb): 00 00 00 00 ' 
3b74(0ebc): 00 00 00 00 ' 
3b78(0ebd): 00 00 00 00 ' 
3b7c(0ebe): 00 00 00 00 ' 
3b80(0ebf): 00 00 00 00 ' 
3b84(0ec0): 00 00 00 00 ' 
3b88(0ec1): 00 00 00 00 ' 
3b8c(0ec2): 00 00 00 00 ' 
3b90(0ec3): 00 00 00 00 ' 
3b94(0ec4): 00 00 00 00 ' 
3b98(0ec5): 00 00 00 00 ' 
3b9c(0ec6): 00 00 00 00 ' 
3ba0(0ec7): 00 00 00 00 ' 
3ba4(0ec8): 00 00 00 00 ' 
3ba8(0ec9): 00 00 00 00 ' 
3bac(0eca): 00 00 00 00 ' 
3bb0(0ecb): 00 00 00 00 ' 
3bb4(0ecc): 00 00 00 00 ' 
3bb8(0ecd): 00 00 00 00 ' 
3bbc(0ece): 00 00 00 00 ' 
3bc0(0ecf): 00 00 00 00 ' 
3bc4(0ed0): 00 00 00 00 ' 
3bc8(0ed1): 00 00 00 00 ' 
3bcc(0ed2): 00 00 00 00 ' 
3bd0(0ed3): 00 00 00 00 ' 
3bd4(0ed4): 00 00 00 00 ' 
3bd8(0ed5): 00 00 00 00 ' 
3bdc(0ed6): 00 00 00 00 ' 
3be0(0ed7): 00 00 00 00 ' 
3be4(0ed8): 00 00 00 00 ' 
3be8(0ed9): 00 00 00 00 ' 
3bec(0eda): 00 00 00 00 ' 
3bf0(0edb): 00 00 00 00 ' 
3bf4(0edc): 00 00 00 00 ' 
3bf8(0edd): 00 00 00 00 ' 
3bfc(0ede): 00 00 00 00 ' 
3c00(0edf): 00 00 00 00 ' 
3c04(0ee0): 00 00 00 00 ' 
3c08(0ee1): 00 00 00 00 ' 
3c0c(0ee2): 00 00 00 00 ' 
3c10(0ee3): 00 00 00 00 ' 
3c14(0ee4): 00 00 00 00 ' 
3c18(0ee5): 00 00 00 00 ' 
3c1c(0ee6): 00 00 00 00 ' 
3c20(0ee7): 00 00 00 00 ' 
3c24(0ee8): 00 00 00 00 ' 
3c28(0ee9): 00 00 00 00 ' 
3c2c(0eea): 00 00 00 00 ' 
3c30(0eeb): 00 00 00 00 ' 
3c34(0eec): 00 00 00 00 ' 
3c38(0eed): 00 00 00 00 ' 
3c3c(0eee): 00 00 00 00 ' 
3c40(0eef): 00 00 00 00 ' 
3c44(0ef0): 00 00 00 00 ' 
3c48(0ef1): 00 00 00 00 ' 
3c4c(0ef2): 00 00 00 00 ' 
3c50(0ef3): 00 00 00 00 ' 
3c54(0ef4): 00 00 00 00 ' 
3c58(0ef5): 00 00 00 00 ' 
3c5c(0ef6): 00 00 00 00 ' 
3c60(0ef7): 00 00 00 00 ' 
3c64(0ef8): 00 00 00 00 ' 
3c68(0ef9): 00 00 00 00 ' 
3c6c(0efa): 00 00 00 00 ' 
3c70(0efb): 00 00 00 00 ' 
3c74(0efc): 00 00 00 00 ' 
3c78(0efd): 00 00 00 00 ' 
3c7c(0efe): 00 00 00 00 ' 
3c80(0eff): 00 00 00 00 ' 
3c84(0f00): 00 00 00 00 ' 
3c88(0f01): 00 00 00 00 ' 
3c8c(0f02): 00 00 00 00 ' 
3c90(0f03): 00 00 00 00 ' 
3c94(0f04): 00 00 00 00 ' 
3c98(0f05): 00 00 00 00 ' 
3c9c(0f06): 00 00 00 00 ' 
3ca0(0f07): 00 00 00 00 ' 
3ca4(0f08): 00 00 00 00 ' 
3ca8(0f09): 00 00 00 00 ' 
3cac(0f0a): 00 00 00 00 ' 
3cb0(0f0b): 00 00 00 00 ' 
3cb4(0f0c): 00 00 00 00 ' 
3cb8(0f0d): 00 00 00 00 ' 
3cbc(0f0e): 00 00 00 00 ' 
3cc0(0f0f): 00 00 00 00 ' 
3cc4(0f10): 00 00 00 00 ' 
3cc8(0f11): 00 00 00 00 ' 
3ccc(0f12): 00 00 00 00 ' 
3cd0(0f13): 00 00 00 00 ' 
3cd4(0f14): 00 00 00 00 ' 
3cd8(0f15): 00 00 00 00 ' 
3cdc(0f16): 00 00 00 00 ' 
3ce0(0f17): 00 00 00 00 ' 
3ce4(0f18): 00 00 00 00 ' 
3ce8(0f19): 00 00 00 00 ' 
3cec(0f1a): 00 00 00 00 ' 
3cf0(0f1b): 00 00 00 00 ' 
3cf4(0f1c): 00 00 00 00 ' 
3cf8(0f1d): 00 00 00 00 ' 
3cfc(0f1e): 00 00 00 00 ' 
3d00(0f1f): 00 00 00 00 ' 
3d04(0f20): 00 00 00 00 ' 
3d08(0f21): 00 00 00 00 ' 
3d0c(0f22): 00 00 00 00 ' 
3d10(0f23): 00 00 00 00 ' 
3d14(0f24): 00 00 00 00 ' 
3d18(0f25): 00 00 00 00 ' 
3d1c(0f26): 00 00 00 00 ' 
3d20(0f27): 00 00 00 00 ' 
3d24(0f28): 00 00 00 00 ' 
3d28(0f29): 00 00 00 00 ' 
3d2c(0f2a): 00 00 00 00 ' 
3d30(0f2b): 00 00 00 00 ' 
3d34(0f2c): 00 00 00 00 ' 
3d38(0f2d): 00 00 00 00 ' 
3d3c(0f2e): 00 00 00 00 ' 
3d40(0f2f): 00 00 00 00 ' 
3d44(0f30): 00 00 00 00 ' 
3d48(0f31): 00 00 00 00 ' 
3d4c(0f32): 00 00 00 00 ' 
3d50(0f33): 00 00 00 00 ' 
3d54(0f34): 00 00 00 00 ' 
3d58(0f35): 00 00 00 00 ' 
3d5c(0f36): 00 00 00 00 ' 
3d60(0f37): 00 00 00 00 ' 
3d64(0f38): 00 00 00 00 ' 
3d68(0f39): 00 00 00 00 ' 
3d6c(0f3a): 00 00 00 00 ' 
3d70(0f3b): 00 00 00 00 ' 
3d74(0f3c): 00 00 00 00 ' 
3d78(0f3d): 00 00 00 00 ' 
3d7c(0f3e): 00 00 00 00 ' 
3d80(0f3f): 00 00 00 00 ' 
3d84(0f40): 00 00 00 00 ' 
3d88(0f41): 00 00 00 00 ' 
3d8c(0f42): 00 00 00 00 ' 
3d90(0f43): 00 00 00 00 ' 
3d94(0f44): 00 00 00 00 ' 
3d98(0f45): 00 00 00 00 ' 
3d9c(0f46): 00 00 00 00 ' 
3da0(0f47): 00 00 00 00 ' 
3da4(0f48): 00 00 00 00 ' 
3da8(0f49): 00 00 00 00 ' 
3dac(0f4a): 00 00 00 00 ' 
3db0(0f4b): 00 00 00 00 ' 
3db4(0f4c): 00 00 00 00 ' 
3db8(0f4d): 00 00 00 00 ' 
3dbc(0f4e): 00 00 00 00 ' 
3dc0(0f4f): 00 00 00 00 ' 
3dc4(0f50): 00 00 00 00 ' 
3dc8(0f51): 00 00 00 00 ' 
3dcc(0f52): 00 00 00 00 ' 
3dd0(0f53): 00 00 00 00 ' 
3dd4(0f54): 00 00 00 00 ' 
3dd8(0f55): 00 00 00 00 ' 
3ddc(0f56): 00 00 00 00 ' 
3de0(0f57): 00 00 00 00 ' 
3de4(0f58): 00 00 00 00 ' 
3de8(0f59): 00 00 00 00 ' 
3dec(0f5a): 00 00 00 00 ' 
3df0(0f5b): 00 00 00 00 ' 
3df4(0f5c):             '  long ' align long
3df4(0f5c):             ' C_tmpfileZ46XDe_4d07ee05_driver_message_L000005 ' <symbol:driver_message>
3df4(0f5c): 00 00 00 00 '  byte 0[20]
3df8(0f5d): 00 00 00 00 ' 
3dfc(0f5e): 00 00 00 00 ' 
3e00(0f5f): 00 00 00 00 ' 
3e04(0f60): 00 00 00 00 ' 
3e08(0f61):             '  long ' align long
3e08(0f61):             ' C_tmpfilerULIfI_4d07ee05_driver_listen_port_id_L000004 ' <symbol:driver_listen_port_id>
3e08(0f61): 00 00       '  byte 0[2]
3e0a(----): 00 00       
3e0c(0f62):             '  long ' align long
3e0c(0f62):             ' C_tmpfiler5stRb_4d07ee05_driver_thread_id_L000003 ' <symbol:driver_thread_id>
3e0c(0f62): 00 00       '  byte 0[2]
3e0e(----): 00 00       
3e10(0f63):             '  long ' align long
3e10(0f63):             ' sbrkinit  ' heap starts here
3e10(0f63): 00 00 00 00 '  long 0 ' this long is required to workaround an obscure homespun bug!!!
3e14(0f64):             '  long ' align long
3e14(0f64):             ' Catalina_Ends ' end of segments
'============================ Method #1: PUB Base =============================
'PUB Base : addr
'------------------------------------------------------------------------------
   addr := @@0 ' Catalina Base Address
'------------------------------------------------------------------------------
3e14: 35             PUSH#0	
3e15: 97 00          PUSH#.B	OBJ+0[]
3e17: 61             POP  	Locals+0
3e18: 32             RETURN	
3e19: 00 00 00    

'******************************************************************************
'                           Catalina_Cogstore.spin                             
'******************************************************************************

'=================================== CONs =====================================
MAX_LONGS = 300
COGSTORE = 32508
ARGC_ADDR = 32560
ARGV_ADDR = 32562
ARGV_0 = 32564
ARGV_MAX = 32
CMD_READ = 268435456
CMD_WRITE = 536870912
CMD_SIZE = 805306368
CMD_SETUP = 1073741824
CMD_RESPONSE = -17958194
QUOTE_CHAR = 34
'=============================== Object Header ================================
3e1c: ac 03 08 01 ' 940 bytes, 8-1 methods, 1 object pointers
3e20: 94 02 00 00 ' ptr #1 to $40b0: PUB Start (locals size: 0)
3e24: 9b 02 00 00 ' ptr #2 to $40b7: PUB Valid (locals size: 0)
3e28: b7 02 00 00 ' ptr #3 to $40d3: PUB Stop (locals size: 0)
3e2c: c0 02 00 00 ' ptr #4 to $40dc: PUB Write (locals size: 0)
3e30: e6 02 00 00 ' ptr #5 to $4102: PUB Read (locals size: 0)
3e34: 0c 03 04 00 ' ptr #6 to $4128: PUB Size (locals size: 4)
3e38: 41 03 00 00 ' ptr #7 to $415d: PUB Setup (locals size: 0)
3e3c: f8 20 00 00 ' ptr #8 to $5f14: OBJ common : Catalina_Common.spin (VAR offset: 0)
'================================ DAT Section =================================
3e40(0000):             '               org       0
3e40(0000):             ' entry
3e40(0000):             ' done
3e40(0000): 00 18 fd a0 '               mov       t0,#0
3e44(0001): 91 18 3d 08 '               wrlong    t0,command
3e48(0002):             ' loop
3e48(0002): 91 18 bd 0a '               rdlong    t0,command wz           ' loop ...
3e4c(0003): 02 00 68 5c '         if_z  jmp       #loop                   ' ... till ...
3e50(0004): 93 18 3d 86 '               cmp       t0,response wz          ' ... we get ...
3e54(0005): 02 00 68 5c '         if_z  jmp       #loop                   ' ... a command
3e58(0006): 8c 1a bd a0 '               mov       t1,t0                   ' extract ...
3e5c(0007): 90 1a bd 60 '               and       t1,low24                ' ... address argument
3e60(0008): 1c 18 fd 28 '               shr       t0,#28                  ' extract command
3e64(0009): 01 18 7d 86 '               cmp       t0,#CMD_READ>>28 wz     ' do ...
3e68(000a): 13 00 68 5c '         if_z  jmp       #do_read                ' ... read
3e6c(000b): 02 18 7d 86 '               cmp       t0,#CMD_WRITE>>28 wz    ' do ... 
3e70(000c): 1b 00 68 5c '         if_z  jmp       #do_write               ' ... write               
3e74(000d): 03 18 7d 86 '               cmp       t0,#CMD_SIZE>>28 wz     ' do ...
3e78(000e): 2a 00 68 5c '         if_z  jmp       #do_size                ' ... size
3e7c(000f): 04 18 7d 86 '               cmp       t0,#CMD_SETUP>>28 wz    ' do ...
3e80(0010): 30 00 68 5c '         if_z  jmp       #do_setup               ' ... setup
3e84(0011):             ' identify        
3e84(0011): 91 26 3d 08 '               wrlong    response,command        ' otherwise return unlikely response ...
3e88(0012): 02 00 7c 5c '               jmp       #loop                   ' ... and loop till we get a known command
3e8c(0013):             ' do_read
3e8c(0013): 9b 2c fc 54 '               movd      rd_inst,#storage        ' read a copy ...                                
3e90(0014): 98 18 bd a2 '               mov       t0,len wz               ' ... of ...                                
3e94(0015):             ' rd_loop                                         ' ... the ...                                  
3e94(0015): 00 00 68 5c '         if_z  jmp       #done                   ' ... string ...                                
3e98(0016): 8d 00 3c 08 ' rd_inst       wrlong    0-0,t1                  ' ... to ...                              
3e9c(0017): 97 2c bc 80 '               add       rd_inst,d_inc           ' ... the ...                                 
3ea0(0018): 04 1a fd 80 '               add       t1,#4                   ' ... address ...                                   
3ea4(0019): 01 18 fd 86 '               sub       t0,#1 wz                ' ... provided ...                              
3ea8(001a): 15 00 7c 5c '               jmp       #rd_loop                ' ... (assume there is enough space!)
3eac(001b):             ' do_write
3eac(001b): 9b 3c fc 54 '               movd      wr_inst,#storage        ' write ...
3eb0(001c): 00 30 fd a0 '               mov       len,#0                  ' ... a ...
3eb4(001d):             ' wr_loop                                         ' ... copy ...
3eb4(001d): 8d 1c bd 08 '               rdlong    t2,t1                   ' ... of ...
3eb8(001e): 8e 00 bc a0 ' wr_inst       mov       0-0,t2                  ' ... the ...
3ebc(001f): 97 3c bc 80 '               add       wr_inst,d_inc           ' ... string ...
3ec0(0020): 04 1a fd 80 '               add       t1,#4                   ' ... to ...
3ec4(0021): 01 30 fd 80 '               add       len,#1                  ' ... cog ...
3ec8(0022): 2c 31 7d 86 '               cmp       len,#MAX_LONGS wz       ' ... RAM ...
3ecc(0023): 00 00 68 5c '         if_z  jmp       #done                   ' ... stopping ...
3ed0(0024): 04 18 fd a0 '               mov       t0,#4                   ' ... when ... 
3ed4(0025): ff 1c 7d 62 ' wr_test       test      t2,#$FF wz              ' ... cog ...
3ed8(0026): 00 00 68 5c '       if_z    jmp       #done                   ' ... full ...
3edc(0027): 08 1c fd 28 '               shr       t2,#8                   ' ... or ...
3ee0(0028): 25 18 fd e4 '               djnz      t0,#wr_test             ' ... termination ... 
3ee4(0029): 1d 00 7c 5c '               jmp       #wr_loop                ' ... detected
3ee8(002a):             ' do_size
3ee8(002a): 90 1a 3d 86 '               cmp       t1,low24 wz             ' return ...
3eec(002b): 02 00 54 5c '         if_nz jmp       #loop                   ' ... the ...                     
3ef0(002c): 98 18 bd a0 '               mov       t0,len                  ' ... size (in LONGs) ...
3ef4(002d): 92 18 bd 68 '               or        t0,size_cmd             ' ... of ...
3ef8(002e): 91 18 3d 08 '               wrlong    t0,command              ' ... the stored ...
3efc(002f): 02 00 7c 5c '               jmp       #loop                   ' ... command line
3f00(0030):             ' do_setup                                        
3f00(0030): 77 30 7d ec '               tjz       len,#no_args            ' if no stored string, set argc/argv to default values
3f04(0031): 8d 1c bd a0 '               mov       t2,t1                   ' save the address argument
3f08(0032): 9b 6a fc 54 '               movd      su_inst,#storage        ' otherwise ...
3f0c(0033): 98 18 bd a2 '               mov       t0,len wz               ' ... read ...
3f10(0034):             ' su_loop                                         ' ... the ...             
3f10(0034): 3a 00 68 5c '         if_z  jmp       #su_count_args          ' ... stored ...
3f14(0035): 8d 00 3c 08 ' su_inst       wrlong    0-0,t1                  ' ... string ...
3f18(0036): 97 6a bc 80 '               add       su_inst,d_inc           ' ... to ...
3f1c(0037): 04 1a fd 80 '               add       t1,#4                   ' ... the ...
3f20(0038): 01 18 fd 86 '               sub       t0,#1 wz                ' ... address ...
3f24(0039): 34 00 7c 5c '               jmp       #su_loop                ' ... provided (assume there is enough space!) 
3f28(003a):             ' su_count_args
3f28(003a): 8e 1a bd a0 '               mov       t1,t2                   ' count the number of arguments in the string
3f2c(003b): 00 32 fd a0 '               mov       n,#0                    ' no arguments yet           
3f30(003c): 00 34 fd a0 '               mov       q,#0                    ' not in a quoted string                                                    
3f34(003d):             ' su_count_loop
3f34(003d): 7c 00 fd 5c '               call      #skip_to_non_space      ' find next non-space
3f38(003e): 00 18 7d 86 '               cmp       t0,#0 wz                ' end of string?
3f3c(003f): 43 00 68 5c '         if_z  jmp       #su_save_argc           ' yes - set up argc
3f40(0040): 01 32 fd 80 '               add       n,#1                    ' no - found an argument
3f44(0041): 81 16 fd 5c '               call      #skip_to_space          ' skip to next space (i.e. end of argument)                            
3f48(0042): 3d 00 7c 5c '               jmp       #su_count_loop                         
3f4c(0043):             ' su_save_argc
3f4c(0043): 20 32 7d 87 '               cmp       n,#ARGV_MAX wz,wc       ' set up argc and first element of argv                                 
3f50(0044): 20 32 c5 a0 '         if_a  mov       n,#ARGV_MAX             '                                    
3f54(0045): 94 32 3d 04 '               wrword    n,argc                  ' word[common#ARGC_ADDR] := n                                              
3f58(0046): 95 2c 3d 04 '               wrword    argv_start,argv         ' word[common#ARGV_ADDR] := argv_0                               
3f5c(0047): 8e 1a bd a0 '               mov       t1,t2      
3f60(0048): 7c 00 fd 5c '               call      #skip_to_non_space      ' find start of first argument ...
3f64(0049): 96 1e bd a0 '               mov       t3,argv_start           ' ... and save it ...                                
3f68(004a): 8f 1a 3d 08 '               wrlong    t1,t3                   ' ... in long[common#ARGV_0] 
3f6c(004b): 00 34 fd a0 '               mov       q,#0                    ' not currently within quoted string
3f70(004c):             ' su_argv_loop
3f70(004c): 8d 18 bd 02 '               rdbyte    t0,t1 wz                ' deconstruct command line, creating the argv array as we go                 
3f74(004d): 73 00 68 5c '         if_z  jmp       #su_argv_done           ' end of string found - terminate the argv array                                                                    
3f78(004e): 22 18 7d 86 '               cmp       t0,#QUOTE_CHAR wz       ' found a quote?                                                            
3f7c(004f): 62 00 54 5c '         if_nz jmp       #su_argv_notquote       ' no - just copy character (or terminate argument of it is a space)
3f80(0050): 01 34 fd 6e '               xor       q,#1 wz                 ' yes - toggle marker indicating we are within quoted string
3f84(0051): 71 00 54 5c '         if_nz jmp       #su_argv_nextchar       ' if this is the start of a quoted string, just keep processing
3f88(0052): 8d 18 bd a0 '               mov       t0,t1                   ' otherwise, is the end ...
3f8c(0053): 01 18 fd 80 '               add       t0,#1                   ' ... of the quoted string ...
3f90(0054): 8c 18 bd 02 '               rdbyte    t0,t0 wz                ' ... also ... 
3f94(0055): 58 00 68 5c '         if_z  jmp       #su_argv_chkquote       ' ... the end ...
3f98(0056): 20 18 7d 86 '               cmp       t0,#" " wz              ' ... of the argument?
3f9c(0057): 71 00 54 5c '         if_nz jmp       #su_argv_nextchar       ' no - just keep processing 
3fa0(0058):             ' su_argv_chkquote
3fa0(0058): 8f 18 bd 08 '               rdlong    t0,t3                   ' yes - is there a quote ...
3fa4(0059): 8c 18 bd 00 '               rdbyte    t0,t0                   ' ... at the start ...
3fa8(005a): 22 18 7d 86 '               cmp       t0,#QUOTE_CHAR wz       ' ... of the argument?
3fac(005b): 5e 00 68 5c '         if_z  jmp       #su_argv_delquote       ' yes - delete the start and end quotes 
3fb0(005c): 01 1a fd 80 '               add       t1,#1                   ' no - do not delete the start or end quotes ...
3fb4(005d): 65 00 7c 5c '               jmp       #su_argv_nextarg        ' ... just save the argument        
3fb8(005e):             ' su_argv_delquote             
3fb8(005e): 8f 18 bd 08 '               rdlong    t0,t3                   ' remove quote ...
3fbc(005f): 01 18 fd 80 '               add       t0,#1                   ' ... from start ...     
3fc0(0060): 8f 18 3d 08 '               wrlong    t0,t3                   ' ... of string
3fc4(0061): 65 00 7c 5c '               jmp       #su_argv_nextarg        ' save next argument
3fc8(0062):             ' su_argv_notquote                                 
3fc8(0062): 20 18 7d 86 '               cmp       t0,#" " wz              ' found a space?              
3fcc(0063): 71 00 54 5c '         if_nz jmp       #su_argv_nextchar       ' no - just keep processing                                       
3fd0(0064): 71 34 7d e8 '               tjnz      q,#su_argv_nextchar     ' yes - are we within a quote? If yes, just keep processing
3fd4(0065):             ' su_argv_nextarg              
3fd4(0065): 01 32 fd 80 '               add       n,#1                    ' no - found the end of an argument                                       
3fd8(0066): 20 32 7d 87 '               cmp       n,#ARGV_MAX wz,wc       ' too many arguments?                                      
3fdc(0067): 73 00 4c 5c '         if_ae jmp       #su_argv_done           ' yes - just terminate argv array                                       
3fe0(0068): 00 18 fd a0 '               mov       t0,#0                   ' no - zero terminate ...
3fe4(0069): 8d 18 3d 00 '               wrbyte    t0,t1                   ' ... the current argument                                          
3fe8(006a): 01 1a fd 80 '               add       t1,#1                   ' find the start ...    
3fec(006b): 7c 00 fd 5c '               call      #skip_to_non_space      ' ... of the next argument
3ff0(006c): 8d 18 bd 02 '               rdbyte    t0,t1 wz                ' end of string?
3ff4(006d): 73 00 68 5c '         if_z  jmp       #su_argv_done           ' yes - terminate qrgv array
3ff8(006e): 04 1e fd 80 '               add       t3,#4                   ' no - save new pointer ...          
3ffc(006f): 8f 1a 3d 08 '               wrlong    t1,t3                   ' ... in the argv array          
4000(0070): 4c 00 7c 5c '               jmp       #su_argv_loop           ' ... and keep processing
4004(0071):             ' su_argv_nextchar        
4004(0071): 01 1a fd 80 '               add       t1,#1                   '  process ...              
4008(0072): 4c 00 7c 5c '               jmp       #su_argv_loop           '  ... the next character          
400c(0073):             ' su_argv_done                                                        
400c(0073): 04 1e fd 80 '               add       t3,#4                   '   ' terminate argv array with a null entry   
4010(0074): 00 18 fd a0 '               mov       t0,#0                   '   long[b] := 0                               
4014(0075): 8f 18 3d 08 '               wrlong    t0,t3                   '                                              
4018(0076): 00 00 7c 5c '               jmp       #done                   '   
401c(0077):             ' no_args                                         ' 
401c(0077): 00 18 fd a0 '               mov       t0,#0                   ' if no stored string ...   
4020(0078): 94 18 3d 04 '               wrword    t0,argc                 ' ... set argc ...                    
4024(0079): 96 18 3d 08 '               wrlong    t0,argv_start           ' ... and argv_0 to zero                 
4028(007a): 95 2c 3d 04 '               wrword    argv_start,argv         ' set argv to argv_0          
402c(007b): 00 00 7c 5c '               jmp       #done                   
4030(007c):             ' skip_to_non_space
4030(007c): 8d 18 bd 00 '               rdbyte    t0,t1
4034(007d): 20 18 7d 86 '               cmp       t0,#" " wz
4038(007e): 01 1a e9 80 '         if_z  add       t1,#1     
403c(007f): 7c 00 68 5c '         if_z  jmp       #skip_to_non_space          
4040(0080):             ' skip_to_non_space_ret
4040(0080): 00 00 7c 5c '               ret
4044(0081):             ' skip_to_space
4044(0081): 8d 18 bd 02 '               rdbyte    t0,t1 wz
4048(0082): 8b 00 68 5c '         if_z  jmp       #skip_to_space_ret
404c(0083): 22 18 7d 86 '               cmp       t0,#QUOTE_CHAR wz
4050(0084): 01 34 e9 6c '         if_z  xor       q,#1
4054(0085): 89 00 68 5c '         if_z  jmp       #:skip_char
4058(0086): 20 18 7d 86 '               cmp       t0,#" " wz
405c(0087): 89 00 54 5c '         if_nz jmp       #:skip_char
4060(0088): 8b 34 7d ec '               tjz       q,#skip_to_space_ret
4064(0089):             ' :skip_char              
4064(0089): 01 1a fd 80 '               add       t1,#1
4068(008a): 81 00 7c 5c '               jmp       #skip_to_space          
406c(008b):             ' skip_to_space_ret
406c(008b): 00 00 7c 5c '               ret
4070(008c): 00 00 00 00 ' t0            long      0
4074(008d): 00 00 00 00 ' t1            long      0
4078(008e): 00 00 00 00 ' t2            long      0
407c(008f): 00 00 00 00 ' t3            long      0
4080(0090): ff ff ff 00 ' low24         long      $FFFFFF
4084(0091): fc 7e 00 00 ' command       long      COGSTORE   
4088(0092): 00 00 00 30 ' size_cmd      long      CMD_SIZE
408c(0093): ce fa ed fe ' response      long      CMD_RESPONSE
4090(0094): 30 7f 00 00 ' argc          long      ARGC_ADDR
4094(0095): 32 7f 00 00 ' argv          long      ARGV_ADDR
4098(0096): 34 7f 00 00 ' argv_start    long      ARGV_0
409c(0097): 00 02 00 00 ' d_inc         long      1<<9
40a0(0098): 00 00 00 00 ' len           long      0                       ' storage used (longs)
40a4(0099): 00 00 00 00 ' n             long      0
40a8(009a): 00 00 00 00 ' q             long      0
40ac(009b): 00 00 00 00 ' storage       long      0                       ' long storage starts here      
'=========================== Method #1: PUB Start =============================
'PUB Start
'------------------------------------------------------------------------------
  coginit(7, @entry, 0)
'------------------------------------------------------------------------------
40b0: 37 22          PUSH#kp	7 ($7)
40b2: c7 24          PUSH#.L	OBJ+36
40b4: 35             PUSH#0	
40b5: 2c             COGISUB	
40b6: 32             RETURN	
'=========================== Method #2: PUB Valid =============================
'PUB Valid : ok
'------------------------------------------------------------------------------
  long[COGSTORE] := -1 ' any invalid command
'------------------------------------------------------------------------------
40b7: 34             PUSH#-1	
40b8: 39 7e fc       PUSH#k2	32508
40bb: c1             POP.L	Mem[]
'------------------------------------------------------------------------------
  repeat 100
'------------------------------------------------------------------------------
40bc: 38 64          PUSH#k1	100
40be: 08 10          LOOPJPF	.+16 (dest:$40d0)
'------------------------------------------------------------------------------
    if long[COGSTORE] == CMD_RESPONSE
'------------------------------------------------------------------------------
40c0: 39 7e fc       PUSH#k2	32508
40c3: c0             PUSH.L	Mem[]
40c4: 3b fe ed fa ce PUSH#k4	-17958194
40c9: fc             EQ   	
40ca: 0a 02          JPF  	.+2 (dest:$40ce)
'------------------------------------------------------------------------------
      return -1
'------------------------------------------------------------------------------
40cc: 34             PUSH#-1	
40cd: 33             RETVAL	
40ce: 09 70          LOOPRPT	.-16 (dest:$40c0)
'------------------------------------------------------------------------------
  return 0
'------------------------------------------------------------------------------
40d0: 35             PUSH#0	
40d1: 33             RETVAL	
40d2: 32             RETURN	
'============================ Method #3: PUB Stop =============================
'PUB Stop
'------------------------------------------------------------------------------
  if Valid
'------------------------------------------------------------------------------
40d3: 00             FRAME	Call with return value	
40d4: 05 02          CALL 	+2 
40d6: 0a 03          JPF  	.+3 (dest:$40db)
'------------------------------------------------------------------------------
    cogstop(7)
'------------------------------------------------------------------------------
40d8: 37 22          PUSH#kp	7 ($7)
40da: 21             COGSTOP	
40db: 32             RETURN	
'=========================== Method #4: PUB Write =============================
'PUB Write(Addr) : ok
'------------------------------------------------------------------------------
  if Valid
'------------------------------------------------------------------------------
40dc: 00             FRAME	Call with return value	
40dd: 05 02          CALL 	+2 
40df: 0a 1e          JPF  	.+30 (dest:$40ff)
'------------------------------------------------------------------------------
    long[COGSTORE] := CMD_WRITE | Addr
'------------------------------------------------------------------------------
40e1: 37 1c          PUSH#kp	536870912 ($20000000)
40e3: 64             PUSH 	Locals+4
40e4: ea             BIT_OR	
40e5: 39 7e fc       PUSH#k2	32508
40e8: c1             POP.L	Mem[]
'------------------------------------------------------------------------------
    repeat 100000
'------------------------------------------------------------------------------
40e9: 3a 01 86 a0    PUSH#k3	100000
40ed: 08 0c          LOOPJPF	.+12 (dest:$40fb)
'------------------------------------------------------------------------------
      if long[COGSTORE] == 0
'------------------------------------------------------------------------------
40ef: 39 7e fc       PUSH#k2	32508
40f2: c0             PUSH.L	Mem[]
40f3: 35             PUSH#0	
40f4: fc             EQ   	
40f5: 0a 02          JPF  	.+2 (dest:$40f9)
'------------------------------------------------------------------------------
        return -1
'------------------------------------------------------------------------------
40f7: 34             PUSH#-1	
40f8: 33             RETVAL	
40f9: 09 74          LOOPRPT	.-12 (dest:$40ef)
'------------------------------------------------------------------------------
    return 0
'------------------------------------------------------------------------------
40fb: 35             PUSH#0	
40fc: 33             RETVAL	
'------------------------------------------------------------------------------
  else
'------------------------------------------------------------------------------
40fd: 04 02          GOTO 	.+2 (dest:$4101)
'------------------------------------------------------------------------------
    return 0
'------------------------------------------------------------------------------
40ff: 35             PUSH#0	
4100: 33             RETVAL	
4101: 32             RETURN	
'============================ Method #5: PUB Read =============================
'PUB Read(Addr) : ok
'------------------------------------------------------------------------------
  if Valid
'------------------------------------------------------------------------------
4102: 00             FRAME	Call with return value	
4103: 05 02          CALL 	+2 
4105: 0a 1e          JPF  	.+30 (dest:$4125)
'------------------------------------------------------------------------------
    long[COGSTORE] := CMD_READ | Addr
'------------------------------------------------------------------------------
4107: 37 1b          PUSH#kp	268435456 ($10000000)
4109: 64             PUSH 	Locals+4
410a: ea             BIT_OR	
410b: 39 7e fc       PUSH#k2	32508
410e: c1             POP.L	Mem[]
'------------------------------------------------------------------------------
    repeat 100000
'------------------------------------------------------------------------------
410f: 3a 01 86 a0    PUSH#k3	100000
4113: 08 0c          LOOPJPF	.+12 (dest:$4121)
'------------------------------------------------------------------------------
      if long[COGSTORE] == 0
'------------------------------------------------------------------------------
4115: 39 7e fc       PUSH#k2	32508
4118: c0             PUSH.L	Mem[]
4119: 35             PUSH#0	
411a: fc             EQ   	
411b: 0a 02          JPF  	.+2 (dest:$411f)
'------------------------------------------------------------------------------
        return -1
'------------------------------------------------------------------------------
411d: 34             PUSH#-1	
411e: 33             RETVAL	
411f: 09 74          LOOPRPT	.-12 (dest:$4115)
'------------------------------------------------------------------------------
    return 0
'------------------------------------------------------------------------------
4121: 35             PUSH#0	
4122: 33             RETVAL	
'------------------------------------------------------------------------------
  else
'------------------------------------------------------------------------------
4123: 04 02          GOTO 	.+2 (dest:$4127)
'------------------------------------------------------------------------------
    return 0
'------------------------------------------------------------------------------
4125: 35             PUSH#0	
4126: 33             RETVAL	
4127: 32             RETURN	
'============================ Method #6: PUB Size =============================
'PUB Size | s
'------------------------------------------------------------------------------
  if not Valid
'------------------------------------------------------------------------------
4128: 00             FRAME	Call with return value	
4129: 05 02          CALL 	+2 
412b: ff             LOG_NOT	
412c: 0a 02          JPF  	.+2 (dest:$4130)
'------------------------------------------------------------------------------
    return -1
'------------------------------------------------------------------------------
412e: 34             PUSH#-1	
412f: 33             RETVAL	
'------------------------------------------------------------------------------
  long[COGSTORE] := CMD_SIZE | $FFFFFF 
'------------------------------------------------------------------------------
4130: 3b 30 00 00 00 PUSH#k4	805306368
4135: 37 37          PUSH#kp	16777215 ($ffffff)
4137: ea             BIT_OR	
4138: 39 7e fc       PUSH#k2	32508
413b: c1             POP.L	Mem[]
'------------------------------------------------------------------------------
  repeat 100
'------------------------------------------------------------------------------
413c: 38 64          PUSH#k1	100
413e: 08 19          LOOPJPF	.+25 (dest:$4159)
'------------------------------------------------------------------------------
    if long[COGSTORE] <> CMD_SIZE | $FFFFFF
'------------------------------------------------------------------------------
4140: 39 7e fc       PUSH#k2	32508
4143: c0             PUSH.L	Mem[]
4144: 3b 30 00 00 00 PUSH#k4	805306368
4149: 37 37          PUSH#kp	16777215 ($ffffff)
414b: ea             BIT_OR	
414c: fb             NE   	
414d: 0a 08          JPF  	.+8 (dest:$4157)
'------------------------------------------------------------------------------
      return long[COGSTORE] & $FFFFFF
'------------------------------------------------------------------------------
414f: 39 7e fc       PUSH#k2	32508
4152: c0             PUSH.L	Mem[]
4153: 37 37          PUSH#kp	16777215 ($ffffff)
4155: e8             BIT_AND	
4156: 33             RETVAL	
4157: 09 67          LOOPRPT	.-25 (dest:$4140)
'------------------------------------------------------------------------------
  return -2
'------------------------------------------------------------------------------
4159: 37 60          PUSH#kp	-2 ($fffffffe)
415b: 33             RETVAL	
415c: 32             RETURN	
'=========================== Method #7: PUB Setup =============================
'PUB Setup(addr) : i
'------------------------------------------------------------------------------
  word[ARGC_ADDR] := 0
'------------------------------------------------------------------------------
415d: 35             PUSH#0	
415e: 39 7f 30       PUSH#k2	32560
4161: a1             POP.W	Mem[]
'------------------------------------------------------------------------------
  word[ARGV_ADDR] := 0
'------------------------------------------------------------------------------
4162: 35             PUSH#0	
4163: 39 7f 32       PUSH#k2	32562
4166: a1             POP.W	Mem[]
'------------------------------------------------------------------------------
  repeat i from 0 to ARGV_MAX-1
'------------------------------------------------------------------------------
4167: 35             PUSH#0	
4168: 61             POP  	Locals+0
'------------------------------------------------------------------------------
    long[ARGV_0][i] := 0
'------------------------------------------------------------------------------
4169: 35             PUSH#0	
416a: 39 7f 34       PUSH#k2	32564
416d: 60             PUSH 	Locals+0
416e: d1             POP.L	Mem[][]
416f: 35             PUSH#0	
4170: 37 04          PUSH#kp	32 ($20)
4172: 36             PUSH#1	
4173: ed             SUB  	
4174: 62 02 72       USING	Locals+0, RPTINCJ .-14 (dest:$4169)
'------------------------------------------------------------------------------
  if not Valid
'------------------------------------------------------------------------------
4177: 00             FRAME	Call with return value	
4178: 05 02          CALL 	+2 
417a: ff             LOG_NOT	
417b: 0a 2c          JPF  	.+44 (dest:$41a9)
'------------------------------------------------------------------------------
    word[ARGC_ADDR] := 1
'------------------------------------------------------------------------------
417d: 36             PUSH#1	
417e: 39 7f 30       PUSH#k2	32560
4181: a1             POP.W	Mem[]
'------------------------------------------------------------------------------
    word[ARGV_ADDR] := ARGV_0
'------------------------------------------------------------------------------
4182: 39 7f 34       PUSH#k2	32564
4185: 39 7f 32       PUSH#k2	32562
4188: a1             POP.W	Mem[]
'------------------------------------------------------------------------------
    long[ARGV_0] := ARGV_0 + 4*(ARGV_MAX-2)
'------------------------------------------------------------------------------
4189: 39 7f 34       PUSH#k2	32564
418c: 37 01          PUSH#kp	4 ($4)
418e: 37 04          PUSH#kp	32 ($20)
4190: 37 00          PUSH#kp	2 ($2)
4192: ed             SUB  	
4193: f4             MPY  	
4194: ec             ADD  	
4195: 39 7f 34       PUSH#k2	32564
4198: c1             POP.L	Mem[]
'------------------------------------------------------------------------------
    long[ARGV_0][ARGV_MAX-2] := $6C6C756E ' null
'------------------------------------------------------------------------------
4199: 3b 6c 6c 75 6e PUSH#k4	1819047278
419e: 39 7f 34       PUSH#k2	32564
41a1: 37 04          PUSH#kp	32 ($20)
41a3: 37 00          PUSH#kp	2 ($2)
41a5: ed             SUB  	
41a6: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  else
'------------------------------------------------------------------------------
41a7: 04 1c          GOTO 	.+28 (dest:$41c5)
'------------------------------------------------------------------------------
    long[COGSTORE] := CMD_SETUP | Addr
'------------------------------------------------------------------------------
41a9: 37 1d          PUSH#kp	1073741824 ($40000000)
41ab: 64             PUSH 	Locals+4
41ac: ea             BIT_OR	
41ad: 39 7e fc       PUSH#k2	32508
41b0: c1             POP.L	Mem[]
'------------------------------------------------------------------------------
    repeat 100000
'------------------------------------------------------------------------------
41b1: 3a 01 86 a0    PUSH#k3	100000
41b5: 08 0c          LOOPJPF	.+12 (dest:$41c3)
'------------------------------------------------------------------------------
      if long[COGSTORE] == 0
'------------------------------------------------------------------------------
41b7: 39 7e fc       PUSH#k2	32508
41ba: c0             PUSH.L	Mem[]
41bb: 35             PUSH#0	
41bc: fc             EQ   	
41bd: 0a 02          JPF  	.+2 (dest:$41c1)
'------------------------------------------------------------------------------
        return -1
'------------------------------------------------------------------------------
41bf: 34             PUSH#-1	
41c0: 33             RETVAL	
41c1: 09 74          LOOPRPT	.-12 (dest:$41b7)
'------------------------------------------------------------------------------
    return 0
'------------------------------------------------------------------------------
41c3: 35             PUSH#0	
41c4: 33             RETVAL	
41c5: 32             RETURN	
41c6: 00 00       

'******************************************************************************
'                              Catalina_LMM.spin                               
'******************************************************************************

'=================================== CONs =====================================
SignFlag = 1
ZeroFlag = 2
NaNFlag = 8
'=============================== Object Header ================================
41c8: a8 07 03 00 ' 1960 bytes, 3-1 methods, 0 object pointers
41cc: 88 07 00 00 ' ptr #1 to $4950: PUB Entry_Addr (locals size: 0)
41d0: 8c 07 00 00 ' ptr #2 to $4954: PUB Run (locals size: 0)
'================================ DAT Section =================================
41d4(0000):             '  org 0
41d4(0000):             ' entry
41d4(0000): 02 00 7c 5c '    jmp #INIT            '$00
41d8(0001): 02 00 7c 5c '    jmp #INIT            '$01 remove this line when using POD, since it
41dc(0002): 53 00 7c 5c ' INIT    jmp #lmm_init   '$02
41e0(0003): 81 00 7c 5c ' LODL    jmp #load_l     '$03
41e4(0004): 83 00 7c 5c ' LODA    jmp #load_a     '$04
41e8(0005): 85 00 7c 5c ' LODF    jmp #fp_ind     '$05
41ec(0006): 88 00 7c 5c ' PSHL    jmp #push_l     '$06
41f0(0007): a9 00 7c 5c ' PSHB    jmp #push_b     '$07
41f4(0008): b1 00 7c 5c ' CPYB    jmp #copy_b     '$08
41f8(0009): be 00 7c 5c ' NEWF    jmp #new_fp     '$09
41fc(000a): c4 00 7c 5c ' RETF    jmp #fp_ret     '$0a
4200(000b): c9 00 7c 5c ' CALA    jmp #f_call     '$0b
4204(000c): c6 00 7c 5c ' RETN    jmp #f_ret      '$0c
4208(000d): cb 00 7c 5c ' CALI    jmp #f_cali     '$0d
420c(000e): ce 00 7c 5c ' JMPA    jmp #f_jump     '$0e
4210(000f): d0 00 7c 5c ' JMPI    jmp #f_jmpi     '$0f
4214(0010): de 00 7c 5c ' DIVS    jmp #f_d32s     '$10
4218(0011): f0 00 7c 5c ' DIVU    jmp #f_d32u     '$11
421c(0012): fc 00 7c 5c ' MULT    jmp #f_m32      '$12
4220(0013): 06 01 7c 5c ' BR_Z    jmp #bra_z      '$13
4224(0014): 08 01 7c 5c ' BRNZ    jmp #bra_nz     '$14
4228(0015): 0a 01 7c 5c ' BRAE    jmp #bra_ae     '$15
422c(0016): 0c 01 7c 5c ' BR_A    jmp #bra_a      '$16
4230(0017): 0e 01 7c 5c ' BRBE    jmp #bra_be     '$17
4234(0018): 10 01 7c 5c ' BR_B    jmp #bra_b      '$18
4238(0019): 12 01 7c 5c ' SYSP    jmp #plugin     '$19
423c(001a): 8b 00 7c 5c ' PSHA    jmp #push_a     '$1a
4240(001b): 32 01 7c 5c ' FADD    jmp #flt_add    '$1b
4244(001c): 31 01 7c 5c ' FSUB    jmp #flt_sub    '$1c
4248(001d): 47 01 7c 5c ' FMUL    jmp #flt_mul    '$1d
424c(001e): 56 01 7c 5c ' FDIV    jmp #flt_div    '$1e
4250(001f): 82 01 7c 5c ' FCMP    jmp #flt_cmp    '$1f
4254(0020): 66 01 7c 5c ' FLIN    jmp #flt_int    '$20
4258(0021): 73 01 7c 5c ' INFL    jmp #int_flt    '$21
425c(0022): 93 00 7c 5c ' PSHM    jmp #push_m     '$22
4260(0023): 9e 00 7c 5c ' POPM    jmp #pop_m      '$23
4264(0024): 8d 00 7c 5c ' PSHF    jmp #push_i     '$24
4268(0025): d2 00 7c 5c ' RLNG    jmp #rd_long    '$25
426c(0026): d4 00 7c 5c ' RWRD    jmp #rd_word    '$26
4270(0027): d6 00 7c 5c ' RBYT    jmp #rd_byte    '$27
4274(0028): d8 00 7c 5c ' WLNG    jmp #wr_long    '$28
4278(0029): da 00 7c 5c ' WWRD    jmp #wr_word    '$29
427c(002a): dc 00 7c 5c ' WBYT    jmp #wr_byte    '$2a
4280(002b): 00 00 00 00 ' PC      long 0          '$2b
4284(002c): 00 00 00 00 ' SP      long 0          '$2c
4288(002d): 00 00 00 00 ' FP      long 0          '$2d
428c(002e): 00 00 00 00 ' RI      long 0          '$2e
4290(002f): 00 00 00 00 ' BC      long 0          '$2f
4294(0030): 00 00 00 00 ' BA      long 0          '$30
4298(0031): 00 00 00 00 ' BZ      long 0          '$31
429c(0032): 00 00 00 00 ' CS      long 0          '$32
42a0(0033): 00 00 00 00 ' r0      long 0          '$33
42a4(0034): 00 00 00 00 ' r1      long 0          '$34
42a8(0035): 00 00 00 00 ' r2      long 0          '$35
42ac(0036): 00 00 00 00 ' r3      long 0          '$36
42b0(0037): 00 00 00 00 ' r4      long 0          '$37
42b4(0038): 00 00 00 00 ' r5      long 0          '$38
42b8(0039): 00 00 00 00 ' r6      long 0          '$39
42bc(003a): 00 00 00 00 ' r7      long 0          '$3a
42c0(003b): 00 00 00 00 ' r8      long 0          '$3b
42c4(003c): 00 00 00 00 ' r9      long 0          '$3c
42c8(003d): 00 00 00 00 ' r10     long 0          '$3d
42cc(003e): 00 00 00 00 ' r11     long 0          '$3e
42d0(003f): 00 00 00 00 ' r12     long 0          '$3f
42d4(0040): 00 00 00 00 ' r13     long 0          '$40
42d8(0041): 00 00 00 00 ' r14     long 0          '$41
42dc(0042): 00 00 00 00 ' r15     long 0          '$42
42e0(0043): 00 00 00 00 ' r16     long 0          '$43
42e4(0044): 00 00 00 00 ' r17     long 0          '$44
42e8(0045): 00 00 00 00 ' r18     long 0          '$45
42ec(0046): 00 00 00 00 ' r19     long 0          '$46
42f0(0047): 00 00 00 00 ' r20     long 0          '$47
42f4(0048): 00 00 00 00 ' r21     long 0          '$48
42f8(0049): 00 00 00 00 ' r22     long 0          '$49
42fc(004a): 00 00 00 00 ' r23     long 0          '$4a
4300(004b): 00 00 00 80 ' Bit31   long  $80000000 '$4b
4304(004c): ff ff ff ff ' all_1s  long  $ffffffff '$4c
4308(004d): ff 00 00 00 ' cviu_m1 long  $000000ff '$4d
430c(004e): ff ff 00 00 ' cviu_m2 long  $0000ffff '$4e
4310(004f): 00 00 00 ff ' top8    long  $ff000000 '$4f   ' top 8 bits bitmask
4314(0050): ff ff ff 00 ' low24   long  $00ffffff '$50   ' low 24 bits bitmask
4318(0051): 00 00 00 00 ' init_BZ long  $00000000 '$51   ' end of code / start of heap
431c(0052): 00 00 00 00 ' init_PC long  $00000000 '$52   ' the initial PC
4320(0053):             ' lmm_init
4320(0053): 01 66 fc 0c '         cogid   r0              '1 convert ...
4324(0054): 02 66 fc 2c '         shl     r0,#2           '2 ... my cog id ...
4328(0055): f0 67 bc 80 '         add     r0,par          '3 ... to my registration addr
432c(0056): 33 66 bc 08 '         rdlong  r0,r0           '4 get my request block addr
4330(0057):             ' wait
4330(0057): 33 60 bc 0a '         rdlong  BA,r0 wz        '5 Wait till we are given the base address ...
4334(0058): 57 00 68 5c '   if_z  jmp     #wait           '6 .. (required to relocate segments)
4338(0059): 04 66 fc 80 '         add     r0,#4           '7 Load our initial SP ...
433c(005a): 33 58 bc 08 '         rdlong  SP,r0           '8 ... from the request block
4340(005b): 4c 63 fc a0 '         mov     BZ,#init_BZ<<2+8 '9 calculate ...
4344(005c): 30 62 bc 80 '         add     BZ,BA           '10 ... pointer to initial BZ
4348(005d): 31 56 bc a0 '         mov     PC,BZ           '11 load ...
434c(005e): 04 56 fc 80 '         add     PC,#4           '12 ... initial  ...
4350(005f): 2b 56 bc 08 '         rdlong  PC,PC           '13 ... PC and ...
4354(0060): 31 62 bc 08 '         rdlong  BZ,BZ           '14 ... BZ and ...
4358(0061): 72 00 fd 5c '         call    #Reloc          '15 ... relocate segments 
435c(0062): 65 00 7c 5c '         jmp     #LMM_loop       '16 we can now start executing LMM code
4360(0063): 00 00 00 00 '         nop                     '17
4364(0064):             ' LMM_next
4364(0064): 04 56 fc 80 '         add    PC,#4
4368(0065):             ' LMM_loop
4368(0065): 2b ce bc 08 '         rdlong LMM_1,PC
436c(0066): 04 56 fc 80 '         add    PC,#4
4370(0067):             ' LMM_1
4370(0067): 00 00 00 00 '         nop
4374(0068): 2b d4 bc 08 '         rdlong LMM_2,PC
4378(0069): 04 56 fc 80 '         add    PC,#4
437c(006a):             ' LMM_2
437c(006a): 00 00 00 00 '         nop
4380(006b): 2b da bc 08 '         rdlong LMM_3,PC
4384(006c): 04 56 fc 80 '         add    PC,#4
4388(006d):             ' LMM_3
4388(006d): 00 00 00 00 '         nop
438c(006e): 2b e0 bc 08 '         rdlong LMM_4,PC
4390(006f): 04 56 fc 80 '         add    PC,#4
4394(0070):             ' LMM_4
4394(0070): 00 00 00 00 '         nop
4398(0071): 65 00 7c 5c '         jmp    #LMM_loop
439c(0072):             ' Reloc
439c(0072): 31 5e bc a0 '         mov   BC,BZ         ' length of data to be relocated
43a0(0073): 03 5e fc 80 '         add   BC,#3         ' round up ...
43a4(0074): 03 5e fc 64 '         andn  BC,#3         ' ... to a multiple of 4 bytes
43a8(0075): 10 5e fc 84 '         sub   BC,#$10       ' omit first 16 bytes
43ac(0076): 10 b6 ff a0 '         mov   t2,#$10       ' destination is byte 16
43b0(0077): 30 b4 bf a0 '         mov   t1,BA         ' source is BA ...
43b4(0078): 10 b4 ff 80 '         add   t1,#$10       ' ... plus 16 bytes 
43b8(0079):             ' reloc_loop
43b8(0079): 80 5e 7c ec '        tjz    BC,#Reloc_ret ' no more to copy
43bc(007a): da b9 bf 08 '        rdlong t3,t1         ' read from src to t3
43c0(007b): db b9 3f 08 '        wrlong t3,t2         ' write t3 to dst
43c4(007c): 04 b4 ff 80 '        add    t1,#4         ' increment source
43c8(007d): 04 b6 ff 80 '        add    t2,#4         ' increment destination
43cc(007e): 04 5e fc 84 '        sub    BC,#4         ' decrement count ...
43d0(007f): 79 00 7c 5c '        jmp    #reloc_loop   ' ... and keep copying
43d4(0080):             ' Reloc_ret
43d4(0080): 00 00 7c 5c '        ret        
43d8(0081):             ' load_l
43d8(0081): 2b 5c bc 08 '        rdlong RI,PC         ' load the long value
43dc(0082): 64 00 7c 5c '        jmp    #LMM_next     ' increment PC, execute next instruction
43e0(0083):             ' load_a
43e0(0083): 2b 5c bc 08 '        rdlong RI,PC         ' load the address
43e4(0084): 64 00 7c 5c '        jmp    #LMM_next     ' increment PC, execute next instruction
43e8(0085):             ' fp_ind
43e8(0085): 2b 5c bc 08 '        rdlong RI,PC         ' load the long value
43ec(0086): 2d 5c bc d0 '        adds   RI,FP         ' add the frame pointer
43f0(0087): 64 00 7c 5c '        jmp    #LMM_next     ' increment PC, execute next instruction
43f4(0088):             ' push_l
43f4(0088): 04 58 fc 84 '        sub    SP,#4         ' decrement SP
43f8(0089): 2c 5c 3c 08 '        wrlong RI,SP         ' save value on stack
43fc(008a): 65 00 7c 5c '        jmp    #LMM_loop     ' increment PC, execute next instruction
4400(008b):             ' push_a
4400(008b): 2b 5c bc 08 '        rdlong RI,PC         ' load the address
4404(008c): 8f 00 7c 5c '        jmp    #push_x       ' use the result as an address of the value to push
4408(008d):             ' push_i
4408(008d): 2b 5c bc 08 '        rdlong RI,PC         ' load the long value
440c(008e): 2d 5c bc d0 '        adds   RI,FP         ' add the frame pointer
4410(008f):             ' push_x
4410(008f): 2e 5c bc 08 '        rdlong RI,RI         ' read the value at that address
4414(0090): 04 58 fc 84 '        sub    SP,#4         ' decrement SP
4418(0091): 2c 5c 3c 08 '        wrlong RI,SP         ' save value on stack
441c(0092): 64 00 7c 5c '        jmp    #LMM_next     ' increment PC, execute next instruction
4420(0093):             ' push_m
4420(0093): 2b 5c bc 08 '        rdlong RI,PC         ' load the long value specifying the registers to push
4424(0094): 39 32 fd 54 '        movd   :push_x,#r6   ' start with ...
4428(0095): 06 5c fc 28 '        shr    RI,#6         ' ... r6
442c(0096): 12 b4 ff a0 '        mov    t1,#18        ' we will push up to 18 registers (up to R24)
4430(0097):             ' :push_nxt
4430(0097): 01 5c fc 2b '        shr    RI,#1 wc,wz   ' save rx?
4434(0098): 04 58 f0 84 '  if_c  sub    SP,#4         ' if so ...
4438(0099):             ' :push_x                     ' ... save ...
4438(0099): 2c 00 30 08 '  if_c  wrlong 0,SP          ' ... the register
443c(009a): 64 00 68 5c '  if_z  jmp    #LMM_next     ' no more to save
4440(009b): d9 33 bd 80 '        add    :push_x,dlsb  ' point to next register
4444(009c): 97 b4 ff e4 '        djnz   t1,#:push_nxt ' continue till all 24 registers checked
4448(009d): 64 00 7c 5c '        jmp    #LMM_next     ' increment PC, execute next instruction
444c(009e):             ' pop_m
444c(009e): 2b 5c bc 08 '        rdlong RI,PC         ' load the long value specifying the registers to push
4450(009f): 4a 46 fd 54 '        movd   :pop_x,#r23   ' start with ...
4454(00a0): 08 5c fc 2c '        shl    RI,#(32-24)   ' ... r23         
4458(00a1): 12 b4 ff a0 '        mov    t1,#18        ' we will pop up to 18 registers (down to r6)
445c(00a2):             ' :pop_nxt
445c(00a2): 01 5c fc 2f '        shl    RI,#1 wc,wz   ' load rx?
4460(00a3):             ' :pop_x                      ' if so ...
4460(00a3): 2c 00 b0 08 '  if_c  rdlong 0,SP          ' ... load ...
4464(00a4): 04 58 f0 80 '  if_c  add    SP,#4         ' ... the register
4468(00a5): 64 00 68 5c '  if_z  jmp    #LMM_next
446c(00a6): d9 47 bd 84 '        sub    :pop_x,dlsb   ' point to previous register
4470(00a7): a2 b4 ff e4 '        djnz   t1,#:pop_nxt  ' continue till all 24 registers checked
4474(00a8): 64 00 7c 5c '        jmp    #LMM_next     ' increment PC, execute next instruction
4478(00a9):             ' push_b
4478(00a9): 2b 5e bc 08 '        rdlong BC,PC         ' load the byte count
447c(00aa): 04 56 fc 80 '        add    PC,#4         ' increment the PC
4480(00ab): 03 5e fc 80 '        add    BC,#3         ' round up BC ...
4484(00ac): 03 5e fc 64 '        andn   BC,#3         ' ... to be a multiple of 4
4488(00ad): 2f 58 bc 84 '        sub    SP,BC         ' decrement SP by rounded up size
448c(00ae): 33 b4 bf a0 '        mov    t1,R0         ' source is in R0
4490(00af): 2c b6 bf a0 '        mov    t2,SP         ' destination is SP
4494(00b0): b7 00 7c 5c '        jmp    #copy_longs   ' do the copy
4498(00b1):             ' copy_b
4498(00b1): 2b 5e bc 08 '        rdlong BC,PC         ' load the byte count
449c(00b2): 04 56 fc 80 '        add    PC,#4         ' increment the PC
44a0(00b3): 03 5e fc 80 '        add    BC,#3         ' round up BC ...
44a4(00b4): 03 5e fc 64 '        andn   BC,#3         ' ... to be a multiple of 4
44a8(00b5): 34 b4 bf a0 '        mov    t1,R1         ' source is in R1
44ac(00b6): 33 b6 bf a0 '        mov    t2,R0         ' destination is in R0
44b0(00b7):             ' copy_longs
44b0(00b7): 65 5e 7c ec '        tjz    BC,#LMM_Loop  ' no more to copy
44b4(00b8): da b9 bf 08 '        rdlong t3,t1         ' read from src to t3
44b8(00b9): db b9 3f 08 '        wrlong t3,t2         ' write t3 to dst
44bc(00ba): 04 b4 ff 80 '        add    t1,#4         ' increment source
44c0(00bb): 04 b6 ff 80 '        add    t2,#4         ' increment destination
44c4(00bc): 04 5e fc 84 '        sub    BC,#4         ' decrement count ...
44c8(00bd): b7 00 7c 5c '        jmp    #copy_longs   ' ... and keep copying
44cc(00be):             ' new_fp
44cc(00be): 04 58 fc 84 '        sub     SP,#4         ' decrement the stack pointer
44d0(00bf): 2c 5a 3c 08 '        wrlong FP,SP         ' save FP to stack
44d4(00c0): 2c 5a bc a0 '        mov    FP,SP         ' set up new FP
44d8(00c1): 08 5e fc 80 '        add    BC,#8         ' calculate what SP was ...
44dc(00c2): 2d 5e bc 80 '        add    BC,FP         ' ... before arguments were pushed
44e0(00c3): 65 00 7c 5c '        jmp    #LMM_loop     ' execute the next instruction
44e4(00c4):             ' fp_ret
44e4(00c4): 2c 5a bc 08 '        rdlong FP,SP         ' restore previous FP
44e8(00c5): 04 58 fc 80 '        add    SP,#4         ' increment the SP
44ec(00c6):             ' f_ret
44ec(00c6): 2c 56 bc 08 '        rdlong PC,SP         ' read the PC
44f0(00c7): 04 58 fc 80 '        add    SP,#4         ' increment the SP
44f4(00c8): 65 00 7c 5c '        jmp    #LMM_loop     ' execute the next instruction
44f8(00c9):             ' f_call                    
44f8(00c9): 2b 5c bc 08 '        rdlong RI,PC         ' get the address to call
44fc(00ca): 04 56 fc 80 '        add    PC,#4         ' increment the PC (this is the return address)
4500(00cb):             ' f_cali
4500(00cb): 04 58 fc 84 '        sub    SP,#4         ' decrement the SP
4504(00cc): 2c 56 3c 08 '        wrlong PC,SP         ' save current PC to stack
4508(00cd): d0 00 7c 5c '        jmp    #f_jmpi       ' jump to location in RI
450c(00ce):             ' f_jump
450c(00ce): 2b 56 bc 08 '        rdlong PC,PC         ' get the address to jump to
4510(00cf): 65 00 7c 5c '        jmp    #LMM_loop     ' execute next instruction
4514(00d0):             ' f_jmpi
4514(00d0): 2e 56 bc a0 '        mov    PC,RI         ' get the address to jump to
4518(00d1): 65 00 7c 5c '        jmp    #LMM_loop     ' execute next instruction
451c(00d2):             ' rd_long
451c(00d2): 2e 5e bc 08 '         rdlong  BC,RI
4520(00d3): 64 00 7c 5c '         jmp     #LMM_Next
4524(00d4):             ' rd_word
4524(00d4): 2e 5e bc 04 '         rdword  BC,RI
4528(00d5): 64 00 7c 5c '         jmp     #LMM_Next
452c(00d6):             ' rd_byte
452c(00d6): 2e 5e bc 00 '         rdbyte  BC,RI
4530(00d7): 64 00 7c 5c '         jmp     #LMM_Next
4534(00d8):             ' wr_long
4534(00d8): 2e 5e 3c 08 '         wrlong  BC,RI
4538(00d9): 64 00 7c 5c '         jmp     #LMM_Next
453c(00da):             ' wr_word
453c(00da): 2e 5e 3c 04 '         wrword  BC,RI
4540(00db): 64 00 7c 5c '         jmp     #LMM_Next
4544(00dc):             ' wr_byte
4544(00dc): 2e 5e 3c 00 '         wrbyte  BC,RI
4548(00dd): 64 00 7c 5c '         jmp     #LMM_Next
454c(00de):             ' f_d32s
454c(00de): 20 b4 ff a0 '         mov  t1,#32
4550(00df): 00 b6 ff a0 '         mov  t2,#0           ' tmp2 is temp register to hold the remainder
4554(00e0): 34 c6 bf a0 '         mov  ftemp,r1
4558(00e1): 33 c8 bf a0 '         mov  ftmp2,r0
455c(00e2): 34 68 bc a8 '         abs  r1, r1
4560(00e3): 33 66 bc a8 '         abs  r0, r0
4564(00e4): e4 c7 bf 6c '         xor  ftemp, ftmp2
4568(00e5):             ' :loop
4568(00e5): 01 66 fc 2d '         shl  r0,#1 WC
456c(00e6): 01 b6 ff 35 '         rcl  t2,#1 WC
4570(00e7): 34 b6 bf e3 '         cmpsub t2,r1 WC,WZ
4574(00e8): 01 66 f8 80 '  if_be add  r0,#1
4578(00e9): e5 b4 ff e4 '         djnz t1,#:loop
457c(00ea): db 69 bc a0 '         mov  r1,t2
4580(00eb): e4 c9 bf a1 '         mov  ftmp2,ftmp2 WC  ' get bit #31 into carry
4584(00ec): 34 68 bc b0 '         negc r1,r1                   ' adjust the sign of the remainder
4588(00ed): e3 c7 bf a1 '         mov  ftemp,ftemp WC  ' get bit #31 into carry
458c(00ee): 33 66 bc b0 '         negc r0,r0                   ' adjust the sign of the result
4590(00ef): 65 00 7c 5c '         jmp  #LMM_loop
4594(00f0):             ' f_d32u
4594(00f0): 20 c6 ff a0 '         mov ftemp,#32
4598(00f1): 00 c8 ff a0 '         mov ftmp2, #0
459c(00f2):             ' :up2
459c(00f2): 01 66 fc 2d '         shl r0,#1       WC
45a0(00f3): 01 c8 ff 35 '         rcl ftmp2,#1    WC
45a4(00f4): e4 69 3c 87 '         cmp r1,ftmp2    WC,WZ
45a8(00f5): f8 00 44 5c '  if_a   jmp #:down
45ac(00f6): 34 c8 bf 84 '         sub ftmp2,r1
45b0(00f7): 01 66 fc 80 '         add r0,#1
45b4(00f8):             ' :down
45b4(00f8): 01 c6 ff 86 '         sub ftemp, #1   WZ
45b8(00f9): f2 00 54 5c '  if_ne  jmp #:up2
45bc(00fa): e4 69 bc a0 '         mov r1,ftmp2
45c0(00fb): 65 00 7c 5c '         jmp #LMM_loop
45c4(00fc):             ' f_m32
45c4(00fc): 00 c6 ff a0 '         mov ftemp,#0
45c8(00fd):             ' :start
45c8(00fd): 00 66 7c 86 '         cmp r0,#0       WZ
45cc(00fe): 04 01 68 5c '  if_e   jmp #:down3
45d0(00ff): 01 66 fc 29 '         shr r0,#1       WC
45d4(0100): 02 01 4c 5c '  if_ae  jmp #:down2
45d8(0101): 34 c6 bf 81 '         add ftemp,r1    WC
45dc(0102):             ' :down2
45dc(0102): 01 68 fc 2d '         shl r1,#1       WC
45e0(0103): fd 00 7c 5c '         jmp #:start
45e4(0104):             ' :down3
45e4(0104): e3 67 bc a0 '         mov r0,ftemp
45e8(0105): 65 00 7c 5c '         jmp #LMM_loop
45ec(0106):             ' bra_z
45ec(0106): ce 00 68 5c '   if_z  jmp    #f_jump       ' if condition true, branch is equiv to jump
45f0(0107): 64 00 7c 5c '         jmp    #LMM_next     ' increment PC, execute next instruction
45f4(0108):             ' bra_nz
45f4(0108): ce 00 54 5c '  if_nz  jmp    #f_jump       ' if condition true, branch is equiv to jump
45f8(0109): 64 00 7c 5c '         jmp    #LMM_next     ' increment PC, execute next instruction
45fc(010a):             ' bra_ae
45fc(010a): ce 00 4c 5c '  if_ae  jmp    #f_jump       ' if condition true, branch is equiv to jump
4600(010b): 64 00 7c 5c '         jmp    #LMM_next     ' increment PC, execute next instruction
4604(010c):             ' bra_a
4604(010c): ce 00 44 5c '  if_a   jmp    #f_jump       ' if condition true, branch is equiv to jump
4608(010d): 64 00 7c 5c '         jmp    #LMM_next     ' increment PC, execute next instruction
460c(010e):             ' bra_be
460c(010e): ce 00 78 5c '  if_be  jmp    #f_jump       ' if condition true, branch is equiv to jump
4610(010f): 64 00 7c 5c '         jmp    #LMM_next     ' increment PC, execute next instruction
4614(0110):             ' bra_b
4614(0110): ce 00 70 5c '  if_b   jmp    #f_jump       ' if condition true, branch is equiv to jump
4618(0111): 64 00 7c 5c '         jmp    #LMM_next     ' increment PC, execute next instruction
461c(0112):             ' plugin
461c(0112): 36 66 bc a0 '         mov     r0,r3           ' get plugin type
4620(0113): 80 66 7c 62 '         test    r0,#$80 wz      ' request by type?
4624(0114): 17 01 68 5c '  if_z   jmp     #ptype          ' yes - must find plugin of this type
4628(0115): 7f 66 fc 60 '         and     r0,#$7f         ' no - code is cog id
462c(0116): 23 01 7c 5c '         jmp     #pid            ' invoke plugin by cog id
4630(0117):             ' ptype
4630(0117): f0 b5 bf a0 '         mov     t1,par          ' no - point to registry
4634(0118): 00 b6 ff a0 '         mov     t2,#0           ' start at cog 0
4638(0119):             ' plgt1
4638(0119): 08 b6 7f 87 '         cmp     t2,#8 wc,wz     ' run out of plugins?
463c(011a): 2f 01 4c 5c '  if_ae  jmp     #plugerr        ' yes - no such plugin
4640(011b): da b9 bf 08 '         rdlong  t3,t1           ' no - check next plugin type
4644(011c): 18 b8 ff 28 '         shr     t3,#24          ' is it ...
4648(011d): 33 b8 3f 86 '         cmp     t3,r0 wz        ' ... the type what we wanted?
464c(011e): 22 01 68 5c '  if_z   jmp     #plgt2          ' yes - use this plugin
4650(011f): 01 b6 ff 80 '         add     t2,#1           ' no ...
4654(0120): 04 b4 ff 80 '         add     t1,#4           ' ... check ...
4658(0121): 19 01 7c 5c '         jmp     #plgt1          ' ... next cog
465c(0122):             ' plgt2
465c(0122): db 67 bc a0 '         mov     r0,t2           ' use the cog where we found the plugin
4660(0123):             ' pid
4660(0123): 02 66 fc 2c '         shl     r0,#2           ' multiply plugin (cog) id by 4 ...
4664(0124): f0 67 bc 80 '         add     r0,par          ' add registry base to get registry entry
4668(0125): 33 66 bc 08 '         rdlong  r0,r0           ' get request block from registry
466c(0126): 4f 66 3c 62 '         test    r0,top8 wz      ' plugin registered?
4670(0127): 2f 01 68 5c '  if_z   jmp     #plugerr        ' no - error 255
4674(0128): 50 66 bc 60 '         and     r0,low24        ' yes - write request ...
4678(0129): 33 6a 3c 08 '         wrlong  r2,r0           ' ... to request block
467c(012a): 33 6c bc 0a ' loop    rdlong  r3,r0   wz      ' wait till ...
4680(012b): 2a 01 54 5c '  if_nz  jmp     #loop           ' ... request completed
4684(012c): 04 66 fc 80 '         add     r0,#4           ' get results ...
4688(012d): 33 66 bc 08 '         rdlong  r0,r0           ' ... from request block
468c(012e): 65 00 7c 5c '         jmp     #LMM_loop       'done
4690(012f): 01 66 fc a4 ' plugerr neg     r0,#1           ' plugin not registered
4694(0130): 65 00 7c 5c '         jmp     #LMM_loop
4698(0131): 4b 68 bc 6c ' flt_sub                 xor     r1, Bit31               ' negate B
469c(0132): 92 3b ff 5c ' flt_add                 call    #_Unpack2               ' unpack two variables
46a0(0133): 65 00 78 5c '           if_c_or_z     jmp     #LMM_Loop               ' check for NaN or B = 0
46a4(0134): 01 ba 7f 62 '                         test    flagA, #SignFlag wz     ' negate A mantissa if negative
46a8(0135): df bf 97 a4 '           if_nz         neg     manA, manA
46ac(0136): 01 c0 7f 62 '                         test    flagB, #SignFlag wz     ' negate B mantissa if negative
46b0(0137): e2 c5 97 a4 '           if_nz         neg     manB, manB
46b4(0138): de b5 bf a0 '                         mov     t1, expA                ' align mantissas
46b8(0139): e1 b5 bf 84 '                         sub     t1, expB
46bc(013a): da b5 bf a8 '                         abs     t1, t1
46c0(013b): 1f b4 ff 4c '                         max     t1, #31
46c4(013c): e1 bd 3f c3 '                         cmps    expA, expB wz,wc
46c8(013d): da c5 87 38 '           if_nz_and_nc  sar     manB, t1
46cc(013e): da bf 93 38 '           if_nz_and_c   sar     manA, t1
46d0(013f): e1 bd 93 a0 '           if_nz_and_c   mov     expA, expB
46d4(0140): e2 bf bf 80 '                         add     manA, manB              ' add the two mantissas
46d8(0141): 00 be 7f c1 '                         cmps    manA, #0 wc, nr         ' set sign of result
46dc(0142): 01 ba f3 68 '           if_c          or      flagA, #SignFlag
46e0(0143): 01 ba cf 64 '           if_nc         andn    flagA, #SignFlag
46e4(0144): df bf bf a8 '                         abs     manA, manA              ' pack result and exit
46e8(0145): bc a9 ff 5c '                         call    #_Pack
46ec(0146): 65 00 7c 5c '                         jmp     #LMM_Loop
46f0(0147): 92 3b ff 5c ' flt_mul                 call    #_Unpack2               ' unpack two variables
46f4(0148): 65 00 70 5c '           if_c          jmp     #LMM_Loop               ' check for NaN
46f8(0149): e0 bb bf 6c '                         xor     flagA, flagB            ' get sign of result
46fc(014a): e1 bd bf 80 '                         add     expA, expB              ' add exponents
4700(014b): 00 b4 ff a0 '                         mov     t1, #0                  ' t2 = upper 32 bits of manB
4704(014c): 20 b6 ff a0 '                         mov     t2, #32                 ' loop counter for multiply
4708(014d): 01 c4 ff 29 '                         shr     manB, #1 wc             ' get initial multiplier bit
470c(014e): df b5 b3 81 ' :multiply if_c          add     t1, manA wc             ' 32x32 bit multiply
4710(014f): 01 b4 ff 31 '                         rcr     t1, #1 wc
4714(0150): 01 c4 ff 31 '                         rcr     manB, #1 wc
4718(0151): 4e b7 ff e4 '                         djnz    t2, #:multiply
471c(0152): 03 b4 ff 2c '                         shl     t1, #3                  ' justify result and exit
4720(0153): da bf bf a0 '                         mov     manA, t1
4724(0154): bc a9 ff 5c '                         call    #_Pack
4728(0155): 65 00 7c 5c '                         jmp     #LMM_Loop
472c(0156): 92 3b ff 5c ' flt_div                 call    #_Unpack2               ' unpack two variables
4730(0157): d5 67 b8 a0 '           if_c_or_z     mov     r0, NaN                 ' check for NaN or divide by 0
4734(0158): 65 00 78 5c '           if_c_or_z     jmp     #LMM_Loop
4738(0159): e0 bb bf 6c '                         xor     flagA, flagB            ' get sign of result
473c(015a): e1 bd bf 84 '                         sub     expA, expB              ' subtract exponents
4740(015b): 00 b4 ff a0 '                         mov     t1, #0                  ' clear quotient
4744(015c): 1e b6 ff a0 '                         mov     t2, #30                 ' loop counter for divide
4748(015d): 01 b4 ff 2c ' :divide                 shl     t1, #1                  ' divide the mantissas
474c(015e): e2 bf 3f c3 '                         cmps    manA, manB wz,wc
4750(015f): e2 bf af 84 '           if_z_or_nc    sub     manA, manB
4754(0160): 01 b4 ef 80 '           if_z_or_nc    add     t1, #1
4758(0161): 01 be ff 2c '                         shl     manA, #1
475c(0162): 5d b7 ff e4 '                         djnz    t2, #:divide
4760(0163): da bf bf a0 '                         mov     manA, t1                ' get result and exit
4764(0164): bc a9 ff 5c '                         call    #_Pack
4768(0165): 65 00 7c 5c '                         jmp     #LMM_Loop
476c(0166): 33 ba bf a0 ' flt_int                 mov     flagA, r0               ' get integer value
4770(0167): 00 66 fc a0 '                         mov     r0, #0                  ' set initial result to zero
4774(0168): dd bf bf aa '                         abs     manA, flagA wz          ' get absolute value of integer
4778(0169): 65 00 68 5c '           if_z          jmp     #LMM_Loop               ' if zero, exit
477c(016a): 1f ba ff 28 '                         shr     flagA, #31              ' set sign flag
4780(016b): 1f bc ff a0 '                         mov     expA, #31               ' set initial value for exponent
4784(016c): 01 be ff 2d ' :normalize              shl     manA, #1 wc             ' normalize the mantissa
4788(016d): 01 bc cf 84 '           if_nc         sub     expA, #1                ' adjust exponent
478c(016e): 6c 01 4c 5c '           if_nc         jmp     #:normalize
4790(016f): 01 be ff 30 '                         rcr     manA, #1                ' justify mantissa
4794(0170): 02 be ff 28 '                         shr     manA, #2
4798(0171): bc a9 ff 5c '                         call    #_Pack                  ' pack and exit
479c(0172): 65 00 7c 5c '                         jmp     #LMM_Loop
47a0(0173): 00 b4 ff a0 ' int_flt                 mov     t1, #0                  ' set for no rounding
47a4(0174): 9e 77 ff 5c ' fix                     call    #_Unpack                ' unpack floating point value
47a8(0175): 65 00 70 5c '           if_c          jmp     #LMM_Loop               ' check for NaN
47ac(0176): 02 be ff 2c '                         shl     manA, #2                ' left justify mantissa
47b0(0177): 00 66 fc a0 '                         mov     r0, #0                  ' initialize result to zero
47b4(0178): de bd bf a4 '                         neg     expA, expA              ' adjust for exponent value
47b8(0179): 1e bc ff 82 '                         add     expA, #30 wz
47bc(017a): 20 bc 7f c1 '                         cmps    expA, #32 wc
47c0(017b): 65 00 6c 5c '           if_nc_or_z    jmp     #LMM_Loop
47c4(017c): de bf bf 28 '                         shr     manA, expA
47c8(017d): da bf bf 80 '                         add     manA, t1                ' round up 1/2 lsb
47cc(017e): 01 be ff 28 '                         shr     manA, #1
47d0(017f): 01 ba 7f 62 '                         test    flagA, #signFlag wz     ' check sign and exit
47d4(0180): df 67 bc 9c '                         sumnz   r0, manA
47d8(0181): 65 00 7c 5c '                         jmp     #LMM_Loop
47dc(0182): 33 b4 bf a0 ' flt_cmp                 mov     t1, r0               ' compare signs
47e0(0183): 34 b4 bf 6c '                         xor     t1, r1
47e4(0184): 4b b4 bf 62 '                         and     t1, Bit31 wz
47e8(0185): 8c 01 68 5c '           if_z          jmp     #:cmp1                  ' same, then compare magnitude
47ec(0186): 33 b4 bf a0 '                         mov     t1, r0               ' check for +0 or -0
47f0(0187): 34 b4 bf 68 '                         or      t1, r1
47f4(0188): 4b b4 bf 67 '                         andn    t1, Bit31 wz,wc
47f8(0189): 65 00 68 5c '           if_z          jmp     #LMM_Loop
47fc(018a): 4b 66 3c 61 '                         test    r0, Bit31 wc         ' compare signs
4800(018b): 65 00 7c 5c '                         jmp     #LMM_Loop
4804(018c): 4b 66 3c 62 ' :cmp1                   test    r0, Bit31 wz         ' check signs
4808(018d): 90 01 54 5c '           if_nz         jmp     #:cmp2
480c(018e): 34 66 3c 87 '                         cmp     r0, r1 wz,wc
4810(018f): 65 00 7c 5c '                         jmp     #LMM_Loop
4814(0190): 33 68 3c 87 ' :cmp2                   cmp     r1, r0 wz,wc      ' reverse test if negative
4818(0191): 65 00 7c 5c '                         jmp     #LMM_Loop
481c(0192): 33 b4 bf a0 ' _Unpack2                mov     t1, r0               ' save A
4820(0193): 34 66 bc a0 '                         mov     r0, r1            ' unpack B to A
4824(0194): 9e 77 ff 5c '                         call    #_Unpack
4828(0195): 9d 01 70 5c '           if_c          jmp     #_Unpack2_ret           ' check for NaN
482c(0196): 33 68 bc a0 '                         mov     r1, r0            ' save B variables
4830(0197): dd c1 bf a0 '                         mov     flagB, flagA
4834(0198): de c3 bf a0 '                         mov     expB, expA
4838(0199): df c5 bf a0 '                         mov     manB, manA
483c(019a): da 67 bc a0 '                         mov     r0, t1               ' unpack A
4840(019b): 9e 77 ff 5c '                         call    #_Unpack
4844(019c): 00 c4 7f 86 '                         cmp     manB, #0 wz             ' set Z flag
4848(019d): 00 00 7c 5c ' _Unpack2_ret            ret
484c(019e): 33 ba bf a0 ' _Unpack                 mov     flagA, r0            ' get sign
4850(019f): 1f ba ff 28 '                         shr     flagA, #31
4854(01a0): 33 be bf a0 '                         mov     manA, r0             ' get mantissa
4858(01a1): d7 bf bf 60 '                         and     manA, Mask23
485c(01a2): 33 bc bf a0 '                         mov     expA, r0             ' get exponent
4860(01a3): 01 bc ff 2c '                         shl     expA, #1
4864(01a4): 18 bc ff 2a '                         shr     expA, #24 wz
4868(01a5): ab 01 68 5c '           if_z          jmp     #:zeroSubnormal         ' check for zero or subnormal
486c(01a6): ff bc 7f 86 '                         cmp     expA, #255 wz           ' check if finite
4870(01a7): b6 01 54 5c '           if_nz         jmp     #:finite
4874(01a8): d5 67 bc a0 '                         mov     r0, NaN              ' no, then return NaN
4878(01a9): 08 ba ff a0 '                         mov     flagA, #NaNFlag
487c(01aa): b9 01 7c 5c '                         jmp     #:exit2
4880(01ab): de bf 3f 6a ' :zeroSubnormal          or      manA, expA wz,nr        ' check for zero
4884(01ac): b0 01 54 5c '           if_nz         jmp     #:subnorm
4888(01ad): 02 ba ff 68 '                         or      flagA, #ZeroFlag        ' yes, then set zero flag
488c(01ae): 96 bc ff a4 '                         neg     expA, #150              ' set exponent and exit
4890(01af): b9 01 7c 5c '                         jmp     #:exit2
4894(01b0): 07 be ff 2c ' :subnorm                shl     manA, #7                ' fix justification for subnormals
4898(01b1): d8 bf 3f 62 ' :subnorm2               test    manA, Bit29 wz
489c(01b2): b8 01 54 5c '           if_nz         jmp     #:exit1
48a0(01b3): 01 be ff 2c '                         shl     manA, #1
48a4(01b4): 01 bc ff 84 '                         sub     expA, #1
48a8(01b5): b1 01 7c 5c '                         jmp     #:subnorm2
48ac(01b6): 06 be ff 2c ' :finite                 shl     manA, #6                ' justify mantissa to bit 29
48b0(01b7): d8 bf bf 68 '                         or      manA, Bit29             ' add leading one bit
48b4(01b8): 7f bc ff 84 ' :exit1                  sub     expA, #127              ' remove bias from exponent
48b8(01b9): 08 ba 7f 61 ' :exit2                  test    flagA, #NaNFlag wc      ' set C flag
48bc(01ba): 00 be 7f 86 '                         cmp     manA, #0 wz             ' set Z flag
48c0(01bb): 00 00 7c 5c ' _Unpack_ret             ret
48c4(01bc): 00 be 7f 86 ' _Pack                   cmp     manA, #0 wz             ' check for zero
48c8(01bd): 00 bc eb a0 '           if_z          mov     expA, #0
48cc(01be): cf 01 68 5c '           if_z          jmp     #:exit1
48d0(01bf): 01 be ff 2d ' :normalize              shl     manA, #1 wc             ' normalize the mantissa
48d4(01c0): 01 bc cf 84 '           if_nc         sub     expA, #1                ' adjust exponent
48d8(01c1): bf 01 4c 5c '           if_nc         jmp     #:normalize
48dc(01c2): 02 bc ff 80 '                         add     expA, #2                ' adjust exponent
48e0(01c3): 00 bf ff 81 '                         add     manA, #$100 wc          ' round up by 1/2 lsb
48e4(01c4): 01 bc f3 80 '           if_c          add     expA, #1
48e8(01c5): 7f bc ff 80 '                         add     expA, #127              ' add bias to exponent
48ec(01c6): d6 bd bf 40 '                         mins    expA, Minus23
48f0(01c7): ff bc ff 44 '                         maxs    expA, #255
48f4(01c8): 01 bc 7f c1 '                         cmps    expA, #1 wc             ' check for subnormals
48f8(01c9): cf 01 4c 5c '           if_nc         jmp     #:exit1
48fc(01ca): 01 be ff 68 ' :subnormal              or      manA, #1                ' adjust mantissa
4900(01cb): 01 be ff 20 '                         ror     manA, #1
4904(01cc): de bd bf a4 '                         neg     expA, expA
4908(01cd): de bf bf 28 '                         shr     manA, expA
490c(01ce): 00 bc ff a0 '                         mov     expA, #0                ' biased exponent = 0
4910(01cf): df 67 bc a0 ' :exit1                  mov     r0, manA             ' bits 22:0 mantissa
4914(01d0): 09 66 fc 28 '                         shr     r0, #9
4918(01d1): de 67 bc 58 '                         movi    r0, expA             ' bits 23:30 exponent
491c(01d2): 1f ba ff 2c '                         shl     flagA, #31
4920(01d3): dd 67 bc 68 '                         or      r0, flagA            ' bit 31 sign
4924(01d4): 00 00 7c 5c ' _Pack_ret               ret
4928(01d5): ff ff ff 7f ' NaN                     long    $7FFF_FFFF
492c(01d6): e9 ff ff ff ' Minus23                 long    -23
4930(01d7): ff ff 7f 00 ' Mask23                  long    $007F_FFFF
4934(01d8): 00 00 00 20 ' Bit29                   long    $2000_0000
4938(01d9): 00 02 00 00 ' dlsb                    long    1 << 9
493c(01da):             ' t1                      res     1                       ' temporary values
493c(01db):             ' t2                      res     1
493c(01dc):             ' t3                      res     1
493c(01dd):             ' flagA                   res     1
493c(01de):             ' expA                    res     1
493c(01df):             ' manA                    res     1
493c(01e0):             ' flagB                   res     1
493c(01e1):             ' expB                    res     1
493c(01e2):             ' manB                    res     1
493c(01e3):             ' ftemp                   res     1
493c(01e4):             ' ftmp2                   res     1
493c(01eb):             '               org       $1eb
493c(01eb): 00 00 00 00 ' DEBUG_VECTORS long      0,0,0,0,0
4940(01ec): 00 00 00 00 ' 
4944(01ed): 00 00 00 00 ' 
4948(01ee): 00 00 00 00 ' 
494c(01ef): 00 00 00 00 ' 
'========================= Method #1: PUB Entry_Addr ==========================
'PUB Entry_Addr : addr
'------------------------------------------------------------------------------
   addr := @entry ' Kernel Entry Address
'------------------------------------------------------------------------------
4950: c7 0c          PUSH#.L	OBJ+12
4952: 61             POP  	Locals+0
4953: 32             RETURN	
'============================ Method #2: PUB Run ==============================
'PUB Run (registry, request, Initial_BA, Initial_SP) : cog
'------------------------------------------------------------------------------
  long[request][2 * cogid + 1] := Initial_SP
'------------------------------------------------------------------------------
4954: 70             PUSH 	Locals+16
4955: 68             PUSH 	Locals+8
4956: 37 00          PUSH#kp	2 ($2)
4958: 3f 89          REGPUSH	$89?
495a: f4             MPY  	
495b: 36             PUSH#1	
495c: ec             ADD  	
495d: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[request][2 * cogid]     := Initial_BA
'------------------------------------------------------------------------------
495e: 6c             PUSH 	Locals+12
495f: 68             PUSH 	Locals+8
4960: 37 00          PUSH#kp	2 ($2)
4962: 3f 89          REGPUSH	$89?
4964: f4             MPY  	
4965: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  coginit(cogid, @entry, registry)
'------------------------------------------------------------------------------
4966: 3f 89          REGPUSH	$89?
4968: c7 0c          PUSH#.L	OBJ+12
496a: 64             PUSH 	Locals+4
496b: 2c             COGISUB	
496c: 32             RETURN	
496d: 00 00 00    

'******************************************************************************
'                      Catalina_HMI_Plugin_HiRes_Tv.spin                       
'******************************************************************************

'=================================== CONs =====================================
NTSC_PAL = 1
INTERLACE = 1
cols = 40
rows = 30
chrs = 1200
sc_count = 621
nx = 0
ny = 1
color = 2
buffer = 3
colors = 603
cx0 = 2476
cy0 = 2477
cm0 = 2478
cx1 = 2479
cy1 = 2480
cm1 = 2481
DATASIZE = 665
CCHAR = 14
'=============================== Object Header ================================
4970: ac 08 03 04 ' 2220 bytes, 3-1 methods, 4 object pointers
4974: 90 07 00 00 ' ptr #1 to $5100: PUB ProxySetup (locals size: 0)
4978: 97 07 40 00 ' ptr #2 to $5107: PUB Start (locals size: 64)
497c: ac 08 0c 00 ' ptr #3 to $521c: OBJ kbd : Catalina_comboKeyboard.spin (VAR offset: 12)
4980: cc 0d 0c 00 ' ptr #4 to $573c: OBJ mouse : Catalina_comboMouse.spin (VAR offset: 12)
4984: 68 10 0c 00 ' ptr #5 to $59d8: OBJ screen : Catalina_HiRes_TV_Text.spin (VAR offset: 12)
4988: a4 15 10 00 ' ptr #6 to $5f14: OBJ common : Catalina_Common.spin (VAR offset: 16)
'================================ DAT Section =================================
498c(0000):             '         org     0
498c(0000):             ' HmiStart
498c(0000): 01 bc ff 0c '         cogid   t1              ' calculate ...
4990(0001): 02 bc ff 2c '         shl     t1,#2           ' ... my ...
4994(0002): f0 bd bf 80 '         add     t1,par          ' ... request ...
4998(0003): de b3 bf 08 '         rdlong  rqstptr,t1      ' ... block ...
499c(0004): d1 b3 bf 60 '         and     rqstptr,low24   ' ... address
49a0(0005): d9 b5 bf a0 '         mov     rsltptr,rqstptr ' calculate ...
49a4(0006): 04 b4 ff 80 '         add     rsltptr,#4      ' ... my result address
49a8(0007):             ' loop
49a8(0007): 1e 5d fe 5c '         call    #ccheck         ' update cursor if required
49ac(0008): d9 b7 bf 0a '         rdlong  rqst,rqstptr wz ' any requests?
49b0(0009): 07 00 68 5c '    if_z jmp     #loop           ' no - wait for a request
49b4(000a): db bd bf a0 '         mov     t1,rqst
49b8(000b): 18 bc ff 28 '         shr     t1,#24
49bc(000c): 20 bc 7f 87 '         cmp     t1,#32 wz,wc
49c0(000d): f4 00 44 5c '   if_a  jmp     #done_bad
49c4(000e): 02 bc ff 20 '         ror     t1,#2           ' lookup code address
49c8(000f): 17 bc ff 80 '         add     t1,#svctable
49cc(0010): de 27 bc 50 '         movs    :table,t1
49d0(0011): 02 bc ff 24 '         rol     t1,#2
49d4(0012): 03 bc ff 2c '         shl     t1,#3
49d8(0013): 00 be bf a0 ' :table  mov     t2,0
49dc(0014): de bf bf 28 '         shr     t2,t1
49e0(0015): ff be ff 60 '         and     t2,#$FF
49e4(0016): df 01 3c 5c '         jmp     t2              ' jump to code routine
49e8(0017):             ' svctable
49e8(0017): 20          '         byte    initialize      ' 0
49e9(----): 37          '         byte    k_present       ' 1
49ea(----): 3c          '         byte    k_get           ' 2
49eb(----): 45          '         byte    k_wait          ' 3
49ec(0018): 42          '         byte    k_new           ' 4
49ed(----): 49          '         byte    k_ready         ' 5
49ee(----): 4d          '         byte    k_clear         ' 6
49ef(----): 51          '         byte    k_state         ' 7
49f0(0019): f4          '         byte    done_bad        ' 8
49f1(----): f4          '         byte    done_bad        ' 9
49f2(----): f4          '         byte    done_bad        '10
49f3(----): 5d          '         byte    m_present       '11
49f4(001a): 60          '         byte    m_button        '12
49f5(----): 68          '         byte    m_buttons       '13
49f6(----): 6b          '         byte    m_abs_x         '14
49f7(----): 6e          '         byte    m_abs_y         '15
49f8(001b): 71          '         byte    m_abs_z         '16
49f9(----): 75          '         byte    m_delta_x       '17
49fa(----): 7e          '         byte    m_delta_y       '18
49fb(----): 81          '         byte    m_delta_z       '19
49fc(001c): 84          '         byte    m_reset         '20
49fd(----): 8e          '         byte    t_geometry      '21
49fe(----): 92          '         byte    t_char          '22
49ff(----): 97          '         byte    t_string        '23
4a00(001d): 9e          '         byte    t_int           '24
4a01(----): bf          '         byte    t_unsigned      '25
4a02(----): f4          '         byte    done_bad        '26 (now implemented in C)
4a03(----): f4          '         byte    done_bad        '27 (now implemented in C)
4a04(001e): c7          '         byte    t_setpos        '28
4a05(----): d7          '         byte    t_getpos        '29
4a06(----): c1          '         byte    t_mode          '30
4a07(----): e2          '         byte    t_scroll        '31
4a08(001f): de          '         byte    t_color         '32
4a09(----): 00 00 00    
4a0c(0020):             '         long                    ' align long
4a0c(0020):             ' initialize
4a0c(0020): db ad bf 08 '         rdlong  ppkbd,rqst      ' save pointer to keyboard parameters
4a10(0021): 04 b6 ff 80 '         add     rqst,#4         ' save pointer to ...
4a14(0022): db af bf 08 '         rdlong  ppmouse,rqst    ' ... mouse params
4a18(0023): 04 b6 ff 80 '         add     rqst,#4         ' save pointer to ...
4a1c(0024): db b1 bf 08 '         rdlong  ppscrn,rqst     ' ... screen parameters
4a20(0025): d8 bb bf a0 '         mov     t0,ppscrn       ' get ...
4a24(0026): dd bd bf 08 '         rdlong  t1,t0           ' ... screen ...
4a28(0027): de d1 bf a0 '         mov     scrcols,t1      ' ... cols
4a2c(0028): 04 ba ff 80 '         add     t0,#4           ' get ...
4a30(0029): dd bf bf 08 '         rdlong  t2,t0           ' ... screen ...
4a34(002a): df d3 bf a0 '         mov     scrrows,t2      ' ... rows
4a38(002b): be 85 ff 5c '         call    #m32            ' multiply rows by cols
4a3c(002c): dd d5 bf a0 '         mov     scrsize,t0      ' save as acreen size
4a40(002d): d8 d9 bf a0 '         mov     scrclrs,ppscrn  ' calculate ...
4a44(002e): 08 d8 ff 80 '         add     scrclrs,#8      ' ... screen color address
4a48(002f): d8 d7 bf a0 '         mov     scrbuff,ppscrn  ' calculate ...
4a4c(0030): 0c d6 ff 80 '         add     scrbuff,#12     ' ... screen buffer address
4a50(0031): eb db bf a0 '         mov     scrpall,scrbuff ' calculate ...
4a54(0032): ea db bf 80 '         add     scrpall,scrsize ' ... palette ...
4a58(0033): ea db bf 80 '         add     scrpall,scrsize ' ... address
4a5c(0034): ed dd bf a0 '         mov     scrcurs,scrpall ' calculate ...
4a60(0035): 40 dc ff 80 '         add     scrcurs,#64     ' ... screen cursors address
4a64(0036): f6 00 7c 5c '         jmp     #done_ok
4a68(0037):             ' k_present
4a68(0037): d6 bb bf a0 '         mov     t0,ppkbd        ' get ...
4a6c(0038): 08 ba ff 80 '         add     t0,#8           ' ...
4a70(0039): dd b9 bf 08 '         rdlong  rslt,t0         ' ... par_present
4a74(003a): dc b9 bf a4 '         neg     rslt,rslt       ' return -par_present
4a78(003b): f7 00 7c 5c '         jmp     #done
4a7c(003c):             ' k_get
4a7c(003c): 02 3b fe 5c '         call    #k_load         ' load key pointed to by par_tail
4a80(003d): f6 00 68 5c '    if_z jmp     #done_ok        ' Z set if no key available
4a84(003e):             ' k_consume
4a84(003e): 01 bc ff 80 '         add     t1,#1           ' increment ...
4a88(003f): 0f bc ff 60 '         and     t1,#$f          ' ...
4a8c(0040): d6 bd 3f 08 '         wrlong  t1,ppkbd        ' ... par_tail
4a90(0041): f7 00 7c 5c '         jmp     #done
4a94(0042): fb 02 fe 5c ' k_new   call    #k_setup        ' setup common values
4a98(0043): d6 bb bf a0 '         mov     t0,ppkbd        ' set par_tail ...
4a9c(0044): dd bf 3f 08 '         wrlong  t2,t0           ' ... to par_head
4aa0(0045):             ' k_wait
4aa0(0045): 1e 5d fe 5c '         call    #ccheck         ' check for cursor update
4aa4(0046): 02 3b fe 5c '         call    #k_load         ' load key pointed to by par_tail
4aa8(0047): 45 00 68 5c '  if_z   jmp     #k_wait         ' Z set if no key available
4aac(0048): 3e 00 7c 5c '         jmp     #k_consume      ' consume and return the key
4ab0(0049):             ' k_ready
4ab0(0049): fb 02 fe 5c '         call    #k_setup        ' setup common values
4ab4(004a): f7 00 68 5c '   if_z  jmp     #done           ' rslt == 0 if no key ready
4ab8(004b): 01 b8 ff a4 '         neg     rslt,#1         ' rslt == -1 if a key is ready
4abc(004c): f7 00 7c 5c '         jmp     #done
4ac0(004d):             ' k_clear
4ac0(004d): fb 02 fe 5c '         call    #k_setup        ' setup common values
4ac4(004e): d6 bb bf a0 '         mov     t0,ppkbd        ' set par_tail ...
4ac8(004f): dd bf 3f 08 '         wrlong  t2,t0           ' .... to par_head
4acc(0050): f7 00 7c 5c '         jmp     #done
4ad0(0051):             ' k_state
4ad0(0051): d6 bb bf a0 '         mov     t0,ppkbd        ' point to ...
4ad4(0052): 0c ba ff 80 '         add     t0,#12          ' ... par_states
4ad8(0053): db bd bf a0 '         mov     t1,rqst         ' get ...
4adc(0054): ff bc ff 60 '         and     t1,#$ff         ' ... key ...
4ae0(0055): de bf bf a0 '         mov     t2,t1           ' ... to test in t1 & t2
4ae4(0056): 05 bc ff 28 '         shr     t1,#5           ' read ...
4ae8(0057): dd bd bf 80 '         add     t1,t0           ' ... long ...
4aec(0058): de b9 bf 08 '         rdlong  rslt,t1         ' ... containing  bit
4af0(0059): df b9 bf 20 '         ror     rslt,t2         ' rotate required bit ...
4af4(005a): 01 b8 ff 60 '         and     rslt,#1         ' .. into position 0
4af8(005b):             ' negrslt
4af8(005b): dc b9 bf a4 '         neg     rslt,rslt       ' and return -rslt
4afc(005c): f7 00 7c 5c '         jmp     #done
4b00(005d):             ' m_present
4b00(005d): d7 bb bf a0 '         mov     t0,ppmouse      ' read ...
4b04(005e): 1c ba ff 80 '         add     t0,#7*4         ' ... par_present ...
4b08(005f): 73 00 7c 5c '         jmp     #m_rett0        ' ... and return it
4b0c(0060):             ' m_button
4b0c(0060): d7 bb bf a0 '         mov     t0,ppmouse      ' read ...
4b10(0061): 18 ba ff 80 '         add     t0,#6*4         ' ... par_buttons ...
4b14(0062): dd b9 bf 08 '         rdlong  rslt,t0         ' .. to get state of buttons
4b18(0063): db bd bf a0 '         mov     t1,rqst         ' get ...
4b1c(0064): ff bc ff 60 '         and     t1,#$ff         ' ... button from request
4b20(0065): de b9 bf 28 '         shr     rslt,t1         ' return ...
4b24(0066): 01 b8 ff 60 '         and     rslt,#1         ' ....
4b28(0067): 5b 00 7c 5c '         jmp     #negrslt        ' -button
4b2c(0068):             ' m_buttons
4b2c(0068): d7 bb bf a0 '         mov     t0,ppmouse      ' read ...
4b30(0069): 18 ba ff 80 '         add     t0,#6*4         ' ... par_buttons ...
4b34(006a): 73 00 7c 5c '         jmp     #m_rett0        ' ... and return it
4b38(006b):             ' m_abs_x
4b38(006b): d7 bb bf a0 '         mov     t0,ppmouse      ' read ...
4b3c(006c): 0c ba ff 80 '         add     t0,#3*4         ' ... par_x ...
4b40(006d): 73 00 7c 5c '         jmp     #m_rett0        ' ... and return it
4b44(006e):             ' m_abs_y
4b44(006e): d7 bb bf a0 '         mov     t0,ppmouse      ' read ...
4b48(006f): 10 ba ff 80 '         add     t0,#4*4         ' ... par_y ...
4b4c(0070): 73 00 7c 5c '         jmp     #m_rett0        ' ... and return it
4b50(0071):             ' m_abs_z
4b50(0071): d7 bb bf a0 '         mov     t0,ppmouse      ' read ...
4b54(0072): 14 ba ff 80 '         add     t0,#5*4         ' ... par_z ...
4b58(0073):             ' m_rett0
4b58(0073): dd b9 bf 08 '         rdlong  rslt,t0         ' ... and return it
4b5c(0074): f7 00 7c 5c '         jmp     #done
4b60(0075):             ' m_delta_x
4b60(0075): d7 bb bf a0 '         mov     t0,ppmouse      ' point to old x value
4b64(0076):             ' m_delta
4b64(0076): dd bd bf a0 '         mov     t1,t0           ' point to ...
4b68(0077): 0c bc ff 80 '         add     t1,#3*4         ' ... new val
4b6c(0078): de c1 bf 08 '         rdlong  t3,t1           ' read new
4b70(0079): dd bf bf 08 '         rdlong  t2,t0           ' read old
4b74(007a): e0 b9 bf a0 '         mov     rslt,t3         ' calculate ...
4b78(007b): df b9 bf 84 '         sub     rslt,t2         ' ... dx = new - old
4b7c(007c): dd c1 3f 08 '         wrlong  t3,t0           ' update old = new
4b80(007d): f7 00 7c 5c '         jmp     #done           ' return dx
4b84(007e):             ' m_delta_y
4b84(007e): d7 bb bf a0 '         mov     t0,ppmouse      ' point to old ...
4b88(007f): 04 ba ff 80 '         add     t0,#1*4         ' ... y value
4b8c(0080): 76 00 7c 5c '         jmp     #m_delta        ' return delta
4b90(0081):             ' m_delta_z
4b90(0081): d7 bb bf a0 '         mov     t0,ppmouse      ' point to old ...
4b94(0082): 08 ba ff 80 '         add     t0,#2*4         ' ... z value
4b98(0083): 76 00 7c 5c '         jmp     #m_delta        ' return delta
4b9c(0084):             ' m_reset
4b9c(0084): d7 bb bf a0 '         mov     t0,ppmouse      ' point to oldx
4ba0(0085): d7 bd bf a0 '         mov     t1,ppmouse      ' point to ...
4ba4(0086): 0c bc ff 80 '         add     t1,#3*4         ' ... par_x
4ba8(0087): 03 c0 ff a0 '         mov     t3,#3           ' 3 longs to copy
4bac(0088):             ' :m_resloop
4bac(0088): de bf bf 08 '         rdlong  t2,t1           ' copy ...
4bb0(0089): dd bf 3f 08 '         wrlong  t2,t0           ' ... longs ...
4bb4(008a): 04 ba ff 80 '         add     t0,#4           ' ... from ...
4bb8(008b): 04 bc ff 80 '         add     t1,#4           ' ... t1 ...
4bbc(008c): 88 c0 bf e4 '         djnz    t3,:m_resloop   ' ... to t0
4bc0(008d): f6 00 7c 5c '         jmp     #done_ok        ' done
4bc4(008e):             ' t_geometry
4bc4(008e): e8 b9 bf a0 '         mov     rslt,scrcols    ' result is ...
4bc8(008f): 08 b8 ff 2c '         shl     rslt,#8         ' ... cols*256 ...
4bcc(0090): e9 b9 bf 80 '         add     rslt,scrrows    ' ... plus rows
4bd0(0091): f7 00 7c 5c '         jmp     #done
4bd4(0092):             ' t_char
4bd4(0092): 33 71 fe 5c '         call    #t_nocurs      ' set up cursor address
4bd8(0093): db c5 bf a0 '         mov     t5,rqst         ' get ...
4bdc(0094): ff c4 ff 60 '         and     t5,#$ff         ' ... char to write
4be0(0095): 5e 2d ff 5c '         call    #t_put5         ' write char to screen at cursor
4be4(0096): f6 00 7c 5c '         jmp     #done_ok
4be8(0097):             ' t_string
4be8(0097): 33 71 fe 5c '         call    #t_nocurs      ' set up cursor address
4bec(0098): d0 b7 bf 60 '         and     rqst,low23      ' source address is lower 23 bits of request
4bf0(0099):             ' :t_strloop
4bf0(0099): db c5 bf 02 '         rdbyte  t5,rqst wz      ' get char to write
4bf4(009a): f6 00 68 5c '   if_z  jmp     #done_ok        ' finished if null byte
4bf8(009b): 5e 2d ff 5c '         call    #t_put5         ' write char to screen at cursor
4bfc(009c): 01 b6 ff 80 '         add     rqst,#1         ' increment string pointer
4c00(009d): 99 00 7c 5c '         jmp     #:t_strloop     ' put more chars
4c04(009e):             ' t_int
4c04(009e): 39 79 fe 5c '         call    #t_getnum       ' point to cursor and get number to print
4c08(009f): 00 b6 7f c3 '         cmps    rqst,#0 WC,WZ   ' positive?
4c0c(00a0): a4 00 4c 5c '  if_ae  jmp     #t_uint         ' yes - no sign
4c10(00a1): 2d c4 ff a0 '         mov     t5,#$2d         ' no - prefix number with '-'
4c14(00a2): 5e 2d ff 5c '         call    #t_put5         ' write char to screen at cursor
4c18(00a3): db b7 bf ab '         abs     rqst,rqst WC,WZ ' make number positive
4c1c(00a4):             ' t_uint
4c1c(00a4): bb 00 68 5c '   if_z  jmp     #:t_int4        ' if zero, just print one digit
4c20(00a5): d2 c3 bf a0 '         mov     t4,maxdec       ' get largest possible decimal divisor
4c24(00a6):             ' :t_int2
4c24(00a6): e1 b7 3f 87 '         cmp     rqst,t4 WC,WZ   ' is our number larger than that?
4c28(00a7): ad 00 4c 5c '  if_ae  jmp     #:t_int3        ' yes - start extracting decimal digits
4c2c(00a8): e1 bb bf a0 '         mov     t0,t4           ' no - divide divisor ...
4c30(00a9): 0a bc ff a0 '         mov     t1,#10          ' ... by 10 ...
4c34(00aa): c3 9d ff 5c '         call    #d32u           ' ... and ...
4c38(00ab): dd c3 bf a0 '         mov     t4,t0           ' ... try ...
4c3c(00ac): a6 00 7c 5c '         jmp     #:t_int2        ' ... again
4c40(00ad):             ' :t_int3
4c40(00ad): 0a c2 7f 87 '         cmp     t4,#10 WC,WZ    ' is this the last digit?
4c44(00ae): bb 00 70 5c '  if_b   jmp     #:t_int4        ' yes - no need to divide any more
4c48(00af): db bb bf a0 '         mov     t0,rqst         ' no - divide number ...
4c4c(00b0): e1 bd bf a0 '         mov     t1,t4           ' ... by  ...
4c50(00b1): c3 9d ff 5c '         call    #d32u           ' ... divisor
4c54(00b2): dd c5 bf a0 '         mov     t5,t0           ' convert quotient ...
4c58(00b3): 30 c4 ff 80 '         add     t5,#$30         ' ... to digit char
4c5c(00b4): de b7 bf a0 '         mov     rqst,t1         ' save remainder for next time
4c60(00b5): 5e 2d ff 5c '         call    #t_put5         ' write char to screen at cursor
4c64(00b6): e1 bb bf a0 '         mov     t0,t4           ' divide divisor ...
4c68(00b7): 0a bc ff a0 '         mov     t1,#10          ' ... by 10 ...
4c6c(00b8): c3 9d ff 5c '         call    #d32u           ' ... and ...
4c70(00b9): dd c3 bf a0 '         mov     t4,t0           ' ... continue ...
4c74(00ba): ad 00 7c 5c '         jmp     #:t_int3        ' ... with next digit
4c78(00bb):             ' :t_int4
4c78(00bb): db c5 bf a0 '         mov     t5,rqst           ' convert last decimal digit ...
4c7c(00bc): 30 c4 ff 80 '         add     t5,#$30         ' ... to digit char
4c80(00bd): 5e 2d ff 5c '         call    #t_put5         ' write char to screen at cursor
4c84(00be): f6 00 7c 5c '         jmp     #done_ok
4c88(00bf):             ' t_unsigned
4c88(00bf): 39 79 fe 5c '         call    #t_getnum       ' point to cursor and get number to print
4c8c(00c0): a4 00 7c 5c '         jmp     #t_uint         ' no sign, just print digits
4c90(00c1):             ' t_mode
4c90(00c1): 33 71 fe 5c '         call    #t_nocurs      ' set up cursor address
4c94(00c2): 02 c0 ff 80 '         add     t3,#2           ' point to cursor mode byte
4c98(00c3): db bb bf a0 '         mov     t0,rqst         ' save ...
4c9c(00c4): ff ba ff 60 '         and     t0,#$ff         ' ... cursor ...
4ca0(00c5): e0 bb 3f 00 '         wrbyte  t0,t3           ' ... mode byte
4ca4(00c6): f6 00 7c 5c '         jmp     #done_ok
4ca8(00c7):             ' t_setpos
4ca8(00c7): 33 71 fe 5c '         call    #t_nocurs      ' set up cursor address
4cac(00c8): db bd bf a0 '         mov     t1,rqst         ' extract ...
4cb0(00c9): 08 bc ff 28 '         shr     t1,#8           ' ... cols ...
4cb4(00ca): ff bc ff 60 '         and     t1,#$ff         ' ... from request
4cb8(00cb): e8 bd 3f 87 '         cmp     t1,scrcols wz,wc ' ensure ...
4cbc(00cc): e8 bd 8f a0 '   if_ae mov     t1,scrcols      ' ... cols within bounds ...
4cc0(00cd): 01 bc cf 84 '   if_ae sub     t1,#1           ' ... or use screen cols - 1
4cc4(00ce): db bf bf a0 '         mov     t2,rqst         ' extract ...
4cc8(00cf): ff be ff 60 '         and     t2,#$ff         ' ... rows from request
4ccc(00d0): e9 bf 3f 87 '         cmp     t2,scrrows wz,wc ' ensure ...
4cd0(00d1): e9 bf 8f a0 '   if_ae mov     t2,scrrows      ' ... rows within bounds ...
4cd4(00d2): 01 be cf 84 '   if_ae sub     t2,#1           ' ... or use screen rows - 1
4cd8(00d3): e0 bd 3f 00 '         wrbyte  t1,t3           ' save cols
4cdc(00d4): 01 c0 ff 80 '         add     t3,#1           ' save ...
4ce0(00d5): e0 bf 3f 00 '         wrbyte  t2,t3           ' ... rows
4ce4(00d6): f6 00 7c 5c '         jmp     #done_ok
4ce8(00d7):             ' t_getpos
4ce8(00d7): 33 71 fe 5c '         call    #t_nocurs      ' set up cursor address
4cec(00d8): e0 b9 bf 00 '         rdbyte  rslt,t3         ' get cursor cols
4cf0(00d9): 01 c0 ff 80 '         add     t3,#1           ' get ...
4cf4(00da): e0 bd bf 00 '         rdbyte  t1,t3           ' ... cursor rows
4cf8(00db): 08 b8 ff 2c '         shl     rslt,#8         ' return ...
4cfc(00dc): de b9 bf 80 '         add     rslt,t1         ' 256*cols + rows
4d00(00dd): f7 00 7c 5c '         jmp     #done
4d04(00de):             ' t_color
4d04(00de): db bb bf a0 '         mov     t0,rqst         ' set ...
4d08(00df): 07 ba ff 60 '         and     t0,#$7          ' ... color as 0 .. 7 ...
4d0c(00e0): ec bb 3f 08 '         wrlong  t0,scrclrs      ' ... of request 
4d10(00e1): f6 00 7c 5c '         jmp     #done_ok
4d14(00e2):             ' t_scroll
4d14(00e2): 33 71 fe 5c '         call    #t_nocurs
4d18(00e3): db c7 bf a0 '         mov     t6,rqst         ' get ...
4d1c(00e4): ff c6 ff 60 '         and     t6,#$ff         ' .... last ...
4d20(00e5): e9 c7 3f 87 '         cmp     t6,scrrows wz,wc ' ... row ...
4d24(00e6): e9 c7 87 a0 '  if_a   mov     t6,scrrows      ' ... or use last row ...
4d28(00e7): 01 c6 ff 84 '         sub     t6,#1           ' ... on screen
4d2c(00e8): db c9 bf a0 '         mov     t7,rqst         ' get ...
4d30(00e9): 08 c8 ff 28 '         shr     t7,#8           ' ... first ...
4d34(00ea): ff c8 ff 60 '         and     t7,#$ff         ' ... row ...
4d38(00eb): e0 c9 3f 87 '         cmp     t7,t3 wz,wc     ' ... or  ...
4d3c(00ec): e0 c9 87 a0 '  if_a   mov     t7,t3           ' ... use last row
4d40(00ed): db cb bf a0 '         mov     t8,rqst         ' get ...
4d44(00ee): 10 ca ff 28 '         shr     t8,#16          ' ... scroll ...
4d48(00ef): ff ca ff 60 '         and     t8,#$ff         ' ... count ...
4d4c(00f0): e9 cb 3f 87 '         cmp     t8,scrrows wz,wc ' ... or ...
4d50(00f1): e9 cb 87 a0 '  if_a   mov     t8,scrrows      ' ... use number of row on screen
4d54(00f2): 97 6f ff 5c '         call    #t_scroll2      ' scroll the screen
4d58(00f3): f6 00 7c 5c '         jmp     #done_ok        '
4d5c(00f4):             ' done_bad
4d5c(00f4): 01 b8 ff a4 '         neg      rslt,#1        ' unknown code specified
4d60(00f5): f7 00 7c 5c '         jmp      #done
4d64(00f6):             ' done_ok
4d64(00f6): 00 b8 ff a0 '         mov      rslt,#0        ' return zero
4d68(00f7):             ' done
4d68(00f7): da b9 3f 08 '         wrlong   rslt,rsltptr   ' save result
4d6c(00f8): 00 b8 ff a0 '         mov      rslt,#0        ' indicate ...
4d70(00f9): d9 b9 3f 08 '         wrlong   rslt,rqstptr   ' ... request complete
4d74(00fa): 07 00 7c 5c '         jmp      #loop          ' wait for next request
4d78(00fb):             ' k_setup
4d78(00fb): d6 bb bf a0 '         mov     t0,ppkbd        ' get ...
4d7c(00fc): dd bd bf 08 '         rdlong  t1,t0           ' ... par_tail
4d80(00fd): 04 ba ff 80 '         add     t0,#4           ' get ...
4d84(00fe): dd bf bf 08 '         rdlong  t2,t0           ' ... par_head
4d88(00ff): de b9 bf a0 '         mov     rslt,t1         ' set Z flag ...
4d8c(0100): df b9 bf 86 '         sub     rslt,t2 wz      ' ... and rslt = 0 if par_tail == par_head
4d90(0101):             ' k_setup_ret
4d90(0101): 00 00 7c 5c '         ret
4d94(0102):             ' k_load
4d94(0102): fb 02 fe 5c '         call    #k_setup        ' setup common values
4d98(0103): 1d 01 68 5c '  if_z   jmp     #k_load_ret     ' Z flag set if no key available
4d9c(0104): 28 ba ff 80 '         add     t0,#40          ' load ...
4da0(0105): dd b9 bf a0 '         mov     rslt,t0         ' ... key ...
4da4(0106): de b9 bf 80 '         add     rslt,t1         ' ... indicated ...
4da8(0107): de b9 bf 80 '         add     rslt,t1         ' ... by ...
4dac(0108): dc b9 bf 04 '         rdword  rslt,rslt       ' ... par_tail
4db0(0109): cb b8 7f 86 '         cmp     rslt,#$CB wz    ' ESC?
4db4(010a): 1b b8 eb a0 '  if_z   mov     rslt,#$1B       ' if so, correct it     
4db8(010b): c8 b8 7f 86 '         cmp     rslt,#$C8 wz    ' BS?
4dbc(010c): 08 b8 eb a0 '  if_z   mov     rslt,#$08       ' if so, correct it
4dc0(010d): d3 b9 3f 62 '         test    rslt,ctrl wz    ' control key?
4dc4(010e): 1a 01 68 5c '  if_z   jmp     #k_unset_z      ' no - return it
4dc8(010f): dc bb bf a0 '         mov     t0, rslt        ' yes - correct it ...
4dcc(0110): ff ba ff 60 '         and     t0,#$ff         ' ... if in range ...
4dd0(0111): 40 ba 7f 87 '         cmp     t0,#$40 wz,wc   ' ... $40 ...
4dd4(0112): 1a 01 70 5c '  if_b   jmp     #k_unset_z      ' ... to ...
4dd8(0113): 80 ba 7f 87 '         cmp     t0,#$80 wz,wc   ' ... $80 ...
4ddc(0114): 1a 01 4c 5c '  if_ae  jmp     #k_unset_z      ' ... otherwise just return it
4de0(0115): 60 ba 7f 87 '         cmp     t0,#$60 wz,wc   ' correct ...
4de4(0116): 20 ba cf 84 '  if_ae  sub     t0,#$20         ' ... both upper ...
4de8(0117): 40 ba ff 84 '         sub     t0,#$40         ' ... and lower case
4dec(0118): d4 b9 bf 60 '         and     rslt,noctrl     ' mask off control flag ...
4df0(0119): dd b9 bf 68 '         or      rslt,t0         ' ... and substitute corrected key
4df4(011a):             ' k_unset_z
4df4(011a): 04 b8 7f 86 '         cmp     rslt,#$04 wz    ' EOT?
4df8(011b): 01 b8 eb a4 '  if_z   neg     rslt,#1         ' if so, return -1 (EOF)
4dfc(011c): 01 ba ff a2 '         mov     t0,#1 wz        ' ensure Z flag not set!
4e00(011d):             ' k_load_ret
4e00(011d): 00 00 7c 5c '         ret
4e04(011e):             ' ccheck
4e04(011e): 2e b1 7f ec '         tjz     ppscrn,#ccheck_ret ' return if not yet initialized
4e08(011f): f1 bd bf a0 '         mov     t1,cnt          ' time ...
4e0c(0120): 2f bd bf 84 '         sub     t1,last         ' ... to update ...
4e10(0121): 30 bd 3f 87 '         cmp     t1,ctime wz,wc  ' ... visible cursor?
4e14(0122): 2e 01 78 5c '   if_be jmp     #ccheck_ret     ' no - just return
4e18(0123): f1 5f be a0 '         mov     last,cnt        ' yes - update last cursor swap time
4e1c(0124):             ' cswap
4e1c(0124): ee c1 bf a0 '         mov     t3,scrcurs      ' get address of cursor 1 ...
4e20(0125): 05 c0 ff 80 '         add     t3,#5           ' ... mode byte
4e24(0126): e0 bb bf 00 '         rdbyte  t0,t3           ' read mode byte
4e28(0127): 01 ba 7f 62 '         test    t0,#1 wz        ' cursor visible ?
4e2c(0128): 2e 01 68 5c '   if_z  jmp     #cswap_ret      ' no - return
4e30(0129): 02 c0 ff 84 '         sub     t3,#2           ' yes - point to cursor 1 data 
4e34(012a): 3d 8d fe 5c '         call    #t_scrpos       ' point to screen cursor location
4e38(012b): dd bd bf 04 '         rdword  t1,t0           ' swap char ...
4e3c(012c): dd 63 3e 04 '         wrword  schar,t0        ' ... at cursor position ...
4e40(012d): de 63 be a0 '         mov     schar,t1        ' ... with cursor char
4e44(012e):             ' cswap_ret
4e44(012e):             ' ccheck_ret
4e44(012e): 00 00 7c 5c '         ret
4e48(012f): 00 00 00 00 ' last    long    0               ' last clock count retrieved
4e4c(0130): 00 5a 62 02 ' ctime   long    40000000        ' cursor on/off time (~0.5 sec)
4e50(0131): 0e 02 00 00 ' schar   long    (CCHAR & 1)<<10 + $200 + (CCHAR & $FE) ' char to swap with screen char
4e54(0132): 0e 02 00 00 ' scurs   long    (CCHAR & 1)<<10 + $200 + (CCHAR & $FE) ' char to swap with screen char
4e58(0133):             ' t_nocurs
4e58(0133): 32 63 3e 86 '         cmp     schar,scurs wz  ' yes - if cursor is on the screen ...
4e5c(0134): 24 5d d6 5c '   if_nz call    #cswap          ' ... restore original char
4e60(0135):             ' t_setcurs
4e60(0135): ee c1 bf a0 '         mov     t3,scrcurs      ' get address of cursor 0 data
4e64(0136): cf b7 3f 62 '         test    rqst,curs_1 wz  ' request intended for cursor 0 ?
4e68(0137): 03 c0 d7 80 '   if_nz add     t3,#3           ' no - add offset for cursor 1 data
4e6c(0138):             ' t_setcurs_ret
4e6c(0138):             ' t_nocurs_ret
4e6c(0138): 00 00 7c 5c '         ret
4e70(0139):             ' t_getnum
4e70(0139): 33 71 fe 5c '         call    #t_nocurs      ' set up cursor address
4e74(013a): d0 b7 bf 60 '         and     rqst,low23      ' source address is lower 23 bits of request
4e78(013b): db b7 bf 0a '         rdlong  rqst,rqst wz    ' get the actual number in the request
4e7c(013c):             ' t_getnum_ret                                
4e7c(013c): 00 00 7c 5c '         ret
4e80(013d):             ' t_scrpos
4e80(013d): e8 bd bf a0 '         mov     t1,scrcols      ' get cols per row
4e84(013e): 01 c0 ff 80 '         add     t3,#1           ' get ...
4e88(013f): e0 bf bf 00 '         rdbyte  t2,t3           ' ... cursor row
4e8c(0140): be 85 ff 5c '         call    #m32            ' mult cursor row by screen cols
4e90(0141): 01 c0 ff 84 '         sub     t3,#1           ' get ...
4e94(0142): e0 bf bf 00 '         rdbyte  t2,t3           ' ... cursor col
4e98(0143): df bb bf 80 '         add     t0,t2           ' add cursor col
4e9c(0144): 01 ba ff 2c '         shl     t0,#1           ' (multiply by two as screen is in words)
4ea0(0145): eb bb bf 80 '         add     t0,scrbuff      ' add screen buffer base
4ea4(0146):             ' t_scrpos_ret
4ea4(0146): 00 00 7c 5c '         ret
4ea8(0147):             ' t_inccur
4ea8(0147): e0 bd bf 00 '         rdbyte  t1,t3           ' get cursor col
4eac(0148): 01 bc ff 80 '         add     t1,#1           ' increment col
4eb0(0149): e8 bd 3f 85 '         cmp     t1,scrcols wc   ' past last col?
4eb4(014a): 5c 01 70 5c '    if_b jmp     #:t_inccol      ' no - just update col
4eb8(014b): 01 c0 ff 80 '         add     t3,#1           ' yes - increment ...
4ebc(014c): e0 bf bf 00 '         rdbyte  t2,t3           ' ... cursor ...
4ec0(014d): 01 be ff 80 '         add     t2,#1           ' ... row
4ec4(014e): e9 bf 3f 87 '         cmp     t2,scrrows wc,wz ' past last row?
4ec8(014f): 59 01 70 5c '  if_b   jmp     #:t_setrow      ' no - just update row
4ecc(0150): 01 c0 ff 80 '         add     t3,#1           ' yes - check ...
4ed0(0151): e0 bb bf 00 '         rdbyte  t0,t3           ' ... cursor mode ...
4ed4(0152): 01 c0 ff 84 '         sub     t3,#1           ' ... for ...
4ed8(0153): 08 ba 7f 62 '         test    t0,#8 wz        ' ... wrap or scroll
4edc(0154): 58 01 68 5c '  if_z   jmp     #:t_setrow0     ' wrap - set cursor to row zero
4ee0(0155): b8 7b ff 5c '         call    #t_up1          ' scroll - scroll screen up 1 line
4ee4(0156): 01 c0 ff 84 '         sub     t3,#1           ' point back at col pointer
4ee8(0157): 5b 01 7c 5c '         jmp     #:t_setcol0     ' put cursor on col zero
4eec(0158):             ' :t_setrow0
4eec(0158): 00 be ff a0 '         mov     t2,#0           ' set row to zero
4ef0(0159):             ' :t_setrow
4ef0(0159): e0 bf 3f 00 '         wrbyte  t2,t3           ' update row
4ef4(015a): 01 c0 ff 84 '         sub     t3,#1           ' point back to col
4ef8(015b):             ' :t_setcol0
4ef8(015b): 00 bc ff a0 '         mov     t1,#0           ' reset cursor col to zero
4efc(015c):             ' :t_inccol
4efc(015c): e0 bd 3f 00 '         wrbyte  t1,t3           ' update cursor col
4f00(015d):             ' t_inccur_ret
4f00(015d): 00 00 7c 5c '         ret
4f04(015e):             ' t_put5
4f04(015e): 0d c4 7f 86 '         cmp     t5,#$0d wz      ' CR?
4f08(015f): 94 01 68 5c '   if_z  jmp     #:t_cr          ' yes - process CR
4f0c(0160): 0a c4 7f 86 '         cmp     t5,#$0a wz      ' no - LF?
4f10(0161): 85 01 68 5c '   if_z  jmp     #:t_lf          ' yes - process LF
4f14(0162): 0c c4 7f 86 '         cmp     t5,#$0c wz      ' no - FF?
4f18(0163): 7d 01 68 5c '   if_z  jmp     #:t_ff          ' yes - process FF
4f1c(0164): 09 c4 7f 86 '         cmp     t5,#$09 wz      ' no - HT?
4f20(0165): 76 01 68 5c '   if_z  jmp     #:t_ht          ' yes - process HT
4f24(0166): de c4 7f 86 '         cmp     t5,#$DE wz      ' no - CapsLock?
4f28(0167): 96 01 68 5c '   if_z  jmp     #t_put5_ret     ' yes - ignore it
4f2c(0168): 3d 8d fe 5c '         call    #t_scrpos       ' no - get screen pos of cursor
4f30(0169): ec bd bf a0 '         mov     t1,scrclrs      ' get ...
4f34(016a): de bd bf 08 '         rdlong  t1,t1           ' current color data
4f38(016b): 01 bc ff 2c '         shl     t1,#1           ' combine ...
4f3c(016c): e2 bf bf a0 '         mov     t2,t5           ' ... character ...
4f40(016d): 01 be ff 60 '         and     t2,#1           ' ... and ...
4f44(016e): df bd bf 80 '         add     t1,t2           ' ... color ...
4f48(016f): 0a bc ff 2c '         shl     t1,#10          ' ... ready ...
4f4c(0170): fe c4 ff 60 '         and     t5,#$fe         ' ... for ...
4f50(0171): d3 c5 bf 80 '         add     t5,ctrl         ' ... ($200) ...
4f54(0172): de c5 bf 80 '         add     t5,t1           ' ... writing to screen buffer
4f58(0173): dd c5 3f 04 '         wrword  t5,t0           ' write char to screen buffer
4f5c(0174): 47 bb fe 5c '         call    #t_inccur       ' increment cursor
4f60(0175): 96 01 7c 5c '         jmp     #t_put5_ret     ' done
4f64(0176):             ' :t_ht
4f64(0176): e0 bb bf 00 '         rdbyte  t0,t3           ' HT - get cursor col
4f68(0177): 08 ba ff 80 '         add     t0,#8           ' move to next ...
4f6c(0178): 07 ba ff 64 '         andn    t0,#7           ' multiple of 8
4f70(0179): e8 bb 3f 85 '         cmp     t0,scrcols wc   ' past last col?
4f74(017a): e8 bb 8f a0 '   if_ae mov     t0,scrcols      ' yes - point to ...                                                                                            
4f78(017b): 01 ba cf 84 '   if_ae sub     t0,#1           ' ... last col
4f7c(017c): 95 01 7c 5c '         jmp     #:t_setcol      ' set cursor col
4f80(017d):             ' :t_ff
4f80(017d): e9 c7 bf a0 '         mov     t6,scrrows      ' scroll ...
4f84(017e): 01 c6 ff 84 '         sub     t6,#1           ' ... whole ...
4f88(017f): 00 c8 ff a0 '         mov     t7,#0           ' ... screen
4f8c(0180): e9 cb bf a0 '         mov     t8,scrrows      ' ... ALL ...
4f90(0181): 97 6f ff 5c '         call    #t_scroll2      ' ... rows up
4f94(0182): 01 c0 ff 80 '         add     t3,#1           ' set cursor row
4f98(0183): 00 ba ff a0 '         mov     t0,#0           ' ... and col
4f9c(0184): 92 01 7c 5c '         jmp     #:t_setrow      ' ... to zero
4fa0(0185):             ' :t_lf
4fa0(0185): 01 c0 ff 80 '         add     t3,#1           ' LF - get ...
4fa4(0186): e0 bb bf 00 '         rdbyte  t0,t3           ' ... cursor row ...
4fa8(0187): 01 ba ff 80 '         add     t0,#1           ' and increment it
4fac(0188): e9 bb 3f 87 '         cmp     t0,scrrows wz,wc 'are we past last row?
4fb0(0189): 92 01 70 5c '   if_b  jmp     #:t_setrow      ' no - just update row
4fb4(018a): 01 c0 ff 80 '         add     t3,#1           ' yes - check ...
4fb8(018b): e0 bb bf 00 '         rdbyte  t0,t3           ' check cursor mode ...
4fbc(018c): 01 c0 ff 84 '         sub     t3,#1           ' ... for ...
4fc0(018d): 08 ba 7f 62 '         test    t0,#8 wz        ' ... wrap ...
4fc4(018e): 00 ba ff a0 '         mov     t0,#0           ' ... or scroll
4fc8(018f): 92 01 68 5c '  if_z   jmp     #:t_setrow      ' wrap - put cursor on row zero
4fcc(0190): b8 7b ff 5c '         call    #t_up1          ' scroll - scroll screen up 1 line
4fd0(0191): 93 01 7c 5c '         jmp     #:t_setcol0     ' put cursor on col zero
4fd4(0192):             ' :t_setrow
4fd4(0192): e0 bb 3f 00 '         wrbyte  t0,t3           ' write updated row
4fd8(0193):             ' :t_setcol0
4fd8(0193): 01 c0 ff 84 '         sub     t3,#1           ' point at current cursor col
4fdc(0194):             ' :t_cr
4fdc(0194): 00 ba ff a0 '         mov     t0,#0           ' zero current col
4fe0(0195):             ' :t_setcol
4fe0(0195): e0 bb 3f 00 '         wrbyte  t0,t3           ' set current cursor col
4fe4(0196):             ' t_put5_ret
4fe4(0196): 00 00 7c 5c '         ret
4fe8(0197):             ' t_scroll2
4fe8(0197): e4 bd bf a0 '         mov     t1,t7           ' calculate ...
4fec(0198): e8 bf bf a0 '         mov     t2,scrcols      ' ... address ...
4ff0(0199): be 85 ff 5c '         call    #m32            ' ... of ...
4ff4(019a): dd c9 bf a0 '         mov     t7,t0           ' ... first ...
4ff8(019b): 01 c8 ff 2c '         shl     t7,#1           ' (multiply by two as screen is in words)
4ffc(019c): eb c9 bf 80 '         add     t7,scrbuff      ' ... byte on screen to scroll
5000(019d): e3 bd bf a0 '         mov     t1,t6           ' calculate ...
5004(019e): e8 bf bf a0 '         mov     t2,scrcols      ' ... address ...
5008(019f): be 85 ff 5c '         call    #m32            ' ... of ...
500c(01a0): dd c7 bf a0 '         mov     t6,t0           ' ... last ...
5010(01a1): 01 c6 ff 2c '         shl     t6,#1           ' (multiply by two as screen is in words)
5014(01a2): eb c7 bf 80 '         add     t6,scrbuff      ' ... byte on screen to scroll (+1)
5018(01a3):             ' :scr_loop1
5018(01a3): 00 ca 7f 86 '         cmp     t8,#0 wz        ' have we scrolled enough times?
501c(01a4): b7 01 68 5c '  if_z   jmp     #t_scroll2_ret  ' yes - done
5020(01a5): 01 ca ff 84 '         sub     t8,#1           ' no - must scroll more
5024(01a6): e4 bd bf a0 '         mov     t1,t7           ' dst address for line scroll
5028(01a7): e4 bf bf a0 '         mov     t2,t7           ' src address ...
502c(01a8): e8 bf bf 80 '         add     t2,scrcols      ' ... for line scroll
5030(01a9): e8 bf bf 80 '         add     t2,scrcols      ' ... for line scroll
5034(01aa):             ' :scr_loop2
5034(01aa): df bb bf 04 '         rdword  t0,t2           ' move ...
5038(01ab): de bb 3f 04 '         wrword  t0,t1           ' ... screen data ...
503c(01ac): 02 bc ff 80 '         add     t1,#2           ' ... from ...
5040(01ad): 02 be ff 80 '         add     t2,#2           ' ... src to dst
5044(01ae): e3 bd 3f 87 '         cmp     t1,t6 wz,wc     ' moved all data?
5048(01af): aa 01 70 5c '  if_b   jmp     #:scr_loop2     ' no - keep moving data
504c(01b0): d5 bb bf a0 '         mov     t0,space        ' yes - fill last line with spaces
5050(01b1): e3 bd bf a0 '         mov     t1,t6           ' point to start of last line
5054(01b2): e8 c5 bf a0 '         mov     t5,scrcols      ' number of columns to fill
5058(01b3):             ' :scr_loop3
5058(01b3): de bb 3f 04 '         wrword  t0,t1           ' fill line ...
505c(01b4): 02 bc ff 80 '         add     t1,#2           ' ... with ...
5060(01b5): b3 c5 ff e4 '         djnz    t5,#:scr_loop3  ' ... spaces
5064(01b6): a3 01 7c 5c '         jmp     #:scr_loop1     ' scroll more
5068(01b7):             ' t_scroll2_ret
5068(01b7): 00 00 7c 5c '         ret
506c(01b8):             ' t_up1
506c(01b8): e9 c7 bf a0 '         mov     t6,scrrows      ' scroll ...
5070(01b9): 01 c6 ff 84 '         sub     t6,#1           ' ... whole ...
5074(01ba): 00 c8 ff a0 '         mov     t7,#0           ' ... screen
5078(01bb): 01 ca ff a0 '         mov     t8,#1           ' ... one ...
507c(01bc): 97 6f ff 5c '         call    #t_scroll2      ' ... row up
5080(01bd):             ' t_up1_ret
5080(01bd): 00 00 7c 5c '         ret
5084(01be):             ' m32
5084(01be): 00 ba ff a0 '         mov t0,#0
5088(01bf): c2 bf 7f ec '         tjz t2,#m32_ret
508c(01c0):             ' :m32_loop
508c(01c0): de bb bf 80 '         add t0,t1
5090(01c1): c0 bf ff e4 '         djnz t2,#:m32_loop
5094(01c2):             ' m32_ret
5094(01c2): 00 00 7c 5c '         ret
5098(01c3):             ' d32u
5098(01c3): 20 cc ff a0 '         mov d1,#32
509c(01c4): 00 ce ff a0 '         mov d2, #0
50a0(01c5):             ' :d32up
50a0(01c5): 01 ba ff 2d '         shl t0,#1    WC
50a4(01c6): 01 ce ff 35 '         rcl d2,#1    WC
50a8(01c7): e7 bd 3f 87 '         cmp t1,d2    WC,WZ
50ac(01c8): cb 01 44 5c '  if_a   jmp #:d32down
50b0(01c9): de cf bf 84 '         sub d2,t1
50b4(01ca): 01 ba ff 80 '         add t0,#1
50b8(01cb):             ' :d32down
50b8(01cb): 01 cc ff 86 '         sub d1, #1   WZ
50bc(01cc): c5 01 54 5c '  if_ne  jmp #:d32up
50c0(01cd): e7 bd bf a0 '         mov t1,d2
50c4(01ce):             ' d32u_ret
50c4(01ce): 00 00 7c 5c '         ret
50c8(01cf): 00 00 80 00 ' curs_1  long     $00800000
50cc(01d0): ff ff 7f 00 ' low23   long     $007FFFFF
50d0(01d1): ff ff ff 00 ' low24   long     $00ffffff
50d4(01d2): 00 ca 9a 3b ' maxdec  long     1000000000     ' maximum decimal divisor for 32 bit values
50d8(01d3): 00 02 00 00 ' ctrl    long     $00000200      ' mask to detect control keys
50dc(01d4): 00 fd ff ff ' noctrl  long     $fffffd00      ' mask to correct control keys
50e0(01d5): 20 02 00 00 ' space   long     $00000220      ' space used when filling
50e4(01d6): 00 00 00 00 ' ppkbd   long     0
50e8(01d7): 00 00 00 00 ' ppmouse long     0
50ec(01d8): 00 00 00 00 ' ppscrn  long     0
50f0(01d9):             ' rqstptr res      1      ' address of my request block
50f0(01da):             ' rsltptr res      1      ' address to put results
50f0(01db):             ' rqst    res      1      ' request being processed
50f0(01dc):             ' rslt    res      1      ' result to return
50f0(01dd):             ' t0      res      1
50f0(01de):             ' t1      res      1
50f0(01df):             ' t2      res      1
50f0(01e0):             ' t3      res      1
50f0(01e1):             ' t4      res      1
50f0(01e2):             ' t5      res      1
50f0(01e3):             ' t6      res      1
50f0(01e4):             ' t7      res      1
50f0(01e5):             ' t8      res      1
50f0(01e6):             ' d1      res      1      ' used when dividing
50f0(01e7):             ' d2      res      1      ' used when dividing
50f0(01e8):             ' scrcols res      1      ' screen cols
50f0(01e9):             ' scrrows res      1      ' screen rows
50f0(01ea):             ' scrsize res      1      ' screen size
50f0(01eb):             ' scrbuff res      1      ' pointer to screen buffer
50f0(01ec):             ' scrclrs res      1      ' current color data
50f0(01ed):             ' scrpall res      1      ' pointer to screen palette
50f0(01ee):             ' scrcurs res      1      ' pointer to screen cursors
50f0(01ef): 07 0a       ' palette byte    $07,   $0A    '0    white / dark blue
50f2(----): 07 bb       '         byte    $07,   $BB    '1    white / red
50f4(01f0): 9e 9b       '         byte    $9E,   $9B    '2   yellow / brown
50f6(----): 04 07       '         byte    $04,   $07    '3     grey / white
50f8(01f1): 3d 3b       '         byte    $3D,   $3B    '4     cyan / dark cyan
50fa(----): 6b 6e       '         byte    $6B,   $6E    '5    green / gray-green
50fc(01f2): bb ce       '         byte    $BB,   $CE    '6      red / pink
50fe(----): 3c 0a       '         byte    $3C,   $0A    '7     cyan / blue
'========================= Method #1: PUB ProxySetup ==========================
'PUB ProxySetup(io_block, proxy_lock, server_cpu)
'------------------------------------------------------------------------------
  v_io_block     := io_block
'------------------------------------------------------------------------------
5100: 64             PUSH 	Locals+4
5101: 41             POP  	VAR+0
'------------------------------------------------------------------------------
  v_proxy_lock   := proxy_lock
'------------------------------------------------------------------------------
5102: 68             PUSH 	Locals+8
5103: 45             POP  	VAR+4
'------------------------------------------------------------------------------
  v_Server_cpu   := server_cpu
'------------------------------------------------------------------------------
5104: 6c             PUSH 	Locals+12
5105: 49             POP  	VAR+8
5106: 32             RETURN	
'=========================== Method #2: PUB Start =============================
'PUB Start (registry, data, start_kbd, start_mouse, start_screen) : ok | i, prqst, fore, back, pkbd, pmouse, pscreen, ptv, px_pkbd, px_pmouse, px_pscreen, px_ptv, px_ioblk, px_lock, px_cpu, cog 
'------------------------------------------------------------------------------
  pkbd    := data  
'------------------------------------------------------------------------------
5107: 68             PUSH 	Locals+8
5108: cd 28          POP.L	Locals+40
'------------------------------------------------------------------------------
  pmouse  := pkbd    + 4 * kbd#kb_count
'------------------------------------------------------------------------------
510a: cc 28          PUSH.L	Locals+40
510c: 37 01          PUSH#kp	4 ($4)
510e: 38 14          PUSH#k1	20
5110: f4             MPY  	
5111: ec             ADD  	
5112: cd 2c          POP.L	Locals+44
'------------------------------------------------------------------------------
  pscreen := pmouse  + 4 * mouse#m_count
'------------------------------------------------------------------------------
5114: cc 2c          PUSH.L	Locals+44
5116: 37 01          PUSH#kp	4 ($4)
5118: 38 0a          PUSH#k1	10
511a: f4             MPY  	
511b: ec             ADD  	
511c: cd 30          POP.L	Locals+48
'------------------------------------------------------------------------------
  ptv     := pscreen + 4 * sc_count 
'------------------------------------------------------------------------------
511e: cc 30          PUSH.L	Locals+48
5120: 37 01          PUSH#kp	4 ($4)
5122: 39 02 6d       PUSH#k2	621
5125: f4             MPY  	
5126: ec             ADD  	
5127: cd 34          POP.L	Locals+52
'------------------------------------------------------------------------------
  long[pscreen][nx] := cols
'------------------------------------------------------------------------------
5129: 38 28          PUSH#k1	40
512b: cc 30          PUSH.L	Locals+48
512d: 35             PUSH#0	
512e: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[pscreen][ny] := rows
'------------------------------------------------------------------------------
512f: 38 1e          PUSH#k1	30
5131: cc 30          PUSH.L	Locals+48
5133: 36             PUSH#1	
5134: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[pscreen][color] := 0 
'------------------------------------------------------------------------------
5135: 35             PUSH#0	
5136: cc 30          PUSH.L	Locals+48
5138: 37 00          PUSH#kp	2 ($2)
513a: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  byte[pscreen][cm1] := %1001
'------------------------------------------------------------------------------
513b: 38 09          PUSH#k1	9
513d: cc 30          PUSH.L	Locals+48
513f: 39 09 b1       PUSH#k2	2481
5142: 91             POP.B	Mem[][]
'------------------------------------------------------------------------------
  repeat i from 0 to 7
'------------------------------------------------------------------------------
5143: 35             PUSH#0	
5144: 79             POP  	Locals+24
'------------------------------------------------------------------------------
    fore := byte[@palette][i << 1]
'------------------------------------------------------------------------------
5145: 87 87 80       PUSH#.B	OBJ+1920
5148: 78             PUSH 	Locals+24
5149: 36             PUSH#1	
514a: e3             SHL  	
514b: 90             PUSH.B	Mem[][]
514c: cd 20          POP.L	Locals+32
'------------------------------------------------------------------------------
    back := byte[@palette][i << 1 + 1]
'------------------------------------------------------------------------------
514e: 87 87 80       PUSH#.B	OBJ+1920
5151: 78             PUSH 	Locals+24
5152: 36             PUSH#1	
5153: e3             SHL  	
5154: 36             PUSH#1	
5155: ec             ADD  	
5156: 90             PUSH.B	Mem[][]
5157: cd 24          POP.L	Locals+36
'------------------------------------------------------------------------------
    long[pscreen][colors + i << 1]     := fore << 24 + back << 16 + fore << 8 + back
'------------------------------------------------------------------------------
5159: cc 20          PUSH.L	Locals+32
515b: 38 18          PUSH#k1	24
515d: e3             SHL  	
515e: cc 24          PUSH.L	Locals+36
5160: 37 03          PUSH#kp	16 ($10)
5162: e3             SHL  	
5163: ec             ADD  	
5164: cc 20          PUSH.L	Locals+32
5166: 37 02          PUSH#kp	8 ($8)
5168: e3             SHL  	
5169: ec             ADD  	
516a: cc 24          PUSH.L	Locals+36
516c: ec             ADD  	
516d: cc 30          PUSH.L	Locals+48
516f: 39 02 5b       PUSH#k2	603
5172: 78             PUSH 	Locals+24
5173: 36             PUSH#1	
5174: e3             SHL  	
5175: ec             ADD  	
5176: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
    long[pscreen][colors + i << 1 + 1] := fore << 24 + fore << 16 + back << 8 + back
'------------------------------------------------------------------------------
5177: cc 20          PUSH.L	Locals+32
5179: 38 18          PUSH#k1	24
517b: e3             SHL  	
517c: cc 20          PUSH.L	Locals+32
517e: 37 03          PUSH#kp	16 ($10)
5180: e3             SHL  	
5181: ec             ADD  	
5182: cc 24          PUSH.L	Locals+36
5184: 37 02          PUSH#kp	8 ($8)
5186: e3             SHL  	
5187: ec             ADD  	
5188: cc 24          PUSH.L	Locals+36
518a: ec             ADD  	
518b: cc 30          PUSH.L	Locals+48
518d: 39 02 5b       PUSH#k2	603
5190: 78             PUSH 	Locals+24
5191: 36             PUSH#1	
5192: e3             SHL  	
5193: ec             ADD  	
5194: 36             PUSH#1	
5195: ec             ADD  	
5196: d1             POP.L	Mem[][]
5197: 35             PUSH#0	
5198: 37 22          PUSH#kp	7 ($7)
519a: 7a 02 ff a7    USING	Locals+24, RPTINCJ .-89 (dest:$5145)
'------------------------------------------------------------------------------
  repeat i from 0 to chrs/2 - 1
'------------------------------------------------------------------------------
519e: 35             PUSH#0	
519f: 79             POP  	Locals+24
'------------------------------------------------------------------------------
    long[pscreen][buffer + i] := $02200220
'------------------------------------------------------------------------------
51a0: 3b 02 20 02 20 PUSH#k4	35652128
51a5: cc 30          PUSH.L	Locals+48
51a7: 37 21          PUSH#kp	3 ($3)
51a9: 78             PUSH 	Locals+24
51aa: ec             ADD  	
51ab: d1             POP.L	Mem[][]
51ac: 35             PUSH#0	
51ad: 39 04 b0       PUSH#k2	1200
51b0: 37 00          PUSH#kp	2 ($2)
51b2: f6             DIV  	
51b3: 36             PUSH#1	
51b4: ed             SUB  	
51b5: 7a 02 68       USING	Locals+24, RPTINCJ .-24 (dest:$51a0)
'------------------------------------------------------------------------------
  if start_kbd
'------------------------------------------------------------------------------
51b8: 6c             PUSH 	Locals+12
51b9: 0a 08          JPF  	.+8 (dest:$51c3)
'------------------------------------------------------------------------------
    kbd.start(pkbd, common#KBD_PIN)
'------------------------------------------------------------------------------
51bb: 01             FRAME	Call without return value	
51bc: cc 28          PUSH.L	Locals+40
51be: 38 1a          PUSH#k1	26
51c0: 06 03 01       CALLOBJ	3:1
'------------------------------------------------------------------------------
  px_pkbd := 0
'------------------------------------------------------------------------------
51c3: 35             PUSH#0	
51c4: cd 38          POP.L	Locals+56
'------------------------------------------------------------------------------
  if start_mouse
'------------------------------------------------------------------------------
51c6: 70             PUSH 	Locals+16
51c7: 0a 08          JPF  	.+8 (dest:$51d1)
'------------------------------------------------------------------------------
    mouse.start(pmouse, common#MOUSE_PIN)
'------------------------------------------------------------------------------
51c9: 01             FRAME	Call without return value	
51ca: cc 2c          PUSH.L	Locals+44
51cc: 38 18          PUSH#k1	24
51ce: 06 04 01       CALLOBJ	4:1
'------------------------------------------------------------------------------
  px_pmouse := 0
'------------------------------------------------------------------------------
51d1: 35             PUSH#0	
51d2: cd 3c          POP.L	Locals+60
'------------------------------------------------------------------------------
  if start_screen
'------------------------------------------------------------------------------
51d4: 74             PUSH 	Locals+20
51d5: 0a 19          JPF  	.+25 (dest:$51f0)
'------------------------------------------------------------------------------
    screen.start(ptv, common#TV_PIN, @long[pscreen][buffer], @long[pscreen][colors], NTSC_PAL, INTERLACE, cols, rows)
'------------------------------------------------------------------------------
51d7: 01             FRAME	Call without return value	
51d8: cc 34          PUSH.L	Locals+52
51da: 38 0c          PUSH#k1	12
51dc: cc 30          PUSH.L	Locals+48
51de: 37 21          PUSH#kp	3 ($3)
51e0: d3             PUSH#.L	Mem[][]
51e1: cc 30          PUSH.L	Locals+48
51e3: 39 02 5b       PUSH#k2	603
51e6: d3             PUSH#.L	Mem[][]
51e7: 36             PUSH#1	
51e8: 36             PUSH#1	
51e9: 38 28          PUSH#k1	40
51eb: 38 1e          PUSH#k1	30
51ed: 06 05 01       CALLOBJ	5:1
'------------------------------------------------------------------------------
  px_pscreen := 0
'------------------------------------------------------------------------------
51f0: 35             PUSH#0	
51f1: cd 40          POP.L	Locals+64
'------------------------------------------------------------------------------
  cog := cognew(@HmiStart, registry)
'------------------------------------------------------------------------------
51f3: 34             PUSH#-1	
51f4: c7 1c          PUSH#.L	OBJ+28
51f6: 64             PUSH 	Locals+4
51f7: 28             COGIFUN	
51f8: cd 54          POP.L	Locals+84
'------------------------------------------------------------------------------
  ok := (cog => 0)
'------------------------------------------------------------------------------
51fa: cc 54          PUSH.L	Locals+84
51fc: 35             PUSH#0	
51fd: fe             GE   	
51fe: 61             POP  	Locals+0
'------------------------------------------------------------------------------
  if ok
'------------------------------------------------------------------------------
51ff: 60             PUSH 	Locals+0
5200: 0a 16          JPF  	.+22 (dest:$5218)
'------------------------------------------------------------------------------
    common.SendInitializationData(cog, @pkbd, 0)
'------------------------------------------------------------------------------
5202: 01             FRAME	Call without return value	
5203: cc 54          PUSH.L	Locals+84
5205: cf 28          PUSH#.L	Locals+40
5207: 35             PUSH#0	
5208: 06 06 04       CALLOBJ	6:4
'------------------------------------------------------------------------------
    common.WaitForRequest(cog)
'------------------------------------------------------------------------------
520b: 01             FRAME	Call without return value	
520c: cc 54          PUSH.L	Locals+84
520e: 06 06 05       CALLOBJ	6:5
'------------------------------------------------------------------------------
    common.Register(cog, common#LMM_HMI) 
'------------------------------------------------------------------------------
5211: 01             FRAME	Call without return value	
5212: cc 54          PUSH.L	Locals+84
5214: 36             PUSH#1	
5215: 06 06 02       CALLOBJ	6:2
5218: 32             RETURN	
5219: 00 00 00    

'******************************************************************************
'                         Catalina_comboKeyboard.spin                          
'******************************************************************************

'=================================== CONs =====================================
kb_count = 20
par_keys = 11
'=============================== Object Header ================================
521c: 20 05 04 00 ' 1312 bytes, 4-1 methods, 0 object pointers
5220: fc 04 00 00 ' ptr #1 to $5718: PUB start (locals size: 0)
5224: 07 05 04 00 ' ptr #2 to $5723: PUB startx (locals size: 4)
5228: 1a 05 00 00 ' ptr #3 to $5736: PUB BlockSize (locals size: 0)
'================================ DAT Section =================================
522c(0000):             '                         org
522c(0000): 4e 09 fc 54 ' entry                   movd    :par,#_pingroup         'load input parameters _pingroup/_locks/_auto
5230(0001): f0 83 be a0 '                         mov     x,par
5234(0002): 2c 82 fe 80 '                         add     x,#11*4
5238(0003): 03 84 fe a0 '                         mov     y,#3
523c(0004): 41 01 bc 08 ' :par                    rdlong  0,x
5240(0005): e7 08 bc 80 '                         add     :par,dlsb
5244(0006): 04 82 fe 80 '                         add     x,#4
5248(0007): 04 84 fe e4 '                         djnz    y,#:par
524c(0008): 4e 83 be a0 '                         mov     x,_pingroup             'get mask for 1st pin
5250(0009): 01 82 fe 64 '                         andn    x,#1
5254(000a): 01 9c 7e 62 '                         test    _pingroup,#1    wz
5258(000b): 01 76 fe a0 '                         mov     dwmask,#1
525c(000c): 41 77 be 2c '                         shl     dwmask,x
5260(000d): 3b 79 be a0 '                         mov     drmask,dwmask
5264(000e): 01 78 d6 2c '         if_nz           shl     drmask,#1
5268(000f): 3c 7b be a0 '                         mov     cwmask,drmask
526c(0010): 01 7a fe 2c '                         shl     cwmask,#1
5270(0011): 3d 7d be a0 '                         mov     crmask,cwmask
5274(0012): 01 7c d6 2c '         if_nz           shl     crmask,#1
5278(0013): 3b ed 97 68 '         if_nz           or      dira,dwmask             'set directions
527c(0014): 3d ed 97 68 '         if_nz           or      dira,cwmask
5280(0015): 00 88 fe a0 '                         mov     _head,#0                'reset output parameter _head
5284(0016): 01 9c 7e 62 ' reset                   test    _pingroup,#1    wz
5288(0017): 3b e9 97 64 '         if_nz           andn    outa,dwmask             'let PS/2 lines float (pulled up)
528c(0018): 3d e9 97 64 '         if_nz           andn    outa,cwmask
5290(0019): 00 ec eb a0 '         if_z            mov     dira,#0
5294(001a): 45 39 fc 54 '                         movd    :par,#_present          'reset output parameters _present/_states[8]
5298(001b): 09 82 fe a0 '                         mov     x,#1+8
529c(001c): 00 00 fc a0 ' :par                    mov     0,#0
52a0(001d): e7 38 bc 80 '                         add     :par,dlsb
52a4(001e): 1c 82 fe e4 '                         djnz    x,#:par
52a8(001f): 08 7e fe a0 '                         mov     stat,#8                 'set reset flag
52ac(0020): 44 49 fc 54 ' update                  movd    :par,#_head             'update output parameters _head/_present/_states[8]
52b0(0021): f0 83 be a0 '                         mov     x,par
52b4(0022): 04 82 fe 80 '                         add     x,#1*4
52b8(0023): 0a 84 fe a0 '                         mov     y,#1+1+8
52bc(0024): 41 01 3c 08 ' :par                    wrlong  0,x
52c0(0025): e7 48 bc 80 '                         add     :par,dlsb
52c4(0026): 04 82 fe 80 '                         add     x,#4
52c8(0027): 24 84 fe e4 '                         djnz    y,#:par
52cc(0028): 08 7e 7e 61 '                         test    stat,#8         wc      'if reset flag, transmit reset command
52d0(0029): ff 80 f2 a0 '         if_c            mov     data,#$FF
52d4(002a): a6 88 f1 5c '         if_c            call    #transmit
52d8(002b): 00 7e fe a0 ' newcode                 mov     stat,#0                 'reset state
52dc(002c): c5 a6 fd 5c ' :same                   call    #receive                'receive byte from keyboard
52e0(002d): 84 80 7e 85 '                         cmp     data,#$83+1     wc      'scancode?
52e4(002e): aa 80 4e 86 '         if_nc           cmp     data,#$AA       wz      'powerup/reset?
52e8(002f): 8a 00 48 5c '         if_nc_and_z     jmp     #configure
52ec(0030): e0 80 4e 86 '         if_nc           cmp     data,#$E0       wz      'extended?
52f0(0031): 01 7e ca 68 '         if_nc_and_z     or      stat,#1
52f4(0032): 2c 00 48 5c '         if_nc_and_z     jmp     #:same
52f8(0033): f0 80 4e 86 '         if_nc           cmp     data,#$F0       wz      'released?
52fc(0034): 02 7e ca 68 '         if_nc_and_z     or      stat,#2
5300(0035): 2c 00 48 5c '         if_nc_and_z     jmp     #:same
5304(0036): 2b 00 4c 5c '         if_nc           jmp     #newcode                'unknown, ignore
5308(0037): 01 7e 7e 61 '                         test    stat,#1         wc      'lookup code with extended flag
530c(0038): 01 80 fe 34 '                         rcl     data,#1
5310(0039): 9e a6 fd 5c '                         call    #look
5314(003a): 00 80 7e 86 '                         cmp     data,#0         wz      'if unknown, ignore
5318(003b): 2b 00 68 5c '         if_z            jmp     #newcode
531c(003c): 4c 87 be a0 '                         mov     t,_states+6             'remember lock keys in _states
5320(003d): 40 83 be a0 '                         mov     x,data                  'set/clear key bit in _states
5324(003e): 05 82 fe 28 '                         shr     x,#5
5328(003f): 46 83 fe 80 '                         add     x,#_states
532c(0040): 41 89 bc 54 '                         movd    :reg,x
5330(0041): 01 84 fe a0 '                         mov     y,#1
5334(0042): 40 85 be 2c '                         shl     y,data
5338(0043): 02 7e 7e 61 '                         test    stat,#2         wc
533c(0044): 42 01 bc 74 ' :reg                    muxnc   0,y
5340(0045): f0 80 ce e1 '         if_nc           cmpsub  data,#$F0       wc      'if released or shift/ctrl/alt/win, done
5344(0046): 20 00 70 5c '         if_c            jmp     #update
5348(0047): 4d 85 be a0 '                         mov     y,_states+7             'get shift/ctrl/alt/win bit pairs
534c(0048): 10 84 fe 28 '                         shr     y,#16
5350(0049): e0 80 fe e1 '                         cmpsub  data,#$E0       wc      'translate keypad, considering numlock
5354(004a): 04 9e 72 62 '         if_c            test    _locks,#%100    wz
5358(004b): 08 81 e2 80 '         if_c_and_z      add     data,#@keypad1-@table
535c(004c): 18 81 d2 80 '         if_c_and_nz     add     data,#@keypad2-@table
5360(004d): 9e a6 f1 5c '         if_c            call    #look
5364(004e): 6c 00 70 5c '         if_c            jmp     #:flags
5368(004f): dd 80 fe e1 '                         cmpsub  data,#$DD       wc      'handle scrlock/capslock/numlock
536c(0050): 08 82 f2 a0 '         if_c            mov     x,#%001_000
5370(0051): 40 83 b2 2c '         if_c            shl     x,data
5374(0052): 4f 83 b2 64 '         if_c            andn    x,_locks
5378(0053): 03 82 f2 28 '         if_c            shr     x,#3
537c(0054): 1d 86 f2 28 '         if_c            shr     t,#29                   'ignore auto-repeat
5380(0055): 43 83 b2 66 '         if_c            andn    x,t             wz
5384(0056): 41 9f b2 6c '         if_c            xor     _locks,x
5388(0057): dd 80 f2 80 '         if_c            add     data,#$DD
538c(0058): 04 7e d2 68 '         if_c_and_nz     or      stat,#4                 'if change, set configure flag to update leds
5390(0059): 03 84 7e 62 '                         test    y,#%11          wz      'get shift into nz
5394(005a): 61 80 56 85 '         if_nz           cmp     data,#$60+1     wc      'check shift1
5398(005b): 5b 80 d2 e1 '         if_nz_and_c     cmpsub  data,#$5B       wc
539c(005c): 28 81 d2 80 '         if_nz_and_c     add     data,#@shift1-@table
53a0(005d): 9e a6 d1 5c '         if_nz_and_c     call    #look
53a4(005e): 03 84 d2 64 '         if_nz_and_c     andn    y,#%11
53a8(005f): 3e 80 56 85 '         if_nz           cmp     data,#$3D+1     wc      'check shift2
53ac(0060): 27 80 d2 e1 '         if_nz_and_c     cmpsub  data,#$27       wc
53b0(0061): 2e 81 d2 80 '         if_nz_and_c     add     data,#@shift2-@table
53b4(0062): 9e a6 d1 5c '         if_nz_and_c     call    #look
53b8(0063): 03 84 d2 64 '         if_nz_and_c     andn    y,#%11
53bc(0064): 02 9e 7e 61 '                         test    _locks,#%010    wc      'check shift-alpha, considering capslock
53c0(0065): 20 d4 fc 74 '                         muxnc   :shift,#$20
53c4(0066): 40 9e 7e 61 '                         test    _locks,#$40     wc
53c8(0067): 20 d4 c4 6c '         if_nz_and_nc    xor     :shift,#$20
53cc(0068): 7b 80 7e 85 '                         cmp     data,#"z"+1     wc
53d0(0069): 61 80 f2 e1 '         if_c            cmpsub  data,#"a"       wc
53d4(006a): 41 80 f2 80 ' :shift  if_c            add     data,#"A"
53d8(006b): 03 84 f2 64 '         if_c            andn    y,#%11
53dc(006c): 08 80 fe 20 ' :flags                  ror     data,#8                 'add shift/ctrl/alt/win flags
53e0(006d): 04 82 fe a0 '                         mov     x,#4                    '+$100 if shift
53e4(006e): 03 84 7e 62 ' :loop                   test    y,#%11          wz      '+$200 if ctrl
53e8(006f): 02 84 fe 28 '                         shr     y,#2                    '+$400 if alt
53ec(0070): 01 80 d6 68 '         if_nz           or      data,#1                 '+$800 if win
53f0(0071): 01 80 fe 20 '                         ror     data,#1
53f4(0072): 6e 82 fe e4 '                         djnz    x,#:loop
53f8(0073): 0c 80 fe 24 '                         rol     data,#12
53fc(0074): f0 83 be a0 '                         mov     x,par                   'check for a "break key" key code
5400(0075): 4c 82 fe 80 '                         add     x,#19*4                 '@par_break - @par_head
5404(0076): 41 85 be 06 '                         rdword  y,x             wz
5408(0077): 7c 00 68 5c '         if_z            jmp     #:storekey
540c(0078): 40 85 3e 86 '                         cmp     y,data          wz      'if match, don't store in buffer
5410(0079): 10 84 ea 2c '         if_e            shl     y,#16                   ' but do store in high order word
5414(007a): 41 85 2a 08 '         if_e            wrlong  y,x                     '  of par_break and zero the low
5418(007b): 88 00 68 5c '         if_e            jmp     #:gotbreak              '   order word so test is once only
541c(007c): f0 83 be 08 ' :storekey               rdlong  x,par                   'if room in buffer and key valid, enter
5420(007d): 01 82 fe 84 '                         sub     x,#1
5424(007e): 0f 82 fe 60 '                         and     x,#$F
5428(007f): 44 83 3e 86 '                         cmp     x,_head         wz
542c(0080): ff 80 56 62 '         if_nz           test    data,#$FF       wz
5430(0081): f0 83 96 a0 '         if_nz           mov     x,par
5434(0082): 2c 82 d6 80 '         if_nz           add     x,#11*4
5438(0083): 44 83 96 80 '         if_nz           add     x,_head
543c(0084): 44 83 96 80 '         if_nz           add     x,_head
5440(0085): 41 81 16 04 '         if_nz           wrword  data,x
5444(0086): 01 88 d6 80 '         if_nz           add     _head,#1
5448(0087): 0f 88 d6 60 '         if_nz           and     _head,#$F
544c(0088): 04 7e 7e 61 ' :gotbreak               test    stat,#4         wc      'if not configure flag, done
5450(0089): 20 00 4c 5c '         if_nc           jmp     #update                 'else configure to update leds
5454(008a): f3 80 fe a0 ' configure               mov     data,#$F3               'set keyboard auto-repeat
5458(008b): a6 88 fd 5c '                         call    #transmit
545c(008c): 50 81 be a0 '                         mov     data,_auto
5460(008d): 7f 80 fe 60 '                         and     data,#%11_11111
5464(008e): a6 88 fd 5c '                         call    #transmit
5468(008f): ed 80 fe a0 '                         mov     data,#$ED               'set keyboard lock-leds
546c(0090): a6 88 fd 5c '                         call    #transmit
5470(0091): 4f 81 be a0 '                         mov     data,_locks
5474(0092): 1d 80 fe 3c '                         rev     data,#-3 & $1F
5478(0093): 04 80 7e 61 '                         test    data,#%100      wc
547c(0094): 01 80 fe 34 '                         rcl     data,#1
5480(0095): 07 80 fe 60 '                         and     data,#%111
5484(0096): a6 88 fd 5c '                         call    #transmit
5488(0097): 4f 83 be a0 '                         mov     x,_locks                'insert locks into _states
548c(0098): 07 82 fe 60 '                         and     x,#%111
5490(0099): 03 9a fe 2c '                         shl     _states+7,#3
5494(009a): 41 9b be 68 '                         or      _states+7,x
5498(009b): 03 9a fe 20 '                         ror     _states+7,#3
549c(009c): 01 8a fe a0 '                         mov     _present,#1             'set _present
54a0(009d): 20 00 7c 5c '                         jmp     #update                 'done
54a4(009e): 02 80 fe 20 ' look                    ror     data,#2                 'perform lookup
54a8(009f): 40 47 bd 50 '                         movs    :reg,data
54ac(00a0): e9 46 fd 80 '                         add     :reg,#table
54b0(00a1): 1b 80 fe 28 '                         shr     data,#27
54b4(00a2): 40 83 be a0 '                         mov     x,data
54b8(00a3): 00 80 be a0 ' :reg                    mov     data,0
54bc(00a4): 41 81 be 28 '                         shr     data,x
54c0(00a5): d2 00 7c 5c '                         jmp     #rand                   'isolate byte
54c4(00a6): 01 9c 7e 62 ' transmit                test    _pingroup,#1    wz
54c8(00a7): 3d ed ab 68 '         if_z            or      dira,cwmask
54cc(00a8): 3d e9 97 68 '         if_nz           or      outa,cwmask             'pull clock low
54d0(00a9): 0d c4 fd 50 '                         movs    napshr,#13              'hold clock for ~128us (must be >100us)
54d4(00aa): e1 cc fd 5c '                         call    #nap
54d8(00ab): 3b ed ab 68 '         if_z            or      dira,dwmask
54dc(00ac): 3b e9 97 68 '         if_nz           or      outa,dwmask             'pull data low
54e0(00ad): 12 c4 fd 50 '                         movs    napshr,#18              'hold data for ~4us
54e4(00ae): e1 cc fd 5c '                         call    #nap
54e8(00af): 3d ed ab 6c '         if_z            xor     dira,cwmask
54ec(00b0): 3d e9 97 64 '         if_nz           andn    outa,cwmask             'release clock
54f0(00b1): ff 80 7e 61 '                         test    data,#$0FF      wc      'append parity and stop bits to byte
54f4(00b2): 00 81 fe 74 '                         muxnc   data,#$100
54f8(00b3): e7 80 be 68 '                         or      data,dlsb
54fc(00b4): 0a 82 fe a0 '                         mov     x,#10                   'ready 10 bits
5500(00b5): d4 b8 fd 5c ' transmit_bit            call    #wait_c0                'wait until clock low
5504(00b6): 01 80 fe 29 '                         shr     data,#1         wc      'output data bit
5508(00b7): 01 9c 7e 62 '                         test    _pingroup,#1    wz
550c(00b8): 3b ed ab 74 '         if_z            muxnc   dira,dwmask
5510(00b9): 3b e9 97 74 '         if_nz           muxnc   outa,dwmask
5514(00ba): de b4 bd a0 '                         mov     wcond,c1                'wait until clock high
5518(00bb): d5 b8 fd 5c '                         call    #wait
551c(00bc): b5 82 fe e4 '                         djnz    x,#transmit_bit         'another bit?
5520(00bd): df b4 bd a0 '                         mov     wcond,c0d0              'wait until clock and data low
5524(00be): d5 b8 fd 5c '                         call    #wait
5528(00bf): e0 b4 bd a0 '                         mov     wcond,c1d1              'wait until clock and data high
552c(00c0): d5 b8 fd 5c '                         call    #wait
5530(00c1): c6 a6 fd 5c '                         call    #receive_ack            'receive ack byte with timed wait
5534(00c2): fa 80 7e 86 '                         cmp     data,#$FA       wz      'if ack error, reset keyboard
5538(00c3): 16 00 54 5c '         if_nz           jmp     #reset
553c(00c4): 00 00 7c 5c ' transmit_ret            ret
5540(00c5): 3e 7d 3e f4 ' receive                 waitpne crmask,crmask           'wait indefinitely for initial clock low
5544(00c6): 0b 82 fe a0 ' receive_ack             mov     x,#11                   'ready 11 bits
5548(00c7): d4 b8 fd 5c ' receive_bit             call    #wait_c0                'wait until clock low
554c(00c8): 10 c4 fd 50 '                         movs    napshr,#16              'pause ~16us
5550(00c9): e1 cc fd 5c '                         call    #nap
5554(00ca): f2 79 3e 61 '                         test    drmask,ina      wc      'input data bit
5558(00cb): 01 80 fe 30 '                         rcr     data,#1
555c(00cc): de b4 bd a0 '                         mov     wcond,c1                'wait until clock high
5560(00cd): d5 b8 fd 5c '                         call    #wait
5564(00ce): c7 82 fe e4 '                         djnz    x,#receive_bit          'another bit?
5568(00cf): 16 80 fe 28 '                         shr     data,#22                'align byte
556c(00d0): ff 81 7e 61 '                         test    data,#$1FF      wc      'if parity error, reset keyboard
5570(00d1): 16 00 4c 5c '         if_nc           jmp     #reset
5574(00d2): ff 80 fe 60 ' rand                    and     data,#$FF               'isolate byte
5578(00d3):             ' look_ret
5578(00d3):             ' receive_ack_ret
5578(00d3): 00 00 7c 5c ' receive_ret             ret
557c(00d4): dd b4 bd a0 ' wait_c0                 mov     wcond,c0                '(wait until clock low)
5580(00d5): e8 84 be a0 ' wait                    mov     y,tenms                 'set timeout to 10ms
5584(00d6): 12 c4 fd 50 ' wloop                   movs    napshr,#18              'nap ~4us
5588(00d7): e1 cc fd 5c '                         call    #nap
558c(00d8): f2 7d 3e 61 '                         test    crmask,ina      wc      'check required state(s)
5590(00d9): f2 79 3e 62 '                         test    drmask,ina      wz      'loop until got state(s) or timeout
5594(00da): d6 84 c2 e4 ' wcond   if_never        djnz    y,#wloop                '(replaced with c0/c1/c0d0/c1d1)
5598(00db): 16 84 7e ec '                         tjz     y,#reset                'if timeout, reset keyboard
559c(00dc):             ' wait_ret
559c(00dc): 00 00 7c 5c ' wait_c0_ret             ret
55a0(00dd): d6 84 f2 e4 ' c0      if_c            djnz    y,#wloop                '(if_never replacements)
55a4(00de): d6 84 ce e4 ' c1      if_nc           djnz    y,#wloop
55a8(00df): d6 84 f6 e4 ' c0d0    if_c_or_nz      djnz    y,#wloop
55ac(00e0): d6 84 ee e4 ' c1d1    if_nc_or_z      djnz    y,#wloop
55b0(00e1): 00 86 fe 08 ' nap                     rdlong  t,#0                    'get clkfreq
55b4(00e2): 00 86 fe 28 ' napshr                  shr     t,#0-0                  'shr scales time (set to 13/16/18)
55b8(00e3): 03 86 fe 48 '                         min     t,#3                    'ensure waitcnt won't snag
55bc(00e4): f1 87 be 80 '                         add     t,cnt                   'add cnt to time
55c0(00e5): 00 86 fe f8 '                         waitcnt t,#0                    'wait until time elapses (nap)
55c4(00e6): 00 00 7c 5c ' nap_ret                 ret
55c8(00e7): 00 02 00 00 ' dlsb                    long    1 << 9
55cc(00e8): c4 09 00 00 ' tenms                   long    10_000 / 4
55d0(00e9): 00 00       ' table                   word    $0000   '00
55d2(----): d8 00       '                         word    $00D8   '01             F9
55d4(00ea): 00 00       '                         word    $0000   '02
55d6(----): d4 00       '                         word    $00D4   '03             F5
55d8(00eb): d2 00       '                         word    $00D2   '04             F3
55da(----): d0 00       '                         word    $00D0   '05             F1
55dc(00ec): d1 00       '                         word    $00D1   '06             F2
55de(----): db 00       '                         word    $00DB   '07             F12
55e0(00ed): 00 00       '                         word    $0000   '08
55e2(----): d9 00       '                         word    $00D9   '09             F10
55e4(00ee): d7 00       '                         word    $00D7   '0A             F8
55e6(----): d5 00       '                         word    $00D5   '0B             F6
55e8(00ef): d3 00       '                         word    $00D3   '0C             F4
55ea(----): 09 00       '                         word    $0009   '0D             Tab
55ec(00f0): 60 00       '                         word    $0060   '0E             `
55ee(----): 00 00       '                         word    $0000   '0F
55f0(00f1): 00 00       '                         word    $0000   '10
55f2(----): f4 f5       '                         word    $F5F4   '11     Alt-R   Alt-L
55f4(00f2): f0 00       '                         word    $00F0   '12             Shift-L
55f6(----): 00 00       '                         word    $0000   '13
55f8(00f3): f2 f3       '                         word    $F3F2   '14     Ctrl-R  Ctrl-L
55fa(----): 71 00       '                         word    $0071   '15             q
55fc(00f4): 31 00       '                         word    $0031   '16             1
55fe(----): 00 00       '                         word    $0000   '17
5600(00f5): 00 00       '                         word    $0000   '18
5602(----): 00 00       '                         word    $0000   '19
5604(00f6): 7a 00       '                         word    $007A   '1A             z
5606(----): 73 00       '                         word    $0073   '1B             s
5608(00f7): 61 00       '                         word    $0061   '1C             a
560a(----): 77 00       '                         word    $0077   '1D             w
560c(00f8): 32 00       '                         word    $0032   '1E             2
560e(----): 00 f6       '                         word    $F600   '1F     Win-L
5610(00f9): 00 00       '                         word    $0000   '20
5612(----): 63 00       '                         word    $0063   '21             c
5614(00fa): 78 00       '                         word    $0078   '22             x
5616(----): 64 00       '                         word    $0064   '23             d
5618(00fb): 65 00       '                         word    $0065   '24             e
561a(----): 34 00       '                         word    $0034   '25             4
561c(00fc): 33 00       '                         word    $0033   '26             3
561e(----): 00 f7       '                         word    $F700   '27     Win-R
5620(00fd): 00 00       '                         word    $0000   '28
5622(----): 20 00       '                         word    $0020   '29             Space
5624(00fe): 76 00       '                         word    $0076   '2A             v
5626(----): 66 00       '                         word    $0066   '2B             f
5628(00ff): 74 00       '                         word    $0074   '2C             t
562a(----): 72 00       '                         word    $0072   '2D             r
562c(0100): 35 00       '                         word    $0035   '2E             5
562e(----): 00 cc       '                         word    $CC00   '2F     Apps
5630(0101): 00 00       '                         word    $0000   '30
5632(----): 6e 00       '                         word    $006E   '31             n
5634(0102): 62 00       '                         word    $0062   '32             b
5636(----): 68 00       '                         word    $0068   '33             h
5638(0103): 67 00       '                         word    $0067   '34             g
563a(----): 79 00       '                         word    $0079   '35             y
563c(0104): 36 00       '                         word    $0036   '36             6
563e(----): 00 cd       '                         word    $CD00   '37     Power
5640(0105): 00 00       '                         word    $0000   '38
5642(----): 00 00       '                         word    $0000   '39
5644(0106): 6d 00       '                         word    $006D   '3A             m
5646(----): 6a 00       '                         word    $006A   '3B             j
5648(0107): 75 00       '                         word    $0075   '3C             u
564a(----): 37 00       '                         word    $0037   '3D             7
564c(0108): 38 00       '                         word    $0038   '3E             8
564e(----): 00 ce       '                         word    $CE00   '3F     Sleep
5650(0109): 00 00       '                         word    $0000   '40
5652(----): 2c 00       '                         word    $002C   '41             ,
5654(010a): 6b 00       '                         word    $006B   '42             k
5656(----): 69 00       '                         word    $0069   '43             i
5658(010b): 6f 00       '                         word    $006F   '44             o
565a(----): 30 00       '                         word    $0030   '45             0
565c(010c): 39 00       '                         word    $0039   '46             9
565e(----): 00 00       '                         word    $0000   '47
5660(010d): 00 00       '                         word    $0000   '48
5662(----): 2e 00       '                         word    $002E   '49             .
5664(010e): 2f ef       '                         word    $EF2F   '4A     (/)     /
5666(----): 6c 00       '                         word    $006C   '4B             l
5668(010f): 3b 00       '                         word    $003B   '4C             ;
566a(----): 70 00       '                         word    $0070   '4D             p
566c(0110): 2d 00       '                         word    $002D   '4E             -
566e(----): 00 00       '                         word    $0000   '4F
5670(0111): 00 00       '                         word    $0000   '50
5672(----): 00 00       '                         word    $0000   '51
5674(0112): 27 00       '                         word    $0027   '52             '
5676(----): 00 00       '                         word    $0000   '53
5678(0113): 5b 00       '                         word    $005B   '54             [
567a(----): 3d 00       '                         word    $003D   '55             =
567c(0114): 00 00       '                         word    $0000   '56
567e(----): 00 00       '                         word    $0000   '57
5680(0115): de 00       '                         word    $00DE   '58             CapsLock
5682(----): f1 00       '                         word    $00F1   '59             Shift-R
5684(0116): 0d eb       '                         word    $EB0D   '5A     (Enter) Enter
5686(----): 5d 00       '                         word    $005D   '5B             ]
5688(0117): 00 00       '                         word    $0000   '5C
568a(----): 5c 00       '                         word    $005C   '5D             \
568c(0118): 00 cf       '                         word    $CF00   '5E     WakeUp
568e(----): 00 00       '                         word    $0000   '5F
5690(0119): 00 00       '                         word    $0000   '60
5692(----): 00 00       '                         word    $0000   '61
5694(011a): 00 00       '                         word    $0000   '62
5696(----): 00 00       '                         word    $0000   '63
5698(011b): 00 00       '                         word    $0000   '64
569a(----): 00 00       '                         word    $0000   '65
569c(011c): c8 00       '                         word    $00C8   '66             BackSpace
569e(----): 00 00       '                         word    $0000   '67
56a0(011d): 00 00       '                         word    $0000   '68
56a2(----): e1 c5       '                         word    $C5E1   '69     End     (1)
56a4(011e): 00 00       '                         word    $0000   '6A
56a6(----): e4 c0       '                         word    $C0E4   '6B     Left    (4)
56a8(011f): e7 c4       '                         word    $C4E7   '6C     Home    (7)
56aa(----): 00 00       '                         word    $0000   '6D
56ac(0120): 00 00       '                         word    $0000   '6E
56ae(----): 00 00       '                         word    $0000   '6F
56b0(0121): e0 ca       '                         word    $CAE0   '70     Insert  (0)
56b2(----): ea c9       '                         word    $C9EA   '71     Delete  (.)
56b4(0122): e2 c3       '                         word    $C3E2   '72     Down    (2)
56b6(----): e5 00       '                         word    $00E5   '73             (5)
56b8(0123): e6 c1       '                         word    $C1E6   '74     Right   (6)
56ba(----): e8 c2       '                         word    $C2E8   '75     Up      (8)
56bc(0124): cb 00       '                         word    $00CB   '76             Esc
56be(----): df 00       '                         word    $00DF   '77             NumLock
56c0(0125): da 00       '                         word    $00DA   '78             F11
56c2(----): ec 00       '                         word    $00EC   '79             (+)
56c4(0126): e3 c7       '                         word    $C7E3   '7A     PageDn  (3)
56c6(----): ed 00       '                         word    $00ED   '7B             (-)
56c8(0127): ee dc       '                         word    $DCEE   '7C     PrScr   (*)
56ca(----): e9 c6       '                         word    $C6E9   '7D     PageUp  (9)
56cc(0128): dd 00       '                         word    $00DD   '7E             ScrLock
56ce(----): 00 00       '                         word    $0000   '7F
56d0(0129): 00 00       '                         word    $0000   '80
56d2(----): 00 00       '                         word    $0000   '81
56d4(012a): 00 00       '                         word    $0000   '82
56d6(----): d6 00       '                         word    $00D6   '83             F7
56d8(012b): ca c5 c3 c7 ' keypad1                 byte    $CA, $C5, $C3, $C7, $C0, 0, $C1, $C4, $C2, $C6, $C9, $0D, "+-*/"
56dc(012c): c0 00 c1 c4 ' 
56e0(012d): c2 c6 c9 0d ' 
56e4(012e): 2b 2d 2a 2f ' 
56e8(012f): 30 31 32 33 ' keypad2                 byte    "0123456789.", $0D, "+-*/"
56ec(0130): 34 35 36 37 ' 
56f0(0131): 38 39 2e 0d ' 
56f4(0132): 2b 2d 2a 2f ' 
56f8(0133): 7b 7c 7d 00 ' shift1                  byte    "{|}", 0, 0, "~"
56fc(0134): 00 7e       ' 
56fe(----): 22 00 00 00 ' shift2                  byte    $22, 0, 0, 0, 0, "<_>?)!@#$%^&*(", 0, ":", 0, "+"
5702(----): 00 3c 5f 3e ' 
5706(----): 3f 29 21 40 ' 
570a(----): 23 24 25 5e ' 
570e(----): 26 2a 28 00 ' 
5712(----): 3a 00 2b    ' 
5715(----): 00 00 00      
5718(013b):             ' dwmask                  res     1       'output driver mask for data
5718(013c):             ' drmask                  res     1       'input mask for data
5718(013d):             ' cwmask                  res     1       'output driver mask for clock
5718(013e):             ' crmask                  res     1       'input mask for data
5718(013f):             ' stat                    res     1
5718(0140):             ' data                    res     1
5718(0141):             ' x                       res     1
5718(0142):             ' y                       res     1
5718(0143):             ' t                       res     1
5718(0144):             ' _head                   res     1       'write-only
5718(0145):             ' _present                res     1       'write-only
5718(0146):             ' _states                 res     8       'write-only
5718(014e):             ' _pingroup               res     1       'read-only at start
5718(014f):             ' _locks                  res     1       'read-only at start
5718(0150):             ' _auto                   res     1       'read-only at start
'=========================== Method #1: PUB start =============================
'PUB start(kb_block, pingroup) : okay
'------------------------------------------------------------------------------
  okay := startx(kb_block, pingroup, %0_000_100, %01_01000)
'------------------------------------------------------------------------------
5718: 00             FRAME	Call with return value	
5719: 64             PUSH 	Locals+4
571a: 68             PUSH 	Locals+8
571b: 37 01          PUSH#kp	4 ($4)
571d: 38 28          PUSH#k1	40
571f: 05 02          CALL 	+2 
5721: 61             POP  	Locals+0
5722: 32             RETURN	
'=========================== Method #2: PUB startx ============================
'PUB startx(kb_block, pingroup, locks, auto) : okay | addr
'------------------------------------------------------------------------------
  addr := @long[kb_block][par_keys]
'------------------------------------------------------------------------------
5723: 64             PUSH 	Locals+4
5724: 38 0b          PUSH#k1	11
5726: d3             PUSH#.L	Mem[][]
5727: 75             POP  	Locals+20
'------------------------------------------------------------------------------
  longmove(addr, @pingroup, 3)
'------------------------------------------------------------------------------
5728: 74             PUSH 	Locals+20
5729: 6b             PUSH#	Locals+8
572a: 37 21          PUSH#kp	3 ($3)
572c: 1e             LONGMOV	
'------------------------------------------------------------------------------
  okay := cognew(@entry, kb_block) + 1
'------------------------------------------------------------------------------
572d: 34             PUSH#-1	
572e: c7 10          PUSH#.L	OBJ+16
5730: 64             PUSH 	Locals+4
5731: 28             COGIFUN	
5732: 36             PUSH#1	
5733: ec             ADD  	
5734: 61             POP  	Locals+0
5735: 32             RETURN	
'========================= Method #3: PUB BlockSize ===========================
'PUB BlockSize : size
'------------------------------------------------------------------------------
   size := kb_count
'------------------------------------------------------------------------------
5736: 38 14          PUSH#k1	20
5738: 61             POP  	Locals+0
5739: 32             RETURN	
573a: 00 00       

'******************************************************************************
'                          Catalina_comboMouse.spin                            
'******************************************************************************

'=================================== CONs =====================================
m_count = 10
'=============================== Object Header ================================
573c: 18 00 02 01 ' 24 bytes, 2-1 methods, 1 object pointers
5740: 0c 00 00 00 ' ptr #1 to $5748: PUB start (locals size: 0)
5744: 18 00 00 00 ' ptr #2 to $5754: OBJ mouse : Catalina_mouse.spin (VAR offset: 0)
'=========================== Method #1: PUB start =============================
'PUB start(m_block, pin) : okay
'------------------------------------------------------------------------------
  return mouse.Start(m_block, pin, pin+1)               ' (Other)
'------------------------------------------------------------------------------
5748: 00             FRAME	Call with return value	
5749: 64             PUSH 	Locals+4
574a: 68             PUSH 	Locals+8
574b: 68             PUSH 	Locals+8
574c: 36             PUSH#1	
574d: ec             ADD  	
574e: 06 02 01       CALLOBJ	2:1
5751: 33             RETVAL	
5752: 32             RETURN	
5753: 00          

'******************************************************************************
'                             Catalina_mouse.spin                              
'******************************************************************************

'=================================== CONs =====================================
m_count = 10
par_x = 3
par_dpin = 8
par_cpin = 9
'=============================== Object Header ================================
5754: 84 02 02 00 ' 644 bytes, 2-1 methods, 0 object pointers
5758: 6c 02 04 00 ' ptr #1 to $59c0: PUB start (locals size: 4)
'================================ DAT Section =================================
575c(0000):             '                         org
575c(0000): f0 3b bd a0 ' entry                   mov     p,par                   'load input parameters:
5760(0001): 14 3a fd 80 '                         add     p,#5*4                  '_dpin/_cpin
5764(0002): 9d 4a bd 08 '                         rdlong  _dpin,p
5768(0003): 04 3a fd 80 '                         add     p,#4
576c(0004): 9d 4c bd 08 '                         rdlong  _cpin,p
5770(0005): 01 32 fd a0 '                         mov     dmask,#1                'set pin masks
5774(0006): a5 32 bd 2c '                         shl     dmask,_dpin
5778(0007): 01 34 fd a0 '                         mov     cmask,#1
577c(0008): a6 34 bd 2c '                         shl     cmask,_cpin
5780(0009): 20 4a 7d 61 '                         test    _dpin,#$20      wc      'modify port registers within code
5784(000a): 96 ba bc 70 '                         muxc    _d1,dlsb
5788(000b): 96 ce bc 70 '                         muxc    _d2,dlsb
578c(000c): 01 f2 fc 70 '                         muxc    _d3,#1
5790(000d): 01 10 fd 70 '                         muxc    _d4,#1
5794(000e): 20 4c 7d 61 '                         test    _cpin,#$20      wc
5798(000f): 96 b4 bc 70 '                         muxc    _c1,dlsb
579c(0010): 96 c0 bc 70 '                         muxc    _c2,dlsb
57a0(0011): 01 0e fd 70 '                         muxc    _c3,#1
57a4(0012): a0 28 fc 54 '                         movd    :par,#_x                'reset output parameters:
57a8(0013): 05 3a fd a0 '                         mov     p,#5                    '_x/_y/_z/_buttons/_present
57ac(0014): 00 00 fc a0 ' :par                    mov     0,#0
57b0(0015): 96 28 bc 80 '                         add     :par,dlsb
57b4(0016): 14 3a fd e4 '                         djnz    p,#:par
57b8(0017): 00 ec ff a0 ' reset                   mov     dira,#0                 'reset directions
57bc(0018): 00 ee ff a0 '                         mov     dirb,#0
57c0(0019): 01 36 fd a0 '                         mov     stat,#1                 'set reset flag
57c4(001a): a0 3a fc 54 ' update                  movd    :par,#_x                'update output parameters:
57c8(001b): f0 3b bd a0 '                         mov     p,par                   '_x/_y/_z/_buttons/_present
57cc(001c): 05 3c fd a0 '                         mov     q,#5
57d0(001d): 9d 00 3c 08 ' :par                    wrlong  0,p
57d4(001e): 96 3a bc 80 '                         add     :par,dlsb
57d8(001f): 04 3a fd 80 '                         add     p,#4
57dc(0020): 1d 3c fd e4 '                         djnz    q,#:par
57e0(0021): 01 36 7d 61 '                         test    stat,#1         wc      'if reset flag, transmit reset command
57e4(0022): ff 38 f1 a0 '         if_c            mov     data,#$FF
57e8(0023): 5a e4 f0 5c '         if_c            call    #transmit
57ec(0024): 00 36 fd a0 '                         mov     stat,#0                 'reset state
57f0(0025): 73 04 fd 5c '                         call    #receive                'receive first byte
57f4(0026): aa 38 7d 86 '                         cmp     data,#$AA       wz      'powerup/reset?
57f8(0027): 3e 00 68 5c '         if_z            jmp     #init
57fc(0028): 9c 46 bd a0 '                         mov     _buttons,data           'data packet, save buttons
5800(0029): 73 04 fd 5c '                         call    #receive                'receive second byte
5804(002a): 10 46 7d 61 '                         test    _buttons,#$10   wc      'adjust _x
5808(002b): 98 38 bd 70 '                         muxc    data,signext
580c(002c): 9c 40 bd 80 '                         add     _x,data
5810(002d): 73 04 fd 5c '                         call    #receive                'receive third byte
5814(002e): 20 46 7d 61 '                         test    _buttons,#$20   wc      'adjust _y
5818(002f): 98 38 bd 70 '                         muxc    data,signext
581c(0030): 9c 42 bd 80 '                         add     _y,data
5820(0031): 07 46 fd 60 '                         and     _buttons,#%111          'trim buttons
5824(0032): 02 48 7d 85 '                         cmp     _present,#2     wc      'if not scrollwheel mouse, update parameters
5828(0033): 1a 00 70 5c '         if_c            jmp     #update
582c(0034): 73 04 fd 5c '                         call    #receive                'scrollwheel mouse, receive fourth byte
5830(0035): 03 48 7d 86 '                         cmp     _present,#3     wz      'if 5-button mouse, handle two extra buttons
5834(0036): 10 38 69 61 '         if_z            test    data,#$10       wc
5838(0037): 08 46 e1 68 '         if_z_and_c      or      _buttons,#%01000
583c(0038): 20 38 69 61 '         if_z            test    data,#$20       wc
5840(0039): 10 46 e1 68 '         if_z_and_c      or      _buttons,#%10000
5844(003a): 1c 38 fd 2c '                         shl     data,#28                'adjust _z
5848(003b): 1c 38 fd 38 '                         sar     data,#28
584c(003c): 9c 44 bd 84 '                         sub     _z,data
5850(003d): 1a 00 7c 5c '                         jmp     #update                 'update parameters
5854(003e): 73 04 fd 5c ' init                    call    #receive                '$AA received, receive id
5858(003f): 64 9a fc 50 '                         movs    crate,#100              'try to enable 3-button scrollwheel type
585c(0040): 4b a8 fc 5c '                         call    #checktype
5860(0041): c8 9a fc 50 '                         movs    crate,#200              'try to enable 5-button scrollwheel type
5864(0042): 4b a8 fc 5c '                         call    #checktype
5868(0043): 01 38 fd 28 '                         shr     data,#1                 'if neither, 3-button type
586c(0044): 01 38 fd 80 '                         add     data,#1
5870(0045): 9c 48 bd a0 '                         mov     _present,data
5874(0046): c8 ae fc 50 '                         movs    srate,#200              'set 200 samples per second
5878(0047): 55 b2 fc 5c '                         call    #setrate
587c(0048): f4 38 fd a0 '                         mov     data,#$F4               'enable data reporting
5880(0049): 5a e4 fc 5c '                         call    #transmit
5884(004a): 1a 00 7c 5c '                         jmp     #update
5888(004b): c8 ae fc 50 ' checktype               movs    srate,#200              'perform "knock" sequence to enable
588c(004c): 55 b2 fc 5c '                         call    #setrate                '..scrollwheel and extra buttons
5890(004d): 02 ae fc 50 ' crate                   movs    srate,#200/100
5894(004e): 55 b2 fc 5c '                         call    #setrate
5898(004f): 50 ae fc 50 '                         movs    srate,#80
589c(0050): 55 b2 fc 5c '                         call    #setrate
58a0(0051): f2 38 fd a0 '                         mov     data,#$F2               'read type
58a4(0052): 5a e4 fc 5c '                         call    #transmit
58a8(0053): 73 04 fd 5c '                         call    #receive
58ac(0054): 00 00 7c 5c ' checktype_ret           ret
58b0(0055): f3 38 fd a0 ' setrate                 mov     data,#$F3
58b4(0056): 5a e4 fc 5c '                         call    #transmit
58b8(0057): 00 38 fd a0 ' srate                   mov     data,#0
58bc(0058): 5a e4 fc 5c '                         call    #transmit
58c0(0059): 00 00 7c 5c ' setrate_ret             ret
58c4(005a):             ' transmit
58c4(005a): 9a ec bf 68 ' _c1                     or      dira,cmask              'pull clock low
58c8(005b): 0d 22 fd 50 '                         movs    napshr,#13              'hold clock for ~128us (must be >100us)
58cc(005c): 90 2a fd 5c '                         call    #nap
58d0(005d): 99 ec bf 68 ' _d1                     or      dira,dmask              'pull data low
58d4(005e): 12 22 fd 50 '                         movs    napshr,#18              'hold data for ~4us
58d8(005f): 90 2a fd 5c '                         call    #nap
58dc(0060): 9a ec bf 6c ' _c2                     xor     dira,cmask              'release clock
58e0(0061): ff 38 7d 61 '                         test    data,#$0FF      wc      'append parity and stop bits to byte
58e4(0062): 00 39 fd 74 '                         muxnc   data,#$100
58e8(0063): 96 38 bd 68 '                         or      data,dlsb
58ec(0064): 0a 3a fd a0 '                         mov     p,#10                   'ready 10 bits
58f0(0065): 83 16 fd 5c ' transmit_bit            call    #wait_c0                'wait until clock low
58f4(0066): 01 38 fd 29 '                         shr     data,#1         wc      'output data bit
58f8(0067): 99 ec bf 74 ' _d2                     muxnc   dira,dmask
58fc(0068): 8d 12 bd a0 '                         mov     wcond,c1                'wait until clock high
5900(0069): 84 16 fd 5c '                         call    #wait
5904(006a): 65 3a fd e4 '                         djnz    p,#transmit_bit         'another bit?
5908(006b): 8e 12 bd a0 '                         mov     wcond,c0d0              'wait until clock and data low
590c(006c): 84 16 fd 5c '                         call    #wait
5910(006d): 8f 12 bd a0 '                         mov     wcond,c1d1              'wait until clock and data high
5914(006e): 84 16 fd 5c '                         call    #wait
5918(006f): 75 04 fd 5c '                         call    #receive_ack            'receive ack byte with timed wait
591c(0070): fa 38 7d 86 '                         cmp     data,#$FA       wz      'if ack error, reset mouse
5920(0071): 17 00 54 5c '         if_nz           jmp     #reset
5924(0072): 00 00 7c 5c ' transmit_ret            ret
5928(0073): 20 4c 7d 61 ' receive                 test    _cpin,#$20      wc      'wait indefinitely for initial clock low
592c(0074): 9a 34 3d f4 '                         waitpne cmask,cmask
5930(0075):             ' receive_ack
5930(0075): 0b 3a fd a0 '                         mov     p,#11                   'ready 11 bits
5934(0076): 83 16 fd 5c ' receive_bit             call    #wait_c0                'wait until clock low
5938(0077): 10 22 fd 50 '                         movs    napshr,#16              'pause ~16us
593c(0078): 90 2a fd 5c '                         call    #nap
5940(0079): f2 33 3d 61 ' _d3                     test    dmask,ina       wc      'input data bit
5944(007a): 01 38 fd 30 '                         rcr     data,#1
5948(007b): 8d 12 bd a0 '                         mov     wcond,c1                'wait until clock high
594c(007c): 84 16 fd 5c '                         call    #wait
5950(007d): 76 3a fd e4 '                         djnz    p,#receive_bit          'another bit?
5954(007e): 16 38 fd 28 '                         shr     data,#22                'align byte
5958(007f): ff 39 7d 61 '                         test    data,#$1FF      wc      'if parity error, reset mouse
595c(0080): 17 00 4c 5c '         if_nc           jmp     #reset
5960(0081): ff 38 fd 60 '                         and     data,#$FF               'isolate byte
5964(0082):             ' receive_ack_ret
5964(0082): 00 00 7c 5c ' receive_ret             ret
5968(0083): 8c 12 bd a0 ' wait_c0                 mov     wcond,c0                '(wait until clock low)
596c(0084): 97 3c bd a0 ' wait                    mov     q,tenms                 'set timeout to 10ms
5970(0085): 12 22 fd 50 ' wloop                   movs    napshr,#18              'nap ~4us
5974(0086): 90 2a fd 5c '                         call    #nap
5978(0087): f2 35 3d 61 ' _c3                     test    cmask,ina       wc      'check required state(s)
597c(0088): f2 33 3d 62 ' _d4                     test    dmask,ina       wz      'loop until got state(s) or timeout
5980(0089): 85 3c c1 e4 ' wcond   if_never        djnz    q,#wloop                '(replaced with c0/c1/c0d0/c1d1)
5984(008a): 17 3c 7d ec '                         tjz     q,#reset                'if timeout, reset mouse
5988(008b):             ' wait_ret
5988(008b): 00 00 7c 5c ' wait_c0_ret             ret
598c(008c): 85 3c f1 e4 ' c0      if_c            djnz    q,#wloop                '(if_never replacements)
5990(008d): 85 3c cd e4 ' c1      if_nc           djnz    q,#wloop
5994(008e): 85 3c f5 e4 ' c0d0    if_c_or_nz      djnz    q,#wloop
5998(008f): 85 3c ed e4 ' c1d1    if_nc_or_z      djnz    q,#wloop
599c(0090): 00 3e fd 08 ' nap                     rdlong  t,#0                    'get clkfreq
59a0(0091): 00 3e fd 28 ' napshr                  shr     t,#18/16/13             'shr scales time
59a4(0092): 03 3e fd 48 '                         min     t,#3                    'ensure waitcnt won't snag
59a8(0093): f1 3f bd 80 '                         add     t,cnt                   'add cnt to time
59ac(0094): 00 3e fd f8 '                         waitcnt t,#0                    'wait until time elapses (nap)
59b0(0095): 00 00 7c 5c ' nap_ret                 ret
59b4(0096): 00 02 00 00 ' dlsb                    long    1 << 9
59b8(0097): c4 09 00 00 ' tenms                   long    10_000 / 4
59bc(0098): 00 ff ff ff ' signext                 long    $FFFFFF00
59c0(0099):             ' dmask                   res     1
59c0(009a):             ' cmask                   res     1
59c0(009b):             ' stat                    res     1
59c0(009c):             ' data                    res     1
59c0(009d):             ' p                       res     1
59c0(009e):             ' q                       res     1
59c0(009f):             ' t                       res     1
59c0(00a0):             ' _x                      res     1       'write-only
59c0(00a1):             ' _y                      res     1       'write-only
59c0(00a2):             ' _z                      res     1       'write-only
59c0(00a3):             ' _buttons                res     1       'write-only
59c0(00a4):             ' _present                res     1       'write-only
59c0(00a5):             ' _dpin                   res     1       'read-only
59c0(00a6):             ' _cpin                   res     1       'read-only
'=========================== Method #1: PUB start =============================
'PUB start(m_block, dpin, cpin) : okay | addr
'------------------------------------------------------------------------------
  long[m_block][par_dpin] := dpin
'------------------------------------------------------------------------------
59c0: 68             PUSH 	Locals+8
59c1: 64             PUSH 	Locals+4
59c2: 37 02          PUSH#kp	8 ($8)
59c4: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[m_block][par_cpin] := cpin
'------------------------------------------------------------------------------
59c5: 6c             PUSH 	Locals+12
59c6: 64             PUSH 	Locals+4
59c7: 38 09          PUSH#k1	9
59c9: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  addr := @long[m_block][par_x]
'------------------------------------------------------------------------------
59ca: 64             PUSH 	Locals+4
59cb: 37 21          PUSH#kp	3 ($3)
59cd: d3             PUSH#.L	Mem[][]
59ce: 71             POP  	Locals+16
'------------------------------------------------------------------------------
  okay := cognew(@entry, addr) > 0
'------------------------------------------------------------------------------
59cf: 34             PUSH#-1	
59d0: c7 08          PUSH#.L	OBJ+8
59d2: 70             PUSH 	Locals+16
59d3: 28             COGIFUN	
59d4: 35             PUSH#0	
59d5: fa             GT   	
59d6: 61             POP  	Locals+0
59d7: 32             RETURN	

'******************************************************************************
'                         Catalina_HiRes_TV_Text.spin                          
'******************************************************************************

'=================================== CONs =====================================
tv_count = 14
MAXCOLS = 40
MAXROWS = 30
tv_pins = 2
tv_mode = 3
tv_screen = 4
tv_colors = 5
tv_width = 6
tv_height = 7
tv_hx = 8
cols = 40
rows = 30
'=============================== Object Header ================================
59d8: b4 00 02 01 ' 180 bytes, 2-1 methods, 1 object pointers
59dc: 44 00 00 00 ' ptr #1 to $5a1c: PUB start (locals size: 0)
59e0: b4 00 00 00 ' ptr #2 to $5a8c: OBJ tv : TV_Half_Height.spin (VAR offset: 0)
'================================ DAT Section =================================
59e4(0000): 00 00 00 00 ' tv_params               long    0               'status
59e8(0001): 01 00 00 00 '                         long    1               'enable
59ec(0002): 00 00 00 00 '                         long    0               'pins
59f0(0003): 12 00 00 00 '                         long    %10010          'mode
59f4(0004): 00 00 00 00 '                         long    0               'screen
59f8(0005): 00 00 00 00 '                         long    0               'colors
59fc(0006): 28 00 00 00 '                         long    40              'hc
5a00(0007): 1e 00 00 00 '                         long    30              'vc
5a04(0008): 04 00 00 00 '                         long    4               'hx
5a08(0009): 01 00 00 00 '                         long    1               'vx
5a0c(000a): 00 00 00 00 '                         long    0               'ho
5a10(000b): 00 00 00 00 '                         long    0               'vo
5a14(000c): 00 00 00 00 '                         long    0               'broadcast
5a18(000d): 00 00 00 00 '                         long    0               'auralcog
'=========================== Method #1: PUB start =============================
'PUB start(tv_block,basepin,screen,colors,ntsc_pal,interlaced,width,height) : okay
'------------------------------------------------------------------------------
  if width>MAXCOLS
'------------------------------------------------------------------------------
5a1c: 7c             PUSH 	Locals+28
5a1d: 38 28          PUSH#k1	40
5a1f: fa             GT   	
5a20: 0a 03          JPF  	.+3 (dest:$5a25)
'------------------------------------------------------------------------------
    width:=MAXCOLS
'------------------------------------------------------------------------------
5a22: 38 28          PUSH#k1	40
5a24: 7d             POP  	Locals+28
'------------------------------------------------------------------------------
  if height>MAXROWS
'------------------------------------------------------------------------------
5a25: cc 20          PUSH.L	Locals+32
5a27: 38 1e          PUSH#k1	30
5a29: fa             GT   	
5a2a: 0a 04          JPF  	.+4 (dest:$5a30)
'------------------------------------------------------------------------------
    height:=MAXROWS
'------------------------------------------------------------------------------
5a2c: 38 1e          PUSH#k1	30
5a2e: cd 20          POP.L	Locals+32
'------------------------------------------------------------------------------
  longmove(tv_block, @tv_params, tv_count)
'------------------------------------------------------------------------------
5a30: 64             PUSH 	Locals+4
5a31: c7 0c          PUSH#.L	OBJ+12
5a33: 38 0e          PUSH#k1	14
5a35: 1e             LONGMOV	
'------------------------------------------------------------------------------
  long[tv_block][tv_pins] := (basepin & $38) << 1 | (basepin & 4 == 4) & %0101
'------------------------------------------------------------------------------
5a36: 68             PUSH 	Locals+8
5a37: 38 38          PUSH#k1	56
5a39: e8             BIT_AND	
5a3a: 36             PUSH#1	
5a3b: e3             SHL  	
5a3c: 68             PUSH 	Locals+8
5a3d: 37 01          PUSH#kp	4 ($4)
5a3f: e8             BIT_AND	
5a40: 37 01          PUSH#kp	4 ($4)
5a42: fc             EQ   	
5a43: 38 05          PUSH#k1	5
5a45: e8             BIT_AND	
5a46: ea             BIT_OR	
5a47: 64             PUSH 	Locals+4
5a48: 37 00          PUSH#kp	2 ($2)
5a4a: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[tv_block][tv_screen] := screen
'------------------------------------------------------------------------------
5a4b: 6c             PUSH 	Locals+12
5a4c: 64             PUSH 	Locals+4
5a4d: 37 01          PUSH#kp	4 ($4)
5a4f: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[tv_block][tv_colors] := colors
'------------------------------------------------------------------------------
5a50: 70             PUSH 	Locals+16
5a51: 64             PUSH 	Locals+4
5a52: 38 05          PUSH#k1	5
5a54: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[tv_block][tv_mode]:=%10000+((interlaced&1)<<1)+(ntsc_pal&1) 'set Interlace, PAL or NTSC ( also sets 16x16 full size tile )
'------------------------------------------------------------------------------
5a55: 37 03          PUSH#kp	16 ($10)
5a57: 78             PUSH 	Locals+24
5a58: 36             PUSH#1	
5a59: e8             BIT_AND	
5a5a: 36             PUSH#1	
5a5b: e3             SHL  	
5a5c: ec             ADD  	
5a5d: 74             PUSH 	Locals+20
5a5e: 36             PUSH#1	
5a5f: e8             BIT_AND	
5a60: ec             ADD  	
5a61: 64             PUSH 	Locals+4
5a62: 37 21          PUSH#kp	3 ($3)
5a64: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[tv_block][tv_width]:=width 'set cols
'------------------------------------------------------------------------------
5a65: 7c             PUSH 	Locals+28
5a66: 64             PUSH 	Locals+4
5a67: 38 06          PUSH#k1	6
5a69: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[tv_block][tv_height]:=height 'sets rows
'------------------------------------------------------------------------------
5a6a: cc 20          PUSH.L	Locals+32
5a6c: 64             PUSH 	Locals+4
5a6d: 37 22          PUSH#kp	7 ($7)
5a6f: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[tv_block][tv_hx]:=4
'------------------------------------------------------------------------------
5a70: 37 01          PUSH#kp	4 ($4)
5a72: 64             PUSH 	Locals+4
5a73: 37 02          PUSH#kp	8 ($8)
5a75: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  if(ntsc_pal and width=<40)
'------------------------------------------------------------------------------
5a76: 74             PUSH 	Locals+20
5a77: 7c             PUSH 	Locals+28
5a78: 38 28          PUSH#k1	40
5a7a: fd             LE   	
5a7b: f0             LOG_AND	
5a7c: 0a 06          JPF  	.+6 (dest:$5a84)
'------------------------------------------------------------------------------
    long[tv_block][tv_hx]:=5
'------------------------------------------------------------------------------
5a7e: 38 05          PUSH#k1	5
5a80: 64             PUSH 	Locals+4
5a81: 37 02          PUSH#kp	8 ($8)
5a83: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  okay := tv.start(tv_block)    
'------------------------------------------------------------------------------
5a84: 00             FRAME	Call with return value	
5a85: 64             PUSH 	Locals+4
5a86: 06 02 01       CALLOBJ	2:1
5a89: 61             POP  	Locals+0
5a8a: 32             RETURN	
5a8b: 00          

'******************************************************************************
'                             TV_Half_Height.spin                              
'******************************************************************************

'=================================== CONs =====================================
fntsc = 3579545
lntsc = 3640
sntsc = 624
fpal = 4433618
lpal = 4540
spal = 848
paramcount = 14
colortable = 384
'=============================== Object Header ================================
5a8c: 88 04 03 00 ' 1160 bytes, 3-1 methods, 0 object pointers
5a90: 70 04 00 00 ' ptr #1 to $5efc: PUB start (locals size: 0)
5a94: 7e 04 00 00 ' ptr #2 to $5f0a: PUB stop (locals size: 0)
'================================ DAT Section =================================
5a98(0000):             '                         org
5a98(0000): 5f 32 fe a0 ' entry                   mov     taskptr,#tasks          'reset tasks
5a9c(0001): 0a 3e fe a0 '                         mov     x,#10                   'perform task sections initially
5aa0(0002): 19 35 be 5c ' :init                   jmpret  taskret,taskptr
5aa4(0003): 02 3e fe e4 '                         djnz    x,#:init
5aa8(0004): 5f 32 fe a0 ' superfield              mov     taskptr,#tasks          'reset tasks
5aac(0005): 01 74 7e 61 '                         test    _mode,#%0001    wc      'if ntsc, set phaseflip
5ab0(0006): 00 ff 8d a0 '         if_nc           mov     phaseflip,phasemask
5ab4(0007): 02 74 7e 62 '                         test    _mode,#%0010    wz      'get interlace into nz
5ab8(0008): 31 3f be a0 ' field                   mov     x,vinv                  'do invisible back porch lines
5abc(0009): 4d aa fc 5c ' :black                  call    #hsync                  'do hsync
5ac0(000a): 07 67 3e fc '                         waitvid burst,sync_high2        'do black
5ac4(000b): 19 35 be 5c '                         jmpret  taskret,taskptr         'call task section (z undisturbed)
5ac8(000c): 09 3e fe e4 '                         djnz    x,#:black               'another black line?
5acc(000d): f0 fd 3d 08 '                         wrlong  visible,par             'set status to visible
5ad0(000e): 24 3f be a0 '                         mov     x,vb                    'do visible back porch lines
5ad4(000f): 48 98 fc 5c '                         call    #blank_lines
5ad8(0010): 3b 51 be a0 '                         mov     screen,_screen          'point to first tile (upper-leftmost)
5adc(0011): 3e 41 be a0 '                         mov     y,_vt                   'set vertical tiles
5ae0(0012): 40 4d be a0 ' :line                   mov     vx,_vx                  'set vertical expand
5ae4(0013): 01 f8 e9 6c ' :vert   if_z            xor     interlace,#1            'interlace skip?
5ae8(0014): 2e f8 69 ec '         if_z            tjz     interlace,#:skip
5aec(0015): 4d aa fc 5c '                         call    #hsync                  'do hsync
5af0(0016): 22 ff bf a0 '                         mov     vscl,hb                 'do visible back porch pixels
5af4(0017): 80 53 be 6c '                         xor     tile,colortable
5af8(0018): 00 52 7e fc '                         waitvid tile,#0
5afc(0019): 3d 3f be a0 '                         mov     x,_ht                   'set horizontal tiles
5b00(001a): 25 ff bf a0 '                         mov     vscl,hx                 'set horizontal expand
5b04(001b): 28 53 be 04 ' :tile                   rdword  tile,screen             'read tile
5b08(001c): 01 53 be 68 '                         or      tile,line               'set pointer bits into tile
5b0c(001d): 06 52 fe 24 '                         rol     tile,#6                 'read tile pixels
5b10(001e): 29 55 be 08 '                         rdlong  pixels,tile             '(2 instructions between reads)
5b14(001f): 04 52 fe 80 '                         add     tile,#4     ' JB MOD point to next scanline's pixels
5b18(0020): 02 50 fe 80 '                         add     screen,#2               'point to next tile
5b1c(0021): 29 59 be 08 '                         rdlong  pixels2,tile ' JB MOD get next scanline's pixels
5b20(0022): 2c 55 be 68 '                         or      pixels,pixels2 ' JB MOD or the two together
5b24(0023): 10 52 fe 28 '                         shr     tile,#10+6              'set tile colors
5b28(0024): 29 4d bc 50 '                         movs    :color,tile
5b2c(0025): ff 52 be a0 '                         mov     tile,phaseflip
5b30(0026): 80 53 be 6c ' :color                  xor     tile,colortable
5b34(0027): 2a 53 3e fc '                         waitvid tile,pixels             'pass colors and pixels to video
5b38(0028): 1b 3e fe e4 '                         djnz    x,#:tile                'another tile?
5b3c(0029): 27 51 be 84 '                         sub     screen,hc2x             'repoint to first tile in same line
5b40(002a): 21 ff bf a0 '                         mov     vscl,hf                 'do visible front porch pixels
5b44(002b): ff 52 be a0 '                         mov     tile,phaseflip
5b48(002c): 80 53 be 6c '                         xor     tile,colortable
5b4c(002d): 00 52 7e fc '                         waitvid tile,#0
5b50(002e): 13 4c fe e4 ' :skip                   djnz    vx,#:vert               'vertical expand?
5b54(002f): 03 03 be 20 '                         ror     line,linerot            'set next line
5b58(0030): 2b 03 be 81 '                         add     line,lineadd    wc
5b5c(0031): 03 03 be 24 '                         rol     line,linerot      
5b60(0032): 12 00 4c 5c '         if_nc           jmp     #:line
5b64(0033): 27 51 be 80 '                         add     screen,hc2x             'point to first tile in next line
5b68(0034): 12 40 fe e4 '                         djnz    y,#:line                'another tile line?
5b6c(0035): 01 f8 e9 6e '         if_z            xor     interlace,#1    wz      'get interlace and field1 into z
5b70(0036): 01 74 7e 61 '                         test    _mode,#%0001    wc      'do visible front porch lines
5b74(0037): 23 3f be a0 '                         mov     x,vf
5b78(0038): 01 3e d2 80 '         if_nz_and_c     add     x,#1
5b7c(0039): 48 98 fc 5c '                         call    #blank_lines
5b80(003a): f0 fb 15 08 '         if_nz           wrlong  invisible,par           'unless interlace and field1, set status to invisible
5b84(003b): 4d aa e4 5c '         if_z_eq_c       call    #hsync                  'if required, do short line
5b88(003c): 2e ff a7 a0 '         if_z_eq_c       mov     vscl,hrest
5b8c(003d): 07 67 26 fc '         if_z_eq_c       waitvid burst,sync_high2
5b90(003e): 00 ff a5 6c '         if_z_eq_c       xor     phaseflip,phasemask
5b94(003f): 56 bc fc 5c '                         call    #vsync_high             'do high vsync pulses
5b98(0040): 08 b5 fc 50 '                         movs    vsync1,#sync_low1       'do low vsync pulses
5b9c(0041): 09 b9 fc 50 '                         movs    vsync2,#sync_low2
5ba0(0042): 58 bc fc 5c '                         call    #vsync_low
5ba4(0043): 56 bc fc 5c '                         call    #vsync_high             'do high vsync pulses
5ba8(0044): 2f ff 97 a0 '         if_nz           mov     vscl,hhalf              'if odd frame, do half line
5bac(0045): 07 67 16 fc '         if_nz           waitvid burst,sync_high2
5bb0(0046): 08 00 68 5c '         if_z            jmp     #field                  'if interlace and field1, display field2
5bb4(0047): 04 00 7c 5c '                         jmp     #superfield             'else, new superfield
5bb8(0048): 4d aa fc 5c ' blank_lines             call    #hsync                  'do hsync
5bbc(0049): 80 53 be 6c '                         xor     tile,colortable         'do background
5bc0(004a): 00 52 7e fc '                         waitvid tile,#0
5bc4(004b): 48 3e fe e4 '                         djnz    x,#blank_lines
5bc8(004c): 00 00 7c 5c ' blank_lines_ret         ret
5bcc(004d): 01 74 7e 61 ' hsync                   test    _mode,#%0001    wc      'if pal, toggle phaseflip
5bd0(004e): 00 ff b1 6c '         if_c            xor     phaseflip,phasemask
5bd4(004f): 35 ff bf a0 '                         mov     vscl,sync_scale1        'do hsync       
5bd8(0050): ff 52 be a0 '                         mov     tile,phaseflip
5bdc(0051): 33 53 be 6c '                         xor     tile,burst
5be0(0052): 37 53 3e fc '                         waitvid tile,sync_normal
5be4(0053): 2d ff bf a0 '                         mov     vscl,hvis               'setup in case blank line
5be8(0054): ff 52 be a0 '                         mov     tile,phaseflip
5bec(0055): 00 00 7c 5c ' hsync_ret               ret
5bf0(0056): 06 b5 fc 50 ' vsync_high              movs    vsync1,#sync_high1      'vertical sync
5bf4(0057): 07 b9 fc 50 '                         movs    vsync2,#sync_high2
5bf8(0058): 32 3f be a0 ' vsync_low               mov     x,vrep
5bfc(0059): 35 ff bf a0 ' vsyncx                  mov     vscl,sync_scale1
5c00(005a): 06 67 3e fc ' vsync1                  waitvid burst,sync_high1
5c04(005b): 36 ff bf a0 '                         mov     vscl,sync_scale2
5c08(005c): 07 67 3e fc ' vsync2                  waitvid burst,sync_high2
5c0c(005d): 59 3e fe e4 '                         djnz    x,#vsyncx
5c10(005e):             ' vsync_low_ret
5c10(005e): 00 00 7c 5c ' vsync_high_ret          ret
5c14(005f): f0 37 be a0 ' tasks                   mov     t1,par                  'load parameters
5c18(0060): 38 c7 fc 54 '                         movd    :par,#_enable           '(skip _status)
5c1c(0061): 0d 38 fe a0 '                         mov     t2,#paramcount - 1
5c20(0062): 04 36 fe 80 ' :load                   add     t1,#4
5c24(0063): 1b 01 bc 08 ' :par                    rdlong  0,t1
5c28(0064): f9 c6 bc 80 '                         add     :par,d0
5c2c(0065): 62 38 fe e4 '                         djnz    t2,#:load               '+119
5c30(0066): 39 37 be a0 '                         mov     t1,_pins                'set video pins and directions
5c34(0067): 08 36 7e 61 '                         test    t1,#$08         wc
5c38(0068): 04 39 8e a0 '         if_nc           mov     t2,pins0
5c3c(0069): 05 39 b2 a0 '         if_c            mov     t2,pins1
5c40(006a): 40 36 7e 61 '                         test    t1,#$40         wc
5c44(006b): 01 36 fe 28 '                         shr     t1,#1
5c48(006c): 03 36 fe 2c '                         shl     t1,#3
5c4c(006d): 1b 39 be 28 '                         shr     t2,t1
5c50(006e): 1c fd bf 50 '                         movs    vcfg,t2
5c54(006f): 06 36 fe 28 '                         shr     t1,#6
5c58(0070): 1b fd bf 54 '                         movd    vcfg,t1
5c5c(0071): 03 36 fe 2c '                         shl     t1,#3
5c60(0072): ff 38 fe 60 '                         and     t2,#$FF
5c64(0073): 1b 39 be 2c '                         shl     t2,t1
5c68(0074): 1c ed 8f a0 '         if_nc           mov     dira,t2
5c6c(0075): 00 ee cf a0 '         if_nc           mov     dirb,#0
5c70(0076): 00 ec f3 a0 '         if_c            mov     dira,#0
5c74(0077): 1c ef b3 a0 '         if_c            mov     dirb,t2                 '+18
5c78(0078): ed 70 7e ec '                         tjz     _enable,#disabled       '+2, disabled?
5c7c(0079): 1a 33 be 5c '                         jmpret  taskptr,taskret         '+1=140, break and return later
5c80(007a): 0a fd fc 50 '                         movs    :rd,#wtab               'load ntsc/pal metrics from word table
5c84(007b): 2d 05 fd 54 '                         movd    :wr,#hvis
5c88(007c): 07 36 fe a0 '                         mov     t1,#wtabx - wtab
5c8c(007d): 01 74 7e 61 '                         test    _mode,#%0001    wc
5c90(007e): 00 38 be a0 ' :rd                     mov     t2,0
5c94(007f): 01 fc fc 80 '                         add     :rd,#1
5c98(0080): 10 38 ce 2c '         if_nc           shl     t2,#16
5c9c(0081): 10 38 fe 28 '                         shr     t2,#16
5ca0(0082): 1c 01 bc a0 ' :wr                     mov     0,t2
5ca4(0083): f9 04 bd 80 '                         add     :wr,d0
5ca8(0084): 7e 36 fe e4 '                         djnz    t1,#:rd                 '+54
5cac(0085): 11 13 cd 50 '         if_nc           movs    :ltab,#ltab             'load ntsc/pal metrics from long table
5cb0(0086): 12 13 f1 50 '         if_c            movs    :ltab,#ltab+1
5cb4(0087): 34 13 fd 54 '                         movd    :ltab,#fcolor
5cb8(0088): 04 36 fe a0 '                         mov     t1,#(ltabx - ltab) >> 1
5cbc(0089): 00 00 bc a0 ' :ltab                   mov     0,0
5cc0(008a): fb 12 bd 80 '                         add     :ltab,d0s1
5cc4(008b): 89 36 fe e4 '                         djnz    t1,#:ltab               '+17
5cc8(008c): 00 36 fe 08 '                         rdlong  t1,#0                   'get CLKFREQ
5ccc(008d): 01 36 fe 28 '                         shr     t1,#1                   'if CLKFREQ < 16MHz, cancel _broadcast
5cd0(008e): f7 36 3e 85 '                         cmp     t1,m8           wc
5cd4(008f): 00 86 f2 a0 '         if_c            mov     _broadcast,#0
5cd8(0090): 01 36 fe 28 '                         shr     t1,#1                   'if CLKFREQ < color frequency * 4, disable
5cdc(0091): 34 37 3e 85 '                         cmp     t1,fcolor       wc
5ce0(0092): ed 00 70 5c '         if_c            jmp     #disabled               '+11
5ce4(0093): 1a 33 be 5c '                         jmpret  taskptr,taskret         '+1=83, break and return later
5ce8(0094): 34 37 be a0 '                         mov     t1,fcolor               'set ctra pll to fcolor * 16
5cec(0095): e0 cc fd 5c '                         call    #divide                 'if ntsc, set vco to fcolor * 32 (114.5454 MHz)
5cf0(0096): 01 74 7e 61 '                         test    _mode,#%0001    wc      'if pal, set vco to fcolor * 16 (70.9379 MHz)
5cf4(0097): 0f f0 f3 58 '         if_c            movi    ctra,#%00001_111        'select fcolor * 16 output (ntsc=/2, pal=/1)
5cf8(0098): 0e f0 cf 58 '         if_nc           movi    ctra,#%00001_110
5cfc(0099): 01 38 ce 2c '         if_nc           shl     t2,#1
5d00(009a): 1c f5 bf a0 '                         mov     frqa,t2                 '+147
5d04(009b): 1a 33 be 5c '                         jmpret  taskptr,taskret         '+1=148, break and return later
5d08(009c): 43 37 be a0 '                         mov     t1,_broadcast           'set ctrb pll to _broadcast
5d0c(009d): 00 38 fe a0 '                         mov     t2,#0                   'if 0, turn off ctrb
5d10(009e): a6 36 7e ec '                         tjz     t1,#:off
5d14(009f): f7 36 be 48 '                         min     t1,m8                   'limit from 8MHz to 128MHz
5d18(00a0): f8 36 be 4c '                         max     t1,m128
5d1c(00a1): 0c 38 fe a0 '                         mov     t2,#%00001_100          'adjust _broadcast to be within 4MHz-8MHz
5d20(00a2): 01 36 fe 28 ' :scale                  shr     t1,#1                   '(vco will be within 64MHz-128MHz)
5d24(00a3): 1b ef 3d 85 '                         cmp     m8,t1           wc
5d28(00a4): 01 38 f2 80 '         if_c            add     t2,#%00000_001
5d2c(00a5): a2 00 70 5c '         if_c            jmp     #:scale
5d30(00a6): 1c f3 bf 58 ' :off                    movi    ctrb,t2
5d34(00a7): e0 cc fd 5c '                         call    #divide
5d38(00a8): 1c f7 bf a0 '                         mov     frqb,t2                 '+165
5d3c(00a9): 1a 33 be 5c '                         jmpret  taskptr,taskret         '+1=166, break and return later
5d40(00aa): a0 36 fe a0 '                         mov     t1,#%10100_000          'set video configuration
5d44(00ab): 01 72 7e 61 '                         test    _pins,#$01      wc      '(swap broadcast/baseband output bits?)
5d48(00ac): 40 36 f2 68 '         if_c            or      t1,#%01000_000
5d4c(00ad): 08 74 7e 61 '                         test    _mode,#%1000    wc      '(strip chroma from broadcast?)
5d50(00ae): 10 36 ce 68 '         if_nc           or      t1,#%00010_000
5d54(00af): 04 74 7e 61 '                         test    _mode,#%0100    wc      '(strip chroma from baseband?)
5d58(00b0): 08 36 ce 68 '         if_nc           or      t1,#%00001_000
5d5c(00b1): 07 88 fe 60 '                         and     _auralcog,#%111         '(set aural cog)
5d60(00b2): 44 37 be 68 '                         or      t1,_auralcog
5d64(00b3): 1b fd bf 58 '                         movi    vcfg,t1                 '+10
5d68(00b4): 3f 4b be a0 '                         mov     hx,_hx                  'compute horizontal metrics
5d6c(00b5): 08 4a fe 2c '                         shl     hx,#8
5d70(00b6): 3f 4b be 68 '                         or      hx,_hx
5d74(00b7): 04 4a fe 2c '                         shl     hx,#4
5d78(00b8): 3d 4f be a0 '                         mov     hc2x,_ht
5d7c(00b9): 01 4e fe 2c '                         shl     hc2x,#1
5d80(00ba): 3d 37 be a0 '                         mov     t1,_ht
5d84(00bb): 3f 39 be a0 '                         mov     t2,_hx
5d88(00bc): e7 d8 fd 5c '                         call    #multiply
5d8c(00bd): 2d 43 be a0 '                         mov     hf,hvis
5d90(00be): 1b 43 be 84 '                         sub     hf,t1
5d94(00bf): 01 42 fe 29 '                         shr     hf,#1           wc
5d98(00c0): 41 45 be a0 '                         mov     hb,_ho
5d9c(00c1): 21 45 be c8 '                         addx    hb,hf
5da0(00c2): 41 43 be 84 '                         sub     hf,_ho                  '+52
5da4(00c3): 3e 37 be a0 '                         mov     t1,_vt                  'compute vertical metrics
5da8(00c4): 40 39 be a0 '                         mov     t2,_vx
5dac(00c5): e7 d8 fd 5c '                         call    #multiply
5db0(00c6): 01 36 fe 28 '                         shr     t1,#1           'JB MOD this divides the screen size by two, as tile size is now 16 not 32 pixels.
5db4(00c7): 10 74 7e 61 '                         test    _mode,#%10000   wc      'consider tile size
5db8(00c8): 01 06 fe 70 '                         muxc    linerot,#1
5dbc(00c9): 02 57 be a0 '                         mov     lineadd,lineinc
5dc0(00ca): 01 56 f2 28 '         if_c            shr     lineadd,#1
5dc4(00cb): 01 36 f2 2c '         if_c            shl     t1,#1
5dc8(00cc): 02 74 7e 61 '                         test    _mode,#%0010    wc      'consider interlace
5dcc(00cd): 01 36 f2 28 '         if_c            shr     t1,#1
5dd0(00ce): 30 47 be a0 '                         mov     vf,vvis
5dd4(00cf): 1b 47 be 84 '                         sub     vf,t1
5dd8(00d0): 01 46 fe 29 '                         shr     vf,#1           wc
5ddc(00d1): 42 49 be a4 '                         neg     vb,_vo
5de0(00d2): 23 49 be c8 '                         addx    vb,vf
5de4(00d3): 42 47 be 80 '                         add     vf,_vo                  '+53
5de8(00d4): 02 74 fe 6c '                         xor     _mode,#%0010            '+1, flip interlace bit for display
5dec(00d5): 1a 33 be 5c ' :colors                 jmpret  taskptr,taskret         '+1=117/160, break and return later
5df0(00d6): 0d 36 fe a0 '                         mov     t1,#13                  'load next 13 colors into colortable
5df4(00d7): db 38 be a0 ' :colorloop              mov     t2,:colorreg            '5 times = 65 (all 64 colors loaded)
5df8(00d8): 07 38 fe 28 '                         shr     t2,#9-2
5dfc(00d9): fc 38 fe 60 '                         and     t2,#$FC
5e00(00da): 3c 39 be 80 '                         add     t2,_colors
5e04(00db): 1c 01 bf 08 ' :colorreg               rdlong  colortable,t2
5e08(00dc): f9 b6 bd 80 '                         add     :colorreg,d0
5e0c(00dd): fa b6 bd 64 '                         andn    :colorreg,d6
5e10(00de): d7 36 fe e4 '                         djnz    t1,#:colorloop          '+158
5e14(00df): d5 00 7c 5c '                         jmp     #:colors                '+1, keep loading colors
5e18(00e0): 00 3a fe 08 ' divide                  rdlong  m1,#0                   'get CLKFREQ
5e1c(00e1): 21 3c fe a0 '                         mov     m2,#32+1
5e20(00e2): 1d 37 be e1 ' :loop                   cmpsub  t1,m1           wc
5e24(00e3): 01 38 fe 34 '                         rcl     t2,#1
5e28(00e4): 01 36 fe 2c '                         shl     t1,#1
5e2c(00e5): e2 3c fe e4 '                         djnz    m2,#:loop
5e30(00e6): 00 00 7c 5c ' divide_ret              ret                             '+140
5e34(00e7): 0b 38 fe 2c ' multiply                shl     t2,#8+4-1
5e38(00e8): 08 3a fe a0 '                         mov     m1,#8
5e3c(00e9): 01 36 fe 29 ' :loop                   shr     t1,#1           wc
5e40(00ea): 1c 37 b2 80 '         if_c            add     t1,t2
5e44(00eb): e9 3a fe e4 '                         djnz    m1,#:loop
5e48(00ec): 00 00 7c 5c ' multiply_ret            ret                             '+37
5e4c(00ed): 00 f0 ff a0 ' disabled                mov     ctra,#0                 'reset ctra
5e50(00ee): 00 f2 ff a0 '                         mov     ctrb,#0                 'reset ctrb
5e54(00ef): 00 fc ff a0 '                         mov     vcfg,#0                 'reset video
5e58(00f0): f0 e9 3f 08 '                         wrlong  outa,par                'set status to disabled
5e5c(00f1): 00 36 fe 08 '                         rdlong  t1,#0                   'get CLKFREQ
5e60(00f2): 08 36 fe 28 '                         shr     t1,#8                   'nap for ~4ms
5e64(00f3): 03 36 fe 48 '                         min     t1,#3
5e68(00f4): f1 37 be 80 '                         add     t1,cnt
5e6c(00f5): 00 36 fe f8 '                         waitcnt t1,#0
5e70(00f6): 00 00 7c 5c '                         jmp     #entry                  'reload parameters
5e74(00f7): 00 12 7a 00 ' m8                      long    8_000_000
5e78(00f8): 00 20 a1 07 ' m128                    long    128_000_000
5e7c(00f9): 00 02 00 00 ' d0                      long    1 << 9 << 0
5e80(00fa): 00 80 00 00 ' d6                      long    1 << 9 << 6
5e84(00fb): 02 02 00 00 ' d0s1                    long    1 << 9 << 0 + 1 << 1
5e88(00fc): 00 00 00 00 ' interlace               long    0
5e8c(00fd): 01 00 00 00 ' invisible               long    1
5e90(00fe): 02 00 00 00 ' visible                 long    2
5e94(00ff): 00 00 00 00 ' phaseflip               long    $00000000
5e98(0100): f0 f0 f0 f0 ' phasemask               long    $F0F0F0F0
5e9c(0101): 00 00 06 00 ' line                    long    $00060000
5ea0(0102): 00 00 00 20 ' lineinc                 long    $20000000       'JB MOD lineinc is now $20000000 so that it carries over in 8 loops instead of 16 for a half tile.
5ea4(0103): 00 00 00 00 ' linerot                 long    0
5ea8(0104): 07 0f 70 f0 ' pins0                   long    %11110000_01110000_00001111_00000111
5eac(0105): 77 7f f7 ff ' pins1                   long    %11111111_11110111_01111111_01110111
5eb0(0106): a5 56 55 55 ' sync_high1              long    %0101010101010101010101_101010_0101
5eb4(0107): 55 55 55 55 ' sync_high2              long    %01010101010101010101010101010101       'used for black
5eb8(0108): a5 aa aa aa ' sync_low1               long    %1010101010101010101010101010_0101
5ebc(0109): aa aa aa 6a ' sync_low2               long    %01_101010101010101010101010101010
5ec0(010a): c8 0b 6c 0e ' wtab                    word    lntsc - sntsc,          lpal - spal     'hvis
5ec4(010b): ac 04 8e 05 '                         word    lntsc / 2 - sntsc,      lpal / 2 - spal 'hrest
5ec8(010c): 1c 07 de 08 '                         word    lntsc / 2,              lpal / 2        'hhalf
5ecc(010d): f3 00 1e 01 '                         word    243,                    286             'vvis
5ed0(010e): 0a 00 12 00 '                         word    10,                     18              'vinv
5ed4(010f): 06 00 05 00 '                         word    6,                      5               'vrep
5ed8(0110): 8a 02 aa 02 '                         word    $02_8A,                 $02_AA          'burst
5edc(0111):             ' wtabx
5edc(0111): 99 9e 36 00 ' ltab                    long    fntsc                                   'fcolor
5ee0(0112): d2 a6 43 00 '                         long    fpal
5ee4(0113): 70 72 02 00 '                         long    sntsc >> 4 << 12 + sntsc                'sync_scale1
5ee8(0114): 50 53 03 00 '                         long    spal >> 4 << 12 + spal
5eec(0115): ac 34 04 00 '                         long    67 << 12 + lntsc / 2 - sntsc            'sync_scale2
5ef0(0116): 8e f5 04 00 '                         long    79 << 12 + lpal / 2 - spal
5ef4(0117): a5 aa 06 50 '                         long    %0101_00000000_01_10101010101010_0101   'sync_normal
5ef8(0118): a5 aa 01 54 '                         long    %010101_00000000_01_101010101010_0101
5efc(0119):             ' ltabx
5efc(0119):             ' taskptr                 res     1                       'tasks
5efc(011a):             ' taskret                 res     1
5efc(011b):             ' t1                      res     1
5efc(011c):             ' t2                      res     1
5efc(011d):             ' m1                      res     1
5efc(011e):             ' m2                      res     1
5efc(011f):             ' x                       res     1                       'display
5efc(0120):             ' y                       res     1
5efc(0121):             ' hf                      res     1
5efc(0122):             ' hb                      res     1
5efc(0123):             ' vf                      res     1
5efc(0124):             ' vb                      res     1
5efc(0125):             ' hx                      res     1
5efc(0126):             ' vx                      res     1
5efc(0127):             ' hc2x                    res     1
5efc(0128):             ' screen                  res     1
5efc(0129):             ' tile                    res     1
5efc(012a):             ' pixels                  res     1
5efc(012b):             ' lineadd                 res     1
5efc(012c):             ' pixels2                 res     1
5efc(012d):             ' hvis                    res     1                       'loaded from word table
5efc(012e):             ' hrest                   res     1
5efc(012f):             ' hhalf                   res     1
5efc(0130):             ' vvis                    res     1
5efc(0131):             ' vinv                    res     1
5efc(0132):             ' vrep                    res     1
5efc(0133):             ' burst                   res     1
5efc(0134):             ' fcolor                  res     1                       'loaded from long table
5efc(0135):             ' sync_scale1             res     1
5efc(0136):             ' sync_scale2             res     1
5efc(0137):             ' sync_normal             res     1
5efc(0138):             ' _enable                 res     1       '0/non-0        read-only
5efc(0139):             ' _pins                   res     1       '%pppmmmm       read-only
5efc(013a):             ' _mode                   res     1       '%tccip         read-only
5efc(013b):             ' _screen                 res     1       '@word          read-only
5efc(013c):             ' _colors                 res     1       '@long          read-only
5efc(013d):             ' _ht                     res     1       '1+             read-only
5efc(013e):             ' _vt                     res     1       '1+             read-only
5efc(013f):             ' _hx                     res     1       '4+             read-only
5efc(0140):             ' _vx                     res     1       '1+             read-only
5efc(0141):             ' _ho                     res     1       '0+-            read-only
5efc(0142):             ' _vo                     res     1       '0+-            read-only
5efc(0143):             ' _broadcast              res     1       '0+             read-only
5efc(0144):             ' _auralcog               res     1       '0-7            read-only
'=========================== Method #1: PUB start =============================
'PUB start(tvptr) : okay
'------------------------------------------------------------------------------
  stop
'------------------------------------------------------------------------------
5efc: 01             FRAME	Call without return value	
5efd: 05 02          CALL 	+2 
'------------------------------------------------------------------------------
  okay := cog := cognew(@entry, tvptr) + 1
'------------------------------------------------------------------------------
5eff: 34             PUSH#-1	
5f00: c7 0c          PUSH#.L	OBJ+12
5f02: 64             PUSH 	Locals+4
5f03: 28             COGIFUN	
5f04: 36             PUSH#1	
5f05: ec             ADD  	
5f06: 42 80          USING	VAR+0, COPY, PUSH
5f08: 61             POP  	Locals+0
5f09: 32             RETURN	
'============================ Method #2: PUB stop =============================
'PUB stop                                                                                                                                
'------------------------------------------------------------------------------
  if cog
'------------------------------------------------------------------------------
5f0a: 40             PUSH 	VAR+0
5f0b: 0a 05          JPF  	.+5 (dest:$5f12)
'------------------------------------------------------------------------------
    cogstop(cog~ - 1)
'------------------------------------------------------------------------------
5f0d: 42 98          USING	VAR+0, POSTCLR, PUSH
5f0f: 36             PUSH#1	
5f10: ed             SUB  	
5f11: 21             COGSTOP	
5f12: 32             RETURN	
5f13: 00          

'******************************************************************************
'                            Catalina_Common.spin                              
'******************************************************************************

'=================================== CONs =====================================
KBD_PIN = 26
MOUSE_PIN = 24
TV_PIN = 12
CLOCKMODE = 1032
XTALFREQ = 5000000
NTSC_PAL = 1
INTERLACE = 1
STACKSIZE = 50
LMM_HMI = 1
COGSTORE = 32508
REGISTRY_END = 32508
REGISTRY = 32476
REQUESTS = 32412
ARGC_ADDR = 32560
ARGV_ADDR = 32562
ARGV_0 = 32564
ARGV_MAX = 32
'=============================== Object Header ================================
5f14: 88 00 06 00 ' 136 bytes, 6-1 methods, 0 object pointers
5f18: 18 00 04 00 ' ptr #1 to $5f2c: PUB InitializeRegistry (locals size: 4)
5f1c: 42 00 00 00 ' ptr #2 to $5f56: PUB Register (locals size: 0)
5f20: 55 00 00 00 ' ptr #3 to $5f69: PUB UnRegister (locals size: 0)
5f24: 63 00 00 00 ' ptr #4 to $5f77: PUB SendInitializationData (locals size: 0)
5f28: 78 00 00 00 ' ptr #5 to $5f8c: PUB WaitForRequest (locals size: 0)
'===================== Method #1: PUB InitializeRegistry ======================
'PUB InitializeRegistry | i
'------------------------------------------------------------------------------
  repeat i from 0 to 7
'------------------------------------------------------------------------------
5f2c: 35             PUSH#0	
5f2d: 65             POP  	Locals+4
'------------------------------------------------------------------------------
    long[REGISTRY][i] := REQUESTS + (8*i)
'------------------------------------------------------------------------------
5f2e: 39 7e 9c       PUSH#k2	32412
5f31: 37 02          PUSH#kp	8 ($8)
5f33: 64             PUSH 	Locals+4
5f34: f4             MPY  	
5f35: ec             ADD  	
5f36: 39 7e dc       PUSH#k2	32476
5f39: 64             PUSH 	Locals+4
5f3a: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
    long[REQUESTS][2 * i] := 0
'------------------------------------------------------------------------------
5f3b: 35             PUSH#0	
5f3c: 39 7e 9c       PUSH#k2	32412
5f3f: 37 00          PUSH#kp	2 ($2)
5f41: 64             PUSH 	Locals+4
5f42: f4             MPY  	
5f43: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
    long[REQUESTS][2 * i + 1] := 0
'------------------------------------------------------------------------------
5f44: 35             PUSH#0	
5f45: 39 7e 9c       PUSH#k2	32412
5f48: 37 00          PUSH#kp	2 ($2)
5f4a: 64             PUSH 	Locals+4
5f4b: f4             MPY  	
5f4c: 36             PUSH#1	
5f4d: ec             ADD  	
5f4e: d1             POP.L	Mem[][]
5f4f: 35             PUSH#0	
5f50: 37 22          PUSH#kp	7 ($7)
5f52: 66 02 59       USING	Locals+4, RPTINCJ .-39 (dest:$5f2e)
5f55: 32             RETURN	
'========================== Method #2: PUB Register ===========================
'PUB Register (my_cog, my_plugin_type)
'------------------------------------------------------------------------------
  long[REGISTRY][my_cog] := (my_plugin_type<<24) + (long[REGISTRY][my_cog] & $00FFFFFF)
'------------------------------------------------------------------------------
5f56: 68             PUSH 	Locals+8
5f57: 38 18          PUSH#k1	24
5f59: e3             SHL  	
5f5a: 39 7e dc       PUSH#k2	32476
5f5d: 64             PUSH 	Locals+4
5f5e: d0             PUSH.L	Mem[][]
5f5f: 37 37          PUSH#kp	16777215 ($ffffff)
5f61: e8             BIT_AND	
5f62: ec             ADD  	
5f63: 39 7e dc       PUSH#k2	32476
5f66: 64             PUSH 	Locals+4
5f67: d1             POP.L	Mem[][]
5f68: 32             RETURN	
'========================= Method #3: PUB UnRegister ==========================
'PUB UnRegister (my_cog)
'------------------------------------------------------------------------------
  long[REGISTRY][my_cog] := (long[REGISTRY][my_cog] & $00FFFFFF)
'------------------------------------------------------------------------------
5f69: 39 7e dc       PUSH#k2	32476
5f6c: 64             PUSH 	Locals+4
5f6d: d0             PUSH.L	Mem[][]
5f6e: 37 37          PUSH#kp	16777215 ($ffffff)
5f70: e8             BIT_AND	
5f71: 39 7e dc       PUSH#k2	32476
5f74: 64             PUSH 	Locals+4
5f75: d1             POP.L	Mem[][]
5f76: 32             RETURN	
'=================== Method #4: PUB SendInitializationData ====================
'PUB SendInitializationData(to_cog, data_1, data_2)
'------------------------------------------------------------------------------
  long[REQUESTS][2 * to_cog + 1] := data_2
'------------------------------------------------------------------------------
5f77: 6c             PUSH 	Locals+12
5f78: 39 7e 9c       PUSH#k2	32412
5f7b: 37 00          PUSH#kp	2 ($2)
5f7d: 64             PUSH 	Locals+4
5f7e: f4             MPY  	
5f7f: 36             PUSH#1	
5f80: ec             ADD  	
5f81: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[REQUESTS][2 * to_cog]     := data_1
'------------------------------------------------------------------------------
5f82: 68             PUSH 	Locals+8
5f83: 39 7e 9c       PUSH#k2	32412
5f86: 37 00          PUSH#kp	2 ($2)
5f88: 64             PUSH 	Locals+4
5f89: f4             MPY  	
5f8a: d1             POP.L	Mem[][]
5f8b: 32             RETURN	
'======================= Method #5: PUB WaitForRequest ========================
'PUB WaitForRequest(to_cog)
'------------------------------------------------------------------------------
  repeat while long[REQUESTS][2 * to_cog] <> 0
'------------------------------------------------------------------------------
5f8c: 39 7e 9c       PUSH#k2	32412
5f8f: 37 00          PUSH#kp	2 ($2)
5f91: 64             PUSH 	Locals+4
5f92: f4             MPY  	
5f93: d0             PUSH.L	Mem[][]
5f94: 35             PUSH#0	
5f95: fb             NE   	
5f96: 0a 02          JPF  	.+2 (dest:$5f9a)
5f98: 04 72          GOTO 	.-14 (dest:$5f8c)
5f9a: 32             RETURN	
5f9b: 00          
5f9c: 00 00 00 00             ' LONG HMI.v_io_block
5fa0: 00 00 00 00             ' LONG HMI.v_proxy_lock
5fa4: 00 00 00 00             ' LONG HMI.v_server_cpu
5fa8: 00 00 00 00             ' LONG HMI.screen.tv.cog
5fac: ff ff f9 ff ff ff f9 ff 

