0000: 00 b4 c4 04 ' Frequency: 80000000 Hz
0004: 6f          ' XTAL mode
0005: d2          ' Checksum
0006: 10 00       ' Base of program
0008: ec 3b       ' Base of variables
000a: 00 3c       ' Base of stack
000c: 2c 00       ' Initial program counter
000e: 20 3c       ' Initial stack pointer

'******************************************************************************
'                              lmm_default.spin                                
'******************************************************************************

'=================================== CONs =====================================
_clkmode = 1032
_xinfreq = 5000000
_stack = 50
START_SCREEN = -1
START_KBD = -1
START_MOUSE = -1
'=============================== Object Header ================================
0010: 6c 00 02 05 ' 108 bytes, 2-1 methods, 5 object pointers
0014: 1c 00 1c 00 ' ptr #1 to $002c: PUB Start (locals size: 28)
0018: 6c 00 00 00 ' ptr #2 to $007c: OBJ Catalina : Catalina.spin (VAR offset: 0)
001c: 54 3b 00 00 ' ptr #3 to $3b64: OBJ Common : Catalina_Common.spin (VAR offset: 0)
0020: 08 2a 00 00 ' ptr #4 to $2a18: OBJ Cogstore : Catalina_Cogstore.spin (VAR offset: 0)
0024: b4 2d 00 00 ' ptr #5 to $2dc4: OBJ Kernel : Catalina_LMM.spin (VAR offset: 0)
0028: 5c 35 00 00 ' ptr #6 to $356c: OBJ HMI : Catalina_HMI_Plugin_PC.spin (VAR offset: 0)
'=========================== Method #1: PUB Start =============================
'PUB Start : ok | cog, ALLOC, HMI_DATA, IO_BLOCK, Proxy_Lock, Server_CPU, s
'------------------------------------------------------------------------------
  Common.InitializeRegistry
'------------------------------------------------------------------------------
002c: 01             FRAME	Call without return value	
002d: 06 03 01       CALLOBJ	3:1
'------------------------------------------------------------------------------
  ALLOC := Common#REQUESTS
'------------------------------------------------------------------------------
0030: 39 7e 9c       PUSH#k2	32412
0033: 69             POP  	Locals+8
'------------------------------------------------------------------------------
  ok         := TRUE
'------------------------------------------------------------------------------
0034: 34             PUSH#-1	
0035: 61             POP  	Locals+0
'------------------------------------------------------------------------------
  Proxy_Lock := -1
'------------------------------------------------------------------------------
0036: 34             PUSH#-1	
0037: 75             POP  	Locals+20
'------------------------------------------------------------------------------
  s := CogStore.Size
'------------------------------------------------------------------------------
0038: 00             FRAME	Call with return value	
0039: 06 04 06       CALLOBJ	4:6
003c: 7d             POP  	Locals+28
'------------------------------------------------------------------------------
  if (s => 0)
'------------------------------------------------------------------------------
003d: 7c             PUSH 	Locals+28
003e: 35             PUSH#0	
003f: fe             GE   	
0040: 0a 07          JPF  	.+7 (dest:$0049)
'------------------------------------------------------------------------------
    ALLOC := ALLOC - s*4
'------------------------------------------------------------------------------
0042: 68             PUSH 	Locals+8
0043: 7c             PUSH 	Locals+28
0044: 37 01          PUSH#kp	4 ($4)
0046: f4             MPY  	
0047: ed             SUB  	
0048: 69             POP  	Locals+8
'------------------------------------------------------------------------------
  CogStore.Setup(ALLOC)
'------------------------------------------------------------------------------
0049: 01             FRAME	Call without return value	
004a: 68             PUSH 	Locals+8
004b: 06 04 07       CALLOBJ	4:7
'------------------------------------------------------------------------------
  CogStore.Stop
'------------------------------------------------------------------------------
004e: 01             FRAME	Call without return value	
004f: 06 04 03       CALLOBJ	4:3
'------------------------------------------------------------------------------
  HMI_DATA := ALLOC - 4 * HMI#DATASIZE
'------------------------------------------------------------------------------
0052: 68             PUSH 	Locals+8
0053: 37 01          PUSH#kp	4 ($4)
0055: 39 01 28       PUSH#k2	296
0058: f4             MPY  	
0059: ed             SUB  	
005a: 6d             POP  	Locals+12
'------------------------------------------------------------------------------
  ALLOC    := HMI_DATA
'------------------------------------------------------------------------------
005b: 6c             PUSH 	Locals+12
005c: 69             POP  	Locals+8
'------------------------------------------------------------------------------
  if ok
'------------------------------------------------------------------------------
005d: 60             PUSH 	Locals+0
005e: 0a 0c          JPF  	.+12 (dest:$006c)
'------------------------------------------------------------------------------
    ok := HMI.Start(Common#REGISTRY, HMI_DATA, START_KBD, START_MOUSE, START_SCREEN)
'------------------------------------------------------------------------------
0060: 00             FRAME	Call with return value	
0061: 39 7e dc       PUSH#k2	32476
0064: 6c             PUSH 	Locals+12
0065: 34             PUSH#-1	
0066: 34             PUSH#-1	
0067: 34             PUSH#-1	
0068: 06 06 02       CALLOBJ	6:2
006b: 61             POP  	Locals+0
'------------------------------------------------------------------------------
  Kernel.Run (Common#REGISTRY, Common#REQUESTS, Catalina.Base, ALLOC)
'------------------------------------------------------------------------------
006c: 01             FRAME	Call without return value	
006d: 39 7e dc       PUSH#k2	32476
0070: 39 7e 9c       PUSH#k2	32412
0073: 00             FRAME	Call with return value	
0074: 06 02 01       CALLOBJ	2:1
0077: 68             PUSH 	Locals+8
0078: 06 05 02       CALLOBJ	5:2
007b: 32             RETURN	

'******************************************************************************
'                                Catalina.spin                                 
'******************************************************************************

'=================================== CONs =====================================
SEGMENT_LAYOUT = 0
'=============================== Object Header ================================
007c: 9c 29 02 00 ' 10652 bytes, 2-1 methods, 0 object pointers
0080: 94 29 00 00 ' ptr #1 to $2a10: PUB Base (locals size: 0)
'================================ DAT Section =================================
0084(0000):             '         org  0
0084(0000): 00 00 00 00 '         long 0          '$00
0088(0001): 00 00 00 00 '         long 0          '$01
008c(0002): 00 00 3c 5c ' INIT    jmp  0          '$02
0090(0003): 00 00 3c 5c ' LODL    jmp  0          '$03
0094(0004): 00 00 3c 5c ' LODA    jmp  0          '$04
0098(0005): 00 00 3c 5c ' LODF    jmp  0          '$05
009c(0006): 00 00 3c 5c ' PSHL    jmp  0          '$06
00a0(0007): 00 00 3c 5c ' PSHB    jmp  0          '$07
00a4(0008): 00 00 3c 5c ' CPYB    jmp  0          '$08
00a8(0009): 00 00 3c 5c ' NEWF    jmp  0          '$09
00ac(000a): 00 00 3c 5c ' RETF    jmp  0          '$0a
00b0(000b): 00 00 3c 5c ' CALA    jmp  0          '$0b
00b4(000c): 00 00 3c 5c ' RETN    jmp  0          '$0c
00b8(000d): 00 00 3c 5c ' CALI    jmp  0          '$0d
00bc(000e): 00 00 3c 5c ' JMPA    jmp  0          '$0e
00c0(000f): 00 00 3c 5c ' JMPI    jmp  0          '$0f
00c4(0010): 00 00 3c 5c ' DIVS    jmp  0          '$10
00c8(0011): 00 00 3c 5c ' DIVU    jmp  0          '$11
00cc(0012): 00 00 3c 5c ' MULT    jmp  0          '$12
00d0(0013): 00 00 3c 5c ' BR_Z    jmp  0          '$13
00d4(0014): 00 00 3c 5c ' BRNZ    jmp  0          '$14
00d8(0015): 00 00 3c 5c ' BRAE    jmp  0          '$15
00dc(0016): 00 00 3c 5c ' BR_A    jmp  0          '$16
00e0(0017): 00 00 3c 5c ' BRBE    jmp  0          '$17
00e4(0018): 00 00 3c 5c ' BR_B    jmp  0          '$18
00e8(0019): 00 00 3c 5c ' SYSP    jmp  0          '$19
00ec(001a): 00 00 3c 5c ' PSHA    jmp  0          '$1a
00f0(001b): 00 00 3c 5c ' FADD    jmp  0          '$1b
00f4(001c): 00 00 3c 5c ' FSUB    jmp  0          '$1c
00f8(001d): 00 00 3c 5c ' FMUL    jmp  0          '$1d
00fc(001e): 00 00 3c 5c ' FDIV    jmp  0          '$1e
0100(001f): 00 00 3c 5c ' FCMP    jmp  0          '$1f
0104(0020): 00 00 3c 5c ' FLIN    jmp  0          '$20
0108(0021): 00 00 3c 5c ' INFL    jmp  0          '$21
010c(0022): 00 00 3c 5c ' PSHM    jmp  0          '$22
0110(0023): 00 00 3c 5c ' POPM    jmp  0          '$23
0114(0024): 00 00 3c 5c ' PSHF    jmp  0          '$24
0118(0025): 00 00 3c 5c ' RLNG    jmp  0          '$25
011c(0026): 00 00 3c 5c ' RWRD    jmp  0          '$26
0120(0027): 00 00 3c 5c ' RBYT    jmp  0          '$27
0124(0028): 00 00 3c 5c ' WLNG    jmp  0          '$28
0128(0029): 00 00 3c 5c ' WWRD    jmp  0          '$29
012c(002a): 00 00 3c 5c ' WBYT    jmp  0          '$2a
0130(002b): 00 00 00 00 ' PC      long 0          '$2b
0134(002c): 00 00 00 00 ' SP      long 0          '$2c
0138(002d): 00 00 00 00 ' FP      long 0          '$2d
013c(002e): 00 00 00 00 ' RI      long 0          '$2e
0140(002f): 00 00 00 00 ' BC      long 0          '$2f
0144(0030): 00 00 00 00 ' BA      long 0          '$30
0148(0031): 00 00 00 00 ' BZ      long 0          '$31
014c(0032): 00 00 00 00 ' CS      long 0          '$32
0150(0033): 00 00 00 00 ' r0      long 0          '$33
0154(0034): 00 00 00 00 ' r1      long 0          '$34
0158(0035): 00 00 00 00 ' r2      long 0          '$35
015c(0036): 00 00 00 00 ' r3      long 0          '$36
0160(0037): 00 00 00 00 ' r4      long 0          '$37
0164(0038): 00 00 00 00 ' r5      long 0          '$38
0168(0039): 00 00 00 00 ' r6      long 0          '$39
016c(003a): 00 00 00 00 ' r7      long 0          '$3a
0170(003b): 00 00 00 00 ' r8      long 0          '$3b
0174(003c): 00 00 00 00 ' r9      long 0          '$3c
0178(003d): 00 00 00 00 ' r10     long 0          '$3d
017c(003e): 00 00 00 00 ' r11     long 0          '$3e
0180(003f): 00 00 00 00 ' r12     long 0          '$3f
0184(0040): 00 00 00 00 ' r13     long 0          '$40
0188(0041): 00 00 00 00 ' r14     long 0          '$41
018c(0042): 00 00 00 00 ' r15     long 0          '$42
0190(0043): 00 00 00 00 ' r16     long 0          '$43
0194(0044): 00 00 00 00 ' r17     long 0          '$44
0198(0045): 00 00 00 00 ' r18     long 0          '$45
019c(0046): 00 00 00 00 ' r19     long 0          '$46
01a0(0047): 00 00 00 00 ' r20     long 0          '$47
01a4(0048): 00 00 00 00 ' r21     long 0          '$48
01a8(0049): 00 00 00 00 ' r22     long 0          '$49
01ac(004a): 00 00 00 00 ' r23     long 0          '$4a
01b0(004b): 00 00 00 80 ' Bit31   long  $80000000 '$4b
01b4(004c): ff ff ff ff ' all_1s  long  $ffffffff '$4c
01b8(004d): ff 00 00 00 ' cviu_m1 long  $000000ff '$4d
01bc(004e): ff ff 00 00 ' cviu_m2 long  $0000ffff '$4e
01c0(004f): 00 00 00 ff ' top8    long  $ff000000 '$4f   ' top 8 bits bitmask
01c4(0050): ff ff ff 00 ' low24   long  $00ffffff '$50   ' low 24 bits bitmask
01c8(0051): 90 29 00 00 ' init_BZ long  @sbrkinit '$51   ' end of code / start of heap
01cc(0052): fc 01 00 00 ' init_PC long  @C_main   '$52   ' the initial PC
01d0(0053):             ' seglayout
01d0(0053): 00 00 00 00 '         long  SEGMENT_LAYOUT
01d4(0054):             ' segtable
01d4(0054): 6c 01 00 00 '         long  @Catalina_Code
01d8(0055): b4 27 00 00 '         long  @Catalina_Cnst
01dc(0056): 78 28 00 00 '         long  @Catalina_Init
01e0(0057): 64 29 00 00 '         long  @Catalina_Data
01e4(0058): 94 29 00 00 '         long  @Catalina_Ends
01e8(0059):             '  long ' align long
01e8(0059):             ' Catalina_Code
01e8(0059):             '  long ' align long
01e8(0059):             '  long ' align long
01e8(0059):             ' C__exit
01e8(0059): 80 66 fc a0 '  mov r0,#$80
01ec(005a): 00 66 7c 0c '  clkset r0
01f0(005b):             ' C__sys_plugin
01f0(005b): 19 00 7c 5c '  jmp #SYSP
01f4(005c): 0c 00 7c 5c '  jmp #RETN
01f8(005d):             ' C_arg_setup
01f8(005d): 04 00 7c 5c '  jmp #LODA                 ' point to argv address
01fc(005e): 98 01 00 00 '  long @C_argv_locn
0200(005f): 2e 5e bc 08 '  rdlong BC,RI
0204(0060): 2f 6c bc 04 '  rdword r3,BC              ' load argc
0208(0061): 02 5e fc 80 '  add BC,#2
020c(0062): 2f 6a bc 04 '  rdword r2,BC              ' load argv
0210(0063): 0c 00 7c 5c '  jmp #RETN                 ' done
0214(0064):             ' C_argv_locn
0214(0064): 30 7f 00 00 '  long $7F30                ' must match value in Catalina_Common_Input.spin
0218(0065):             ' C_debug_init
0218(0065): 0c 00 7c 5c '  jmp #RETN                 ' done
021c(0066):             '  long ' align long
021c(0066):             ' C_bbos_time_init ' <symbol:bbos_time_init>
021c(0066): 22 00 7c 5c '  jmp #PSHM
0220(0067): 00 0c 00 00 '  long $c00 ' save registers
0224(0068): 00 5e fc a0 '  mov BC, #0 ' arg size
0228(0069): 0b 00 7c 5c '  jmp #CALA
022c(006a): 08 0f 00 00 '  long @C__clockfreq ' CALL addrg
0230(006b): 04 00 7c 5c '  jmp #LODA
0234(006c): ec 27 00 00 '  long @C_bbos_time_init_L000004
0238(006d): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
023c(006e): 33 7c bc a0 '  mov r11, r0 ' ADDU
0240(006f): 3d 7c bc 80 '  add r11, r10 ' ADDU (3)
0244(0070): 04 00 7c 5c '  jmp #LODA
0248(0071): e8 27 00 00 '  long @C_bbos_time_init_L000008
024c(0072): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
0250(0073): 3e 66 bc a0 '  mov r0, r11 ' setup r0/r1 (2)
0254(0074): 3d 68 bc a0 '  mov r1, r10 ' setup r0/r1 (2)
0258(0075): 11 00 7c 5c '  jmp #DIVU ' DIVU
025c(0076): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
0260(0077): 04 00 7c 5c '  jmp #LODA
0264(0078): 64 29 00 00 '  long @C_usec_delay
0268(0079): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrg
026c(007a): 23 00 7c 5c '  jmp #POPM
0270(007b): 00 0c 00 00 '  long $c00 ' restore registers
0274(007c): 0c 00 7c 5c '  jmp #RETN
0278(007d):             '  long ' align long
0278(007d):             ' C_main ' <symbol:main>
0278(007d): 0b 00 7c 5c '  jmp #CALA
027c(007e): 7c 01 00 00 '  long @C_arg_setup
0280(007f): 04 00 7c 5c '  jmp #LODA
0284(0080): e4 27 00 00 '  long @C_main_L000013
0288(0081): 2e 6a bc 08 '  rdlong r2, RI ' reg ARG con
028c(0082): 6f 6c fc a0 '  mov r3, #111 ' reg ARG coni
0290(0083): 08 5e fc a0 '  mov BC, #8 ' arg size
0294(0084): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0298(0085): 0b 00 7c 5c '  jmp #CALA
029c(0086): 10 0f 00 00 '  long @C__clockinit
02a0(0087): 08 58 fc 80 '  add SP, #8 ' CALL addrg
02a4(0088): 04 00 7c 5c '  jmp #LODA
02a8(0089): 08 0f 00 00 '  long @C__clockfreq
02ac(008a): 2e 6a bc a0 '  mov r2, RI ' reg ARG ADDRG
02b0(008b): 04 00 7c 5c '  jmp #LODA
02b4(008c): cc 27 00 00 '  long @C_main_16_L000017
02b8(008d): 2e 6c bc a0 '  mov r3, RI ' reg ARG ADDRG
02bc(008e): 08 5e fc a0 '  mov BC, #8 ' arg size
02c0(008f): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
02c4(0090): 0b 00 7c 5c '  jmp #CALA
02c8(0091): 70 26 00 00 '  long @C_printf
02cc(0092): 08 58 fc 80 '  add SP, #8 ' CALL addrg
02d0(0093): 00 5e fc a0 '  mov BC, #0 ' arg size
02d4(0094): 0b 00 7c 5c '  jmp #CALA
02d8(0095): a0 01 00 00 '  long @C_bbos_time_init ' CALL addrg
02dc(0096): 03 6a fc a0 '  mov r2, #3 ' reg ARG coni
02e0(0097): 00 6c fc a0 '  mov r3, #0 ' reg ARG coni
02e4(0098): 02 6e fc a0 '  mov r4, #2 ' reg ARG coni
02e8(0099): 01 70 fc a0 '  mov r5, #1 ' reg ARG coni
02ec(009a): 10 5e fc a0 '  mov BC, #16 ' arg size
02f0(009b): 10 58 fc 84 '  sub SP, #16 ' stack space for reg ARGs
02f4(009c): 0b 00 7c 5c '  jmp #CALA
02f8(009d): 84 09 00 00 '  long @C_h48c_open
02fc(009e): 10 58 fc 80 '  add SP, #16 ' CALL addrg
0300(009f): 0e 00 7c 5c '  jmp #JMPA
0304(00a0): f4 03 00 00 '  long @C_main_19 ' JUMPV addrg
0308(00a1):             ' C_main_18
0308(00a1): 18 6a fc a0 '  mov r2, #24 ' reg ARG coni
030c(00a2): 04 5e fc a0 '  mov BC, #4 ' arg size
0310(00a3): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
0314(00a4): 0b 00 7c 5c '  jmp #CALA
0318(00a5): 44 0a 00 00 '  long @C_h48c_gforce_of_axis
031c(00a6): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0320(00a7): 04 00 7c 5c '  jmp #LODA
0324(00a8): 7c 29 00 00 '  long @C_gforce_x
0328(00a9): 2e 66 3c 08 '  wrlong r0, RI ' ASGNI4 addrg
032c(00aa): 19 6a fc a0 '  mov r2, #25 ' reg ARG coni
0330(00ab): 04 5e fc a0 '  mov BC, #4 ' arg size
0334(00ac): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
0338(00ad): 0b 00 7c 5c '  jmp #CALA
033c(00ae): 44 0a 00 00 '  long @C_h48c_gforce_of_axis
0340(00af): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0344(00b0): 04 00 7c 5c '  jmp #LODA
0348(00b1): 78 29 00 00 '  long @C_gforce_y
034c(00b2): 2e 66 3c 08 '  wrlong r0, RI ' ASGNI4 addrg
0350(00b3): 1a 6a fc a0 '  mov r2, #26 ' reg ARG coni
0354(00b4): 04 5e fc a0 '  mov BC, #4 ' arg size
0358(00b5): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
035c(00b6): 0b 00 7c 5c '  jmp #CALA
0360(00b7): 44 0a 00 00 '  long @C_h48c_gforce_of_axis
0364(00b8): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0368(00b9): 04 00 7c 5c '  jmp #LODA
036c(00ba): 74 29 00 00 '  long @C_gforce_z
0370(00bb): 2e 66 3c 08 '  wrlong r0, RI ' ASGNI4 addrg
0374(00bc): 04 00 7c 5c '  jmp #LODA
0378(00bd): 74 29 00 00 '  long @C_gforce_z
037c(00be): 2e 6a bc 08 '  rdlong r2, RI ' reg ARG INDIR ADDRG
0380(00bf): 04 00 7c 5c '  jmp #LODA
0384(00c0): 78 29 00 00 '  long @C_gforce_y
0388(00c1): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRG
038c(00c2): 04 00 7c 5c '  jmp #LODA
0390(00c3): 7c 29 00 00 '  long @C_gforce_x
0394(00c4): 2e 6e bc 08 '  rdlong r4, RI ' reg ARG INDIR ADDRG
0398(00c5): 04 00 7c 5c '  jmp #LODA
039c(00c6): b8 27 00 00 '  long @C_main_21_L000022
03a0(00c7): 2e 70 bc a0 '  mov r5, RI ' reg ARG ADDRG
03a4(00c8): 10 5e fc a0 '  mov BC, #16 ' arg size
03a8(00c9): 10 58 fc 84 '  sub SP, #16 ' stack space for reg ARGs
03ac(00ca): 0b 00 7c 5c '  jmp #CALA
03b0(00cb): 70 26 00 00 '  long @C_printf
03b4(00cc): 10 58 fc 80 '  add SP, #16 ' CALL addrg
03b8(00cd): 00 5e fc a0 '  mov BC, #0 ' arg size
03bc(00ce): 0b 00 7c 5c '  jmp #CALA
03c0(00cf): e8 0a 00 00 '  long @C_h48c_free_fall ' CALL addrg
03c4(00d0): 00 66 7c c2 '  cmps r0,  #0 wz
03c8(00d1): 13 00 7c 5c '  jmp #BR_Z
03cc(00d2): ac 03 00 00 '  long @C_main_23 ' EQI4
03d0(00d3): 04 00 7c 5c '  jmp #LODA
03d4(00d4): b4 27 00 00 '  long @C_main_L000026
03d8(00d5): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
03dc(00d6): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
03e0(00d7): 3e 6c bc a0 '  mov r3, r11 ' CVI, CVU or LOAD
03e4(00d8): 08 5e fc a0 '  mov BC, #8 ' arg size
03e8(00d9): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
03ec(00da): 0b 00 7c 5c '  jmp #CALA
03f0(00db): 60 26 00 00 '  long @C__outa
03f4(00dc): 08 58 fc 80 '  add SP, #8 ' CALL addrg
03f8(00dd): 04 00 7c 5c '  jmp #LODA
03fc(00de): b4 27 00 00 '  long @C_main_L000026
0400(00df): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
0404(00e0): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
0408(00e1): 3e 6c bc a0 '  mov r3, r11 ' CVI, CVU or LOAD
040c(00e2): 08 5e fc a0 '  mov BC, #8 ' arg size
0410(00e3): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0414(00e4): 0b 00 7c 5c '  jmp #CALA
0418(00e5): 28 0f 00 00 '  long @C__dira
041c(00e6): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0420(00e7): 0e 00 7c 5c '  jmp #JMPA
0424(00e8): f4 03 00 00 '  long @C_main_24 ' JUMPV addrg
0428(00e9):             ' C_main_23
0428(00e9): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
042c(00ea): 04 00 7c 5c '  jmp #LODA
0430(00eb): b4 27 00 00 '  long @C_main_L000026
0434(00ec): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG con
0438(00ed): 08 5e fc a0 '  mov BC, #8 ' arg size
043c(00ee): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0440(00ef): 0b 00 7c 5c '  jmp #CALA
0444(00f0): 60 26 00 00 '  long @C__outa
0448(00f1): 08 58 fc 80 '  add SP, #8 ' CALL addrg
044c(00f2): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
0450(00f3): 04 00 7c 5c '  jmp #LODA
0454(00f4): b4 27 00 00 '  long @C_main_L000026
0458(00f5): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG con
045c(00f6): 08 5e fc a0 '  mov BC, #8 ' arg size
0460(00f7): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0464(00f8): 0b 00 7c 5c '  jmp #CALA
0468(00f9): 28 0f 00 00 '  long @C__dira
046c(00fa): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0470(00fb):             ' C_main_24
0470(00fb):             ' C_main_19
0470(00fb): 0e 00 7c 5c '  jmp #JMPA
0474(00fc): 8c 02 00 00 '  long @C_main_18 ' JUMPV addrg
0478(00fd): 0e 00 7c 5c '  jmp #JMPA
047c(00fe): 6c 01 00 00 '  long @C__exit
0480(00ff):             '  long ' align long
0480(00ff):             ' C_tmpfilex4T4vf_4d178bb2_post_clock_pulse_L000002 ' <symbol:post_clock_pulse>
0480(00ff): 22 00 7c 5c '  jmp #PSHM
0484(0100): 00 0c 02 00 '  long $20c00 ' save registers
0488(0101): 35 88 bc a0 '  mov r17, r2 ' reg var <- reg arg
048c(0102): 00 5e fc a0 '  mov BC, #0 ' arg size
0490(0103): 0b 00 7c 5c '  jmp #CALA
0494(0104): 20 0f 00 00 '  long @C__cnt ' CALL addrg
0498(0105): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
049c(0106): 04 00 7c 5c '  jmp #LODA
04a0(0107): f0 27 00 00 '  long @C_tmpfilex4T4vf_4d178bb2_post_clock_pulse_L000002_L000004
04a4(0108): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
04a8(0109): 3e 6a bc a0 '  mov r2, r11 ' ADDI/P
04ac(010a): 3d 6a bc d0 '  adds r2, r10 ' ADDI/P (3)
04b0(010b): 04 5e fc a0 '  mov BC, #4 ' arg size
04b4(010c): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
04b8(010d): 0b 00 7c 5c '  jmp #CALA
04bc(010e): ac 27 00 00 '  long @C__waitcnt
04c0(010f): 04 58 fc 80 '  add SP, #4 ' CALL addrg
04c4(0110): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
04c8(0111): 44 7a bc a0 '  mov r10, r17 ' CVI, CVU or LOAD
04cc(0112): 3d 7c bc 2c '  shl r11, r10 ' LSHI/U (1)
04d0(0113): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
04d4(0114): 3e 6c bc a0 '  mov r3, r11 ' CVI, CVU or LOAD
04d8(0115): 08 5e fc a0 '  mov BC, #8 ' arg size
04dc(0116): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
04e0(0117): 0b 00 7c 5c '  jmp #CALA
04e4(0118): 60 26 00 00 '  long @C__outa
04e8(0119): 08 58 fc 80 '  add SP, #8 ' CALL addrg
04ec(011a): 00 5e fc a0 '  mov BC, #0 ' arg size
04f0(011b): 0b 00 7c 5c '  jmp #CALA
04f4(011c): 20 0f 00 00 '  long @C__cnt ' CALL addrg
04f8(011d): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
04fc(011e): 04 00 7c 5c '  jmp #LODA
0500(011f): f0 27 00 00 '  long @C_tmpfilex4T4vf_4d178bb2_post_clock_pulse_L000002_L000004
0504(0120): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
0508(0121): 3e 6a bc a0 '  mov r2, r11 ' ADDI/P
050c(0122): 3d 6a bc d0 '  adds r2, r10 ' ADDI/P (3)
0510(0123): 04 5e fc a0 '  mov BC, #4 ' arg size
0514(0124): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
0518(0125): 0b 00 7c 5c '  jmp #CALA
051c(0126): ac 27 00 00 '  long @C__waitcnt
0520(0127): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0524(0128): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
0528(0129): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
052c(012a): 44 7a bc a0 '  mov r10, r17 ' CVI, CVU or LOAD
0530(012b): 3e 6c bc a0 '  mov r3, r11 ' LSHI/U
0534(012c): 3d 6c bc 2c '  shl r3, r10 ' LSHI/U (3)
0538(012d): 08 5e fc a0 '  mov BC, #8 ' arg size
053c(012e): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0540(012f): 0b 00 7c 5c '  jmp #CALA
0544(0130): 60 26 00 00 '  long @C__outa
0548(0131): 08 58 fc 80 '  add SP, #8 ' CALL addrg
054c(0132): 23 00 7c 5c '  jmp #POPM
0550(0133): 00 0c 02 00 '  long $20c00 ' restore registers
0554(0134): 0c 00 7c 5c '  jmp #RETN
0558(0135):             '  long ' align long
0558(0135):             ' C_tmpfileRdorjk_4d178bb2_pre_clock_pulse_L000007 ' <symbol:pre_clock_pulse>
0558(0135): 22 00 7c 5c '  jmp #PSHM
055c(0136): 00 0c 02 00 '  long $20c00 ' save registers
0560(0137): 35 88 bc a0 '  mov r17, r2 ' reg var <- reg arg
0564(0138): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
0568(0139): 44 7a bc a0 '  mov r10, r17 ' CVI, CVU or LOAD
056c(013a): 3d 7c bc 2c '  shl r11, r10 ' LSHI/U (1)
0570(013b): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
0574(013c): 3e 6c bc a0 '  mov r3, r11 ' CVI, CVU or LOAD
0578(013d): 08 5e fc a0 '  mov BC, #8 ' arg size
057c(013e): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0580(013f): 0b 00 7c 5c '  jmp #CALA
0584(0140): 60 26 00 00 '  long @C__outa
0588(0141): 08 58 fc 80 '  add SP, #8 ' CALL addrg
058c(0142): 00 5e fc a0 '  mov BC, #0 ' arg size
0590(0143): 0b 00 7c 5c '  jmp #CALA
0594(0144): 20 0f 00 00 '  long @C__cnt ' CALL addrg
0598(0145): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
059c(0146): 04 00 7c 5c '  jmp #LODA
05a0(0147): f0 27 00 00 '  long @C_tmpfilex4T4vf_4d178bb2_post_clock_pulse_L000002_L000004
05a4(0148): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
05a8(0149): 3e 6a bc a0 '  mov r2, r11 ' ADDI/P
05ac(014a): 3d 6a bc d0 '  adds r2, r10 ' ADDI/P (3)
05b0(014b): 04 5e fc a0 '  mov BC, #4 ' arg size
05b4(014c): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
05b8(014d): 0b 00 7c 5c '  jmp #CALA
05bc(014e): ac 27 00 00 '  long @C__waitcnt
05c0(014f): 04 58 fc 80 '  add SP, #4 ' CALL addrg
05c4(0150): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
05c8(0151): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
05cc(0152): 44 7a bc a0 '  mov r10, r17 ' CVI, CVU or LOAD
05d0(0153): 3e 6c bc a0 '  mov r3, r11 ' LSHI/U
05d4(0154): 3d 6c bc 2c '  shl r3, r10 ' LSHI/U (3)
05d8(0155): 08 5e fc a0 '  mov BC, #8 ' arg size
05dc(0156): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
05e0(0157): 0b 00 7c 5c '  jmp #CALA
05e4(0158): 60 26 00 00 '  long @C__outa
05e8(0159): 08 58 fc 80 '  add SP, #8 ' CALL addrg
05ec(015a): 00 5e fc a0 '  mov BC, #0 ' arg size
05f0(015b): 0b 00 7c 5c '  jmp #CALA
05f4(015c): 20 0f 00 00 '  long @C__cnt ' CALL addrg
05f8(015d): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
05fc(015e): 04 00 7c 5c '  jmp #LODA
0600(015f): f0 27 00 00 '  long @C_tmpfilex4T4vf_4d178bb2_post_clock_pulse_L000002_L000004
0604(0160): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
0608(0161): 3e 6a bc a0 '  mov r2, r11 ' ADDI/P
060c(0162): 3d 6a bc d0 '  adds r2, r10 ' ADDI/P (3)
0610(0163): 04 5e fc a0 '  mov BC, #4 ' arg size
0614(0164): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
0618(0165): 0b 00 7c 5c '  jmp #CALA
061c(0166): ac 27 00 00 '  long @C__waitcnt
0620(0167): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0624(0168): 23 00 7c 5c '  jmp #POPM
0628(0169): 00 0c 02 00 '  long $20c00 ' restore registers
062c(016a): 0c 00 7c 5c '  jmp #RETN
0630(016b):             '  long ' align long
0630(016b):             ' C_stamp_shiftout ' <symbol:stamp_shiftout>
0630(016b): 09 00 7c 5c '  jmp #NEWF
0634(016c): 22 00 7c 5c '  jmp #PSHM
0638(016d): 00 cc 03 00 '  long $3cc00 ' save registers
063c(016e): 38 88 bc a0 '  mov r17, r5 ' reg var <- reg arg
0640(016f): 37 86 bc a0 '  mov r16, r4 ' reg var <- reg arg
0644(0170): 36 84 bc a0 '  mov r15, r3 ' reg var <- reg arg
0648(0171): 35 82 bc a0 '  mov r14, r2 ' reg var <- reg arg
064c(0172): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
0650(0173): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
0654(0174): 2d 7a bc a0 '  mov r10, FP
0658(0175): 08 7a fc 80 '  add r10, #8 ' reg <- addrfi
065c(0176): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRU4 reg
0660(0177): 3e 6c bc a0 '  mov r3, r11 ' LSHI/U
0664(0178): 3d 6c bc 2c '  shl r3, r10 ' LSHI/U (3)
0668(0179): 08 5e fc a0 '  mov BC, #8 ' arg size
066c(017a): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0670(017b): 0b 00 7c 5c '  jmp #CALA
0674(017c): 60 26 00 00 '  long @C__outa
0678(017d): 08 58 fc 80 '  add SP, #8 ' CALL addrg
067c(017e): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
0680(017f): 2d 7a bc a0 '  mov r10, FP
0684(0180): 08 7a fc 80 '  add r10, #8 ' reg <- addrfi
0688(0181): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRU4 reg
068c(0182): 3d 7c bc 2c '  shl r11, r10 ' LSHI/U (1)
0690(0183): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
0694(0184): 3e 6c bc a0 '  mov r3, r11 ' CVI, CVU or LOAD
0698(0185): 08 5e fc a0 '  mov BC, #8 ' arg size
069c(0186): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
06a0(0187): 0b 00 7c 5c '  jmp #CALA
06a4(0188): 28 0f 00 00 '  long @C__dira
06a8(0189): 08 58 fc 80 '  add SP, #8 ' CALL addrg
06ac(018a): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
06b0(018b): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
06b4(018c): 44 7a bc a0 '  mov r10, r17 ' CVI, CVU or LOAD
06b8(018d): 3e 6c bc a0 '  mov r3, r11 ' LSHI/U
06bc(018e): 3d 6c bc 2c '  shl r3, r10 ' LSHI/U (3)
06c0(018f): 08 5e fc a0 '  mov BC, #8 ' arg size
06c4(0190): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
06c8(0191): 0b 00 7c 5c '  jmp #CALA
06cc(0192): 60 26 00 00 '  long @C__outa
06d0(0193): 08 58 fc 80 '  add SP, #8 ' CALL addrg
06d4(0194): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
06d8(0195): 44 7a bc a0 '  mov r10, r17 ' CVI, CVU or LOAD
06dc(0196): 3d 7c bc 2c '  shl r11, r10 ' LSHI/U (1)
06e0(0197): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
06e4(0198): 3e 6c bc a0 '  mov r3, r11 ' CVI, CVU or LOAD
06e8(0199): 08 5e fc a0 '  mov BC, #8 ' arg size
06ec(019a): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
06f0(019b): 0b 00 7c 5c '  jmp #CALA
06f4(019c): 28 0f 00 00 '  long @C__dira
06f8(019d): 08 58 fc 80 '  add SP, #8 ' CALL addrg
06fc(019e): 05 86 7c 86 '  cmp r16,  #5 wz
0700(019f): 14 00 7c 5c '  jmp #BRNZ
0704(01a0): 94 07 00 00 '  long @C_stamp_shiftout_10 ' NEU4
0708(01a1): 20 7c fc a0 '  mov r11, #32 ' reg <- coni
070c(01a2): 42 7c bc 84 '  sub r11, r15 ' SUBU (1)
0710(01a3): 3e 82 bc 2c '  shl r14, r11 ' LSHI/U (1)
0714(01a4): 0e 00 7c 5c '  jmp #JMPA
0718(01a5): 4c 07 00 00 '  long @C_stamp_shiftout_13 ' JUMPV addrg
071c(01a6):             ' C_stamp_shiftout_12
071c(01a6): 41 7c bc a0 '  mov r11, r14
0720(01a7): 01 7c fc 2c '  shl r11, #1 ' LSHU4 coni
0724(01a8): 41 7a bc a0 '  mov r10, r14
0728(01a9): 1f 7a fc 28 '  shr r10, #31 ' RSHU4 coni
072c(01aa): 3e 82 bc a0 '  mov r14, r11 ' BORI/U
0730(01ab): 3d 82 bc 68 '  or r14, r10 ' BORI/U (3)
0734(01ac): 41 7c bc a0 '  mov r11, r14
0738(01ad): 01 7c fc 60 '  and r11, #1 ' BANDU4 coni
073c(01ae): 00 7c 7c 86 '  cmp r11,  #0 wz
0740(01af): 13 00 7c 5c '  jmp #BR_Z
0744(01b0): 04 07 00 00 '  long @C_stamp_shiftout_15 ' EQU4
0748(01b1): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
074c(01b2): 2d 7a bc a0 '  mov r10, FP
0750(01b3): 08 7a fc 80 '  add r10, #8 ' reg <- addrfi
0754(01b4): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRU4 reg
0758(01b5): 3d 7c bc 2c '  shl r11, r10 ' LSHI/U (1)
075c(01b6): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
0760(01b7): 3e 6c bc a0 '  mov r3, r11 ' CVI, CVU or LOAD
0764(01b8): 08 5e fc a0 '  mov BC, #8 ' arg size
0768(01b9): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
076c(01ba): 0b 00 7c 5c '  jmp #CALA
0770(01bb): 60 26 00 00 '  long @C__outa
0774(01bc): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0778(01bd): 0e 00 7c 5c '  jmp #JMPA
077c(01be): 34 07 00 00 '  long @C_stamp_shiftout_16 ' JUMPV addrg
0780(01bf):             ' C_stamp_shiftout_15
0780(01bf): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
0784(01c0): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
0788(01c1): 2d 7a bc a0 '  mov r10, FP
078c(01c2): 08 7a fc 80 '  add r10, #8 ' reg <- addrfi
0790(01c3): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRU4 reg
0794(01c4): 3e 6c bc a0 '  mov r3, r11 ' LSHI/U
0798(01c5): 3d 6c bc 2c '  shl r3, r10 ' LSHI/U (3)
079c(01c6): 08 5e fc a0 '  mov BC, #8 ' arg size
07a0(01c7): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
07a4(01c8): 0b 00 7c 5c '  jmp #CALA
07a8(01c9): 60 26 00 00 '  long @C__outa
07ac(01ca): 08 58 fc 80 '  add SP, #8 ' CALL addrg
07b0(01cb):             ' C_stamp_shiftout_16
07b0(01cb): 44 6a bc a0 '  mov r2, r17 ' CVI, CVU or LOAD
07b4(01cc): 04 5e fc a0 '  mov BC, #4 ' arg size
07b8(01cd): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
07bc(01ce): 0b 00 7c 5c '  jmp #CALA
07c0(01cf): 04 04 00 00 '  long @C_tmpfilex4T4vf_4d178bb2_post_clock_pulse_L000002
07c4(01d0): 04 58 fc 80 '  add SP, #4 ' CALL addrg
07c8(01d1):             ' C_stamp_shiftout_13
07c8(01d1): 42 7c bc a0 '  mov r11, r15 ' CVI, CVU or LOAD
07cc(01d2): 3e 84 bc a0 '  mov r15, r11
07d0(01d3): 01 84 fc 84 '  sub r15, #1 ' SUBU4 coni
07d4(01d4): 00 7c 7c 86 '  cmp r11,  #0 wz
07d8(01d5): 14 00 7c 5c '  jmp #BRNZ
07dc(01d6): a0 06 00 00 '  long @C_stamp_shiftout_12 ' NEU4
07e0(01d7): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
07e4(01d8): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
07e8(01d9): 2d 7a bc a0 '  mov r10, FP
07ec(01da): 08 7a fc 80 '  add r10, #8 ' reg <- addrfi
07f0(01db): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRU4 reg
07f4(01dc): 3e 6c bc a0 '  mov r3, r11 ' LSHI/U
07f8(01dd): 3d 6c bc 2c '  shl r3, r10 ' LSHI/U (3)
07fc(01de): 08 5e fc a0 '  mov BC, #8 ' arg size
0800(01df): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0804(01e0): 0b 00 7c 5c '  jmp #CALA
0808(01e1): 60 26 00 00 '  long @C__outa
080c(01e2): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0810(01e3):             ' C_stamp_shiftout_10
0810(01e3): 23 00 7c 5c '  jmp #POPM
0814(01e4): 00 cc 03 00 '  long $3cc00 ' restore registers
0818(01e5): 0a 00 7c 5c '  jmp #RETF
081c(01e6):             '  long ' align long
081c(01e6):             ' C_stamp_shiftin ' <symbol:stamp_shiftin>
081c(01e6): 22 00 7c 5c '  jmp #PSHM
0820(01e7): 00 fe 03 00 '  long $3fe00 ' save registers
0824(01e8): 38 88 bc a0 '  mov r17, r5 ' reg var <- reg arg
0828(01e9): 37 86 bc a0 '  mov r16, r4 ' reg var <- reg arg
082c(01ea): 36 84 bc a0 '  mov r15, r3 ' reg var <- reg arg
0830(01eb): 35 82 bc a0 '  mov r14, r2 ' reg var <- reg arg
0834(01ec): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
0838(01ed): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
083c(01ee): 44 7a bc a0 '  mov r10, r17 ' CVI, CVU or LOAD
0840(01ef): 3e 6c bc a0 '  mov r3, r11 ' LSHI/U
0844(01f0): 3d 6c bc 2c '  shl r3, r10 ' LSHI/U (3)
0848(01f1): 08 5e fc a0 '  mov BC, #8 ' arg size
084c(01f2): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0850(01f3): 0b 00 7c 5c '  jmp #CALA
0854(01f4): 28 0f 00 00 '  long @C__dira
0858(01f5): 08 58 fc 80 '  add SP, #8 ' CALL addrg
085c(01f6): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
0860(01f7): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
0864(01f8): 43 7a bc a0 '  mov r10, r16 ' CVI, CVU or LOAD
0868(01f9): 3e 6c bc a0 '  mov r3, r11 ' LSHI/U
086c(01fa): 3d 6c bc 2c '  shl r3, r10 ' LSHI/U (3)
0870(01fb): 08 5e fc a0 '  mov BC, #8 ' arg size
0874(01fc): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0878(01fd): 0b 00 7c 5c '  jmp #CALA
087c(01fe): 60 26 00 00 '  long @C__outa
0880(01ff): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0884(0200): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
0888(0201): 43 7a bc a0 '  mov r10, r16 ' CVI, CVU or LOAD
088c(0202): 3d 7c bc 2c '  shl r11, r10 ' LSHI/U (1)
0890(0203): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
0894(0204): 3e 6c bc a0 '  mov r3, r11 ' CVI, CVU or LOAD
0898(0205): 08 5e fc a0 '  mov BC, #8 ' arg size
089c(0206): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
08a0(0207): 0b 00 7c 5c '  jmp #CALA
08a4(0208): 28 0f 00 00 '  long @C__dira
08a8(0209): 08 58 fc 80 '  add SP, #8 ' CALL addrg
08ac(020a): 00 80 fc a0 '  mov r13, #0 ' reg <- coni
08b0(020b): 02 84 7c 86 '  cmp r15,  #2 wz
08b4(020c): 14 00 7c 5c '  jmp #BRNZ
08b8(020d): c8 08 00 00 '  long @C_stamp_shiftin_18 ' NEU4
08bc(020e): 0e 00 7c 5c '  jmp #JMPA
08c0(020f): b0 08 00 00 '  long @C_stamp_shiftin_21 ' JUMPV addrg
08c4(0210):             ' C_stamp_shiftin_20
08c4(0210): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
08c8(0211): 04 5e fc a0 '  mov BC, #4 ' arg size
08cc(0212): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
08d0(0213): 0b 00 7c 5c '  jmp #CALA
08d4(0214): dc 04 00 00 '  long @C_tmpfileRdorjk_4d178bb2_pre_clock_pulse_L000007
08d8(0215): 04 58 fc 80 '  add SP, #4 ' CALL addrg
08dc(0216): 00 5e fc a0 '  mov BC, #0 ' arg size
08e0(0217): 0b 00 7c 5c '  jmp #CALA
08e4(0218): 58 26 00 00 '  long @C__ina ' CALL addrg
08e8(0219): 01 7a fc a0 '  mov r10, #1 ' reg <- coni
08ec(021a): 44 78 bc a0 '  mov r9, r17 ' CVI, CVU or LOAD
08f0(021b): 3c 7a bc 2c '  shl r10, r9 ' LSHI/U (1)
08f4(021c): 33 7c bc a0 '  mov r11, r0 ' BANDI/U
08f8(021d): 3d 7c bc 60 '  and r11, r10 ' BANDI/U (3)
08fc(021e): 00 7c 7c c2 '  cmps r11,  #0 wz
0900(021f): 13 00 7c 5c '  jmp #BR_Z
0904(0220): 98 08 00 00 '  long @C_stamp_shiftin_24 ' EQI4
0908(0221): 01 7e fc a0 '  mov r12, #1 ' reg <- coni
090c(0222): 0e 00 7c 5c '  jmp #JMPA
0910(0223): 9c 08 00 00 '  long @C_stamp_shiftin_25 ' JUMPV addrg
0914(0224):             ' C_stamp_shiftin_24
0914(0224): 00 7e fc a0 '  mov r12, #0 ' reg <- coni
0918(0225):             ' C_stamp_shiftin_25
0918(0225): 40 7c bc a0 '  mov r11, r13
091c(0226): 01 7c fc 2c '  shl r11, #1 ' LSHU4 coni
0920(0227): 3f 7a bc a0 '  mov r10, r12 ' CVI, CVU or LOAD
0924(0228): 3e 80 bc a0 '  mov r13, r11 ' BORI/U
0928(0229): 3d 80 bc 68 '  or r13, r10 ' BORI/U (3)
092c(022a):             ' C_stamp_shiftin_21
092c(022a): 41 7c bc a0 '  mov r11, r14 ' CVI, CVU or LOAD
0930(022b): 3e 82 bc a0 '  mov r14, r11
0934(022c): 01 82 fc 84 '  sub r14, #1 ' SUBU4 coni
0938(022d): 00 7c 7c 86 '  cmp r11,  #0 wz
093c(022e): 14 00 7c 5c '  jmp #BRNZ
0940(022f): 48 08 00 00 '  long @C_stamp_shiftin_20 ' NEU4
0944(0230):             ' C_stamp_shiftin_18
0944(0230): 40 66 bc a0 '  mov r0, r13 ' CVI, CVU or LOAD
0948(0231): 23 00 7c 5c '  jmp #POPM
094c(0232): 00 fe 03 00 '  long $3fe00 ' restore registers
0950(0233): 0c 00 7c 5c '  jmp #RETN
0954(0234):             '  long ' align long
0954(0234):             ' C_tmpfileCxgKZh_4d178bb2_umulf_L000002 ' <symbol:umulf>
0954(0234): 22 00 7c 5c '  jmp #PSHM
0958(0235): 00 ec 03 00 '  long $3ec00 ' save registers
095c(0236): 36 88 bc a0 '  mov r17, r3 ' reg var <- reg arg
0960(0237): 35 86 bc a0 '  mov r16, r2 ' reg var <- reg arg
0964(0238): 00 7c fc a0 '  mov r11, #0 ' reg <- coni
0968(0239): 3e 80 bc a0 '  mov r13, r11 ' CVI, CVU or LOAD
096c(023a): 3e 82 bc a0 '  mov r14, r11 ' CVI, CVU or LOAD
0970(023b): 01 84 fc a0 '  mov r15, #1 ' reg <- coni
0974(023c):             ' C_tmpfileCxgKZh_4d178bb2_umulf_L000002_4
0974(023c): 00 86 7c c3 '  cmps r16,  #0 wz,wc
0978(023d): 15 00 7c 5c '  jmp #BRAE
097c(023e): 2c 09 00 00 '  long @C_tmpfileCxgKZh_4d178bb2_umulf_L000002_8 ' GEI4
0980(023f): 42 88 bc 38 '  sar r17, r15 ' RSHI (1)
0984(0240): 44 82 bc d0 '  adds r14, r17 ' ADDI/P (1)
0988(0241): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
098c(0242): 42 7c bc 2c '  shl r11, r15 ' LSHI/U (1)
0990(0243): 01 7c fc d4 '  subs r11, #1 ' SUBI4 coni
0994(0244): 44 7c bc 60 '  and r11, r17 ' BANDI/U (2)
0998(0245): 10 7a fc a0 '  mov r10, #16 ' reg <- coni
099c(0246): 42 7a bc d4 '  subs r10, r15 ' SUBI/P (1)
09a0(0247): 3d 7c bc 2c '  shl r11, r10 ' LSHI/U (1)
09a4(0248): 3e 80 bc d0 '  adds r13, r11 ' ADDI/P (1)
09a8(0249):             ' C_tmpfileCxgKZh_4d178bb2_umulf_L000002_8
09a8(0249): 01 86 fc 2c '  shl r16, #1 ' LSHI4 coni
09ac(024a): 01 84 fc d0 '  adds r15, #1 ' ADDI4 coni
09b0(024b): 11 84 7c c3 '  cmps r15,  #17 wz,wc
09b4(024c): 18 00 7c 5c '  jmp #BR_B
09b8(024d): f8 08 00 00 '  long @C_tmpfileCxgKZh_4d178bb2_umulf_L000002_4 ' LTI4
09bc(024e): 00 80 7c c3 '  cmps r13,  #0 wz,wc
09c0(024f): 15 00 7c 5c '  jmp #BRAE
09c4(0250): 50 09 00 00 '  long @C_tmpfileCxgKZh_4d178bb2_umulf_L000002_10 ' GEI4
09c8(0251): 01 82 fc d0 '  adds r14, #1 ' ADDI4 coni
09cc(0252):             ' C_tmpfileCxgKZh_4d178bb2_umulf_L000002_10
09cc(0252): 41 6a bc a0 '  mov r2, r14 ' CVI, CVU or LOAD
09d0(0253): 04 00 7c 5c '  jmp #LODA
09d4(0254): f8 27 00 00 '  long @C_tmpfileCxgKZh_4d178bb2_umulf_L000002_12_L000013
09d8(0255): 2e 6c bc a0 '  mov r3, RI ' reg ARG ADDRG
09dc(0256): 08 5e fc a0 '  mov BC, #8 ' arg size
09e0(0257): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
09e4(0258): 0b 00 7c 5c '  jmp #CALA
09e8(0259): 70 26 00 00 '  long @C_printf
09ec(025a): 08 58 fc 80 '  add SP, #8 ' CALL addrg
09f0(025b): 41 66 bc a0 '  mov r0, r14 ' CVI, CVU or LOAD
09f4(025c): 23 00 7c 5c '  jmp #POPM
09f8(025d): 00 ec 03 00 '  long $3ec00 ' restore registers
09fc(025e): 0c 00 7c 5c '  jmp #RETN
0a00(025f):             '  long ' align long
0a00(025f):             ' C_h48c_open ' <symbol:h48c_open>
0a00(025f): 22 00 7c 5c '  jmp #PSHM
0a04(0260): 00 cc 03 00 '  long $3cc00 ' save registers
0a08(0261): 38 88 bc a0 '  mov r17, r5 ' reg var <- reg arg
0a0c(0262): 37 86 bc a0 '  mov r16, r4 ' reg var <- reg arg
0a10(0263): 36 84 bc a0 '  mov r15, r3 ' reg var <- reg arg
0a14(0264): 35 82 bc a0 '  mov r14, r2 ' reg var <- reg arg
0a18(0265): 04 00 7c 5c '  jmp #LODA
0a1c(0266): 8c 29 00 00 '  long @C_tmpfileqjwcPm_4d178bb2_h48c_dio_pin_L000014
0a20(0267): 2e 88 3c 08 '  wrlong r17, RI ' ASGNI4 addrg
0a24(0268): 04 00 7c 5c '  jmp #LODA
0a28(0269): 88 29 00 00 '  long @C_tmpfileYkNWeU_4d178bb2_h48c_clk_pin_L000015
0a2c(026a): 2e 86 3c 08 '  wrlong r16, RI ' ASGNI4 addrg
0a30(026b): 04 00 7c 5c '  jmp #LODA
0a34(026c): 84 29 00 00 '  long @C_tmpfileQ8dHEr_4d178bb2_h48c_cs_pin_L000016
0a38(026d): 2e 7c bc a0 '  mov r11, RI ' reg <- addrg
0a3c(026e): 04 00 7c 5c '  jmp #LODA
0a40(026f): 84 29 00 00 '  long @C_tmpfileQ8dHEr_4d178bb2_h48c_cs_pin_L000016
0a44(0270): 2e 84 3c 08 '  wrlong r15, RI ' ASGNI4 addrg
0a48(0271): 04 00 7c 5c '  jmp #LODA
0a4c(0272): 80 29 00 00 '  long @C_tmpfileSpHr4Y_4d178bb2_h48c_zerog_pin_L000017
0a50(0273): 2e 82 3c 08 '  wrlong r14, RI ' ASGNI4 addrg
0a54(0274): 01 7a fc a0 '  mov r10, #1 ' reg <- coni
0a58(0275): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
0a5c(0276): 3d 5c bc a0 '  mov RI, r10
0a60(0277): 3e 5c bc 2c '  shl RI, r11
0a64(0278): 2e 7c bc a0 '  mov r11, RI ' SHLI/U (2)
0a68(0279): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
0a6c(027a): 3e 6c bc a0 '  mov r3, r11 ' CVI, CVU or LOAD
0a70(027b): 08 5e fc a0 '  mov BC, #8 ' arg size
0a74(027c): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0a78(027d): 0b 00 7c 5c '  jmp #CALA
0a7c(027e): 60 26 00 00 '  long @C__outa
0a80(027f): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0a84(0280): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
0a88(0281): 04 00 7c 5c '  jmp #LODA
0a8c(0282): 84 29 00 00 '  long @C_tmpfileQ8dHEr_4d178bb2_h48c_cs_pin_L000016
0a90(0283): 2e 7a bc 08 '  rdlong r10, RI ' reg <- INDIRI4 addrg
0a94(0284): 3d 7c bc 2c '  shl r11, r10 ' LSHI/U (1)
0a98(0285): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
0a9c(0286): 3e 6c bc a0 '  mov r3, r11 ' CVI, CVU or LOAD
0aa0(0287): 08 5e fc a0 '  mov BC, #8 ' arg size
0aa4(0288): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0aa8(0289): 0b 00 7c 5c '  jmp #CALA
0aac(028a): 28 0f 00 00 '  long @C__dira
0ab0(028b): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0ab4(028c): 23 00 7c 5c '  jmp #POPM
0ab8(028d): 00 cc 03 00 '  long $3cc00 ' restore registers
0abc(028e): 0c 00 7c 5c '  jmp #RETN
0ac0(028f):             '  long ' align long
0ac0(028f):             ' C_h48c_gforce_of_axis ' <symbol:h48c_gforce_of_axis>
0ac0(028f): 22 00 7c 5c '  jmp #PSHM
0ac4(0290): 00 88 03 00 '  long $38800 ' save registers
0ac8(0291): 35 88 bc a0 '  mov r17, r2 ' reg var <- reg arg
0acc(0292): 1b 6a fc a0 '  mov r2, #27 ' reg ARG coni
0ad0(0293): 04 5e fc a0 '  mov BC, #4 ' arg size
0ad4(0294): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
0ad8(0295): 0b 00 7c 5c '  jmp #CALA
0adc(0296): 90 0b 00 00 '  long @C_h48c_read_value
0ae0(0297): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0ae4(0298): 33 86 bc a0 '  mov r16, r0 ' CVI, CVU or LOAD
0ae8(0299): 00 5e fc a0 '  mov BC, #0 ' arg size
0aec(029a): 0b 00 7c 5c '  jmp #CALA
0af0(029b): 20 0f 00 00 '  long @C__cnt ' CALL addrg
0af4(029c): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
0af8(029d): 3e 6a bc a0 '  mov r2, r11
0afc(029e): 2c 6b fc 80 '  add r2, #300 ' ADDU4 coni
0b00(029f): 04 5e fc a0 '  mov BC, #4 ' arg size
0b04(02a0): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
0b08(02a1): 0b 00 7c 5c '  jmp #CALA
0b0c(02a2): ac 27 00 00 '  long @C__waitcnt
0b10(02a3): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0b14(02a4): 44 6a bc a0 '  mov r2, r17 ' CVI, CVU or LOAD
0b18(02a5): 04 5e fc a0 '  mov BC, #4 ' arg size
0b1c(02a6): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
0b20(02a7): 0b 00 7c 5c '  jmp #CALA
0b24(02a8): 90 0b 00 00 '  long @C_h48c_read_value
0b28(02a9): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0b2c(02aa): 33 84 bc a0 '  mov r15, r0 ' CVI, CVU or LOAD
0b30(02ab): 43 84 3c c3 '  cmps r15, r16 wz,wc
0b34(02ac): 18 00 7c 5c '  jmp #BR_B
0b38(02ad): d0 0a 00 00 '  long @C_h48c_gforce_of_axis_20 ' LTI4
0b3c(02ae): 42 66 bc a0 '  mov r0, r15 ' SUBI/P
0b40(02af): 43 66 bc d4 '  subs r0, r16 ' SUBI/P (3)
0b44(02b0): 0e 00 7c 5c '  jmp #JMPA
0b48(02b1): dc 0a 00 00 '  long @C_h48c_gforce_of_axis_19 ' JUMPV addrg
0b4c(02b2):             ' C_h48c_gforce_of_axis_20
0b4c(02b2): 43 7c bc a0 '  mov r11, r16 ' SUBI/P
0b50(02b3): 42 7c bc d4 '  subs r11, r15 ' SUBI/P (3)
0b54(02b4): 3e 66 bc a4 '  neg r0, r11 ' NEGI4
0b58(02b5):             ' C_h48c_gforce_of_axis_19
0b58(02b5): 23 00 7c 5c '  jmp #POPM
0b5c(02b6): 00 88 03 00 '  long $38800 ' restore registers
0b60(02b7): 0c 00 7c 5c '  jmp #RETN
0b64(02b8):             '  long ' align long
0b64(02b8):             ' C_h48c_free_fall ' <symbol:h48c_free_fall>
0b64(02b8): 22 00 7c 5c '  jmp #PSHM
0b68(02b9): 00 0e 02 00 '  long $20e00 ' save registers
0b6c(02ba): 00 5e fc a0 '  mov BC, #0 ' arg size
0b70(02bb): 0b 00 7c 5c '  jmp #CALA
0b74(02bc): 58 26 00 00 '  long @C__ina ' CALL addrg
0b78(02bd): 01 7a fc a0 '  mov r10, #1 ' reg <- coni
0b7c(02be): 04 00 7c 5c '  jmp #LODA
0b80(02bf): 80 29 00 00 '  long @C_tmpfileSpHr4Y_4d178bb2_h48c_zerog_pin_L000017
0b84(02c0): 2e 78 bc 08 '  rdlong r9, RI ' reg <- INDIRI4 addrg
0b88(02c1): 3c 7a bc 2c '  shl r10, r9 ' LSHI/U (1)
0b8c(02c2): 33 7c bc a0 '  mov r11, r0 ' BANDI/U
0b90(02c3): 3d 7c bc 60 '  and r11, r10 ' BANDI/U (3)
0b94(02c4): 00 7c 7c 86 '  cmp r11,  #0 wz
0b98(02c5): 13 00 7c 5c '  jmp #BR_Z
0b9c(02c6): 30 0b 00 00 '  long @C_h48c_free_fall_24 ' EQU4
0ba0(02c7): 01 88 fc a0 '  mov r17, #1 ' reg <- coni
0ba4(02c8): 0e 00 7c 5c '  jmp #JMPA
0ba8(02c9): 34 0b 00 00 '  long @C_h48c_free_fall_25 ' JUMPV addrg
0bac(02ca):             ' C_h48c_free_fall_24
0bac(02ca): 00 88 fc a0 '  mov r17, #0 ' reg <- coni
0bb0(02cb):             ' C_h48c_free_fall_25
0bb0(02cb): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
0bb4(02cc): 3e 66 bc a0 '  mov r0, r11 ' CVUI
0bb8(02cd): 4d 66 bc 60 '  and r0, cviu_m1 ' zero extend
0bbc(02ce): 23 00 7c 5c '  jmp #POPM
0bc0(02cf): 00 0e 02 00 '  long $20e00 ' restore registers
0bc4(02d0): 0c 00 7c 5c '  jmp #RETN
0bc8(02d1):             '  long ' align long
0bc8(02d1):             ' C_h48c_close ' <symbol:h48c_close>
0bc8(02d1): 22 00 7c 5c '  jmp #PSHM
0bcc(02d2): 00 0c 00 00 '  long $c00 ' save registers
0bd0(02d3): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
0bd4(02d4): 04 00 7c 5c '  jmp #LODA
0bd8(02d5): 84 29 00 00 '  long @C_tmpfileQ8dHEr_4d178bb2_h48c_cs_pin_L000016
0bdc(02d6): 2e 7a bc 08 '  rdlong r10, RI ' reg <- INDIRI4 addrg
0be0(02d7): 3d 7c bc 2c '  shl r11, r10 ' LSHI/U (1)
0be4(02d8): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
0be8(02d9): 3e 6c bc a0 '  mov r3, r11 ' CVI, CVU or LOAD
0bec(02da): 08 5e fc a0 '  mov BC, #8 ' arg size
0bf0(02db): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0bf4(02dc): 0b 00 7c 5c '  jmp #CALA
0bf8(02dd): 60 26 00 00 '  long @C__outa
0bfc(02de): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0c00(02df): 23 00 7c 5c '  jmp #POPM
0c04(02e0): 00 0c 00 00 '  long $c00 ' restore registers
0c08(02e1): 0c 00 7c 5c '  jmp #RETN
0c0c(02e2):             '  long ' align long
0c0c(02e2):             ' C_h48c_read_value ' <symbol:h48c_read_value>
0c0c(02e2): 09 00 7c 5c '  jmp #NEWF
0c10(02e3): 04 58 fc 84 '  sub SP, #4
0c14(02e4): 22 00 7c 5c '  jmp #PSHM
0c18(02e5): 00 0c 02 00 '  long $20c00 ' save registers
0c1c(02e6): 35 88 bc a0 '  mov r17, r2 ' reg var <- reg arg
0c20(02e7): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
0c24(02e8): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
0c28(02e9): 04 00 7c 5c '  jmp #LODA
0c2c(02ea): 84 29 00 00 '  long @C_tmpfileQ8dHEr_4d178bb2_h48c_cs_pin_L000016
0c30(02eb): 2e 7a bc 08 '  rdlong r10, RI ' reg <- INDIRI4 addrg
0c34(02ec): 3d 7c bc 2c '  shl r11, r10 ' LSHI/U (1)
0c38(02ed): 3e 6c bc a0 '  mov r3, r11 ' CVI, CVU or LOAD
0c3c(02ee): 08 5e fc a0 '  mov BC, #8 ' arg size
0c40(02ef): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0c44(02f0): 0b 00 7c 5c '  jmp #CALA
0c48(02f1): 60 26 00 00 '  long @C__outa
0c4c(02f2): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0c50(02f3): 44 6a bc a0 '  mov r2, r17 ' CVI, CVU or LOAD
0c54(02f4): 05 7c fc a0 '  mov r11, #5 ' reg <- coni
0c58(02f5): 3e 6c bc a0 '  mov r3, r11 ' CVI, CVU or LOAD
0c5c(02f6): 3e 6e bc a0 '  mov r4, r11 ' CVI, CVU or LOAD
0c60(02f7): 04 00 7c 5c '  jmp #LODA
0c64(02f8): 88 29 00 00 '  long @C_tmpfileYkNWeU_4d178bb2_h48c_clk_pin_L000015
0c68(02f9): 2e 70 bc 08 '  rdlong r5, RI ' reg ARG INDIR ADDRG
0c6c(02fa): 10 58 fc 84 '  sub SP, #16 ' stack space for reg ARGs
0c70(02fb): 1a 00 7c 5c '  jmp #PSHA
0c74(02fc): 8c 29 00 00 '  long @C_tmpfileqjwcPm_4d178bb2_h48c_dio_pin_L000014 ' stack ARG INDIR ADDRG
0c78(02fd): 14 5e fc a0 '  mov BC, #20 ' arg size
0c7c(02fe): 0b 00 7c 5c '  jmp #CALA
0c80(02ff): b4 05 00 00 '  long @C_stamp_shiftout
0c84(0300): 14 58 fc 80 '  add SP, #20 ' CALL addrg
0c88(0301): 0d 6a fc a0 '  mov r2, #13 ' reg ARG coni
0c8c(0302): 02 6c fc a0 '  mov r3, #2 ' reg ARG coni
0c90(0303): 04 00 7c 5c '  jmp #LODA
0c94(0304): 88 29 00 00 '  long @C_tmpfileYkNWeU_4d178bb2_h48c_clk_pin_L000015
0c98(0305): 2e 6e bc 08 '  rdlong r4, RI ' reg ARG INDIR ADDRG
0c9c(0306): 04 00 7c 5c '  jmp #LODA
0ca0(0307): 8c 29 00 00 '  long @C_tmpfileqjwcPm_4d178bb2_h48c_dio_pin_L000014
0ca4(0308): 2e 70 bc 08 '  rdlong r5, RI ' reg ARG INDIR ADDRG
0ca8(0309): 10 5e fc a0 '  mov BC, #16 ' arg size
0cac(030a): 10 58 fc 84 '  sub SP, #16 ' stack space for reg ARGs
0cb0(030b): 0b 00 7c 5c '  jmp #CALA
0cb4(030c): a0 07 00 00 '  long @C_stamp_shiftin
0cb8(030d): 10 58 fc 80 '  add SP, #16 ' CALL addrg
0cbc(030e): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
0cc0(030f): 05 00 7c 5c '  jmp #LODF
0cc4(0310): fc ff ff ff '  long -4
0cc8(0311): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNU4 addrl
0ccc(0312): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
0cd0(0313): 04 00 7c 5c '  jmp #LODA
0cd4(0314): 84 29 00 00 '  long @C_tmpfileQ8dHEr_4d178bb2_h48c_cs_pin_L000016
0cd8(0315): 2e 7a bc 08 '  rdlong r10, RI ' reg <- INDIRI4 addrg
0cdc(0316): 3d 7c bc 2c '  shl r11, r10 ' LSHI/U (1)
0ce0(0317): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
0ce4(0318): 3e 6c bc a0 '  mov r3, r11 ' CVI, CVU or LOAD
0ce8(0319): 08 5e fc a0 '  mov BC, #8 ' arg size
0cec(031a): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0cf0(031b): 0b 00 7c 5c '  jmp #CALA
0cf4(031c): 60 26 00 00 '  long @C__outa
0cf8(031d): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0cfc(031e): 2d 7c bc a0 '  mov r11, FP
0d00(031f): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
0d04(0320): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRU4 reg
0d08(0321): 04 00 7c 5c '  jmp #LODA
0d0c(0322): f4 27 00 00 '  long @C_h48c_read_value_L000029
0d10(0323): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
0d14(0324): 3e 66 bc a0 '  mov r0, r11 ' BANDI/U
0d18(0325): 3d 66 bc 60 '  and r0, r10 ' BANDI/U (3)
0d1c(0326): 23 00 7c 5c '  jmp #POPM
0d20(0327): 00 0c 02 00 '  long $20c00 ' restore registers
0d24(0328): 04 58 fc 80 '  add SP, #4 ' framesize
0d28(0329): 0a 00 7c 5c '  jmp #RETF
0d2c(032a):             '  long ' align long
0d2c(032a):             ' C_bbos_delay_usec
0d2c(032a): 04 00 7c 5c '                                 jmp #LODA
0d30(032b): 64 29 00 00 '                                 long @C_usec_delay
0d34(032c): 2e 7e bc 08 '                                 rdlong r12, RI ' usec delay ' r2 - t1, r3 - t2, r12 - 4us
0d38(032d): 02 7e fc 2c '                                 shl r12, #2 ' compute (usec * 4)
0d3c(032e): 02 6a fc 2a '                                 shr r2, #2 wz
0d40(032f): 01 6a e8 a0 '         if_z    mov r2, #1
0d44(0330): 3f 6c bc a0 '                                 mov r3, r12
0d48(0331): f1 6d bc 80 '                                 add r3, cnt
0d4c(0332): 29 6c fc 84 '                                 sub r3, #41
0d50(0333):             '         C_wait
0d50(0333): 3f 6c bc f8 '                                 waitcnt r3, r12
0d54(0334): 01 6a fc 84 '                                 sub r2, #1 ' decrement
0d58(0335): 35 6a 3c 62 '                                 test r2, r2 wz
0d5c(0336): 14 00 7c 5c '                                 jmp #BRNZ
0d60(0337): d4 0c 00 00 '                                 long @C_wait
0d64(0338): 0c 00 7c 5c '                                 jmp #RETN
0d68(0339):             '  long ' align long
0d68(0339):             ' C_t_char ' <symbol:t_char>
0d68(0339): 22 00 7c 5c '  jmp #PSHM
0d6c(033a): 00 08 03 00 '  long $30800 ' save registers
0d70(033b): 36 88 bc a0 '  mov r17, r3 ' reg var <- reg arg
0d74(033c): 35 86 bc a0 '  mov r16, r2 ' reg var <- reg arg
0d78(033d): 44 7c bc a0 '  mov r11, r17
0d7c(033e): 01 7c fc 60 '  and r11, #1 ' BANDU4 coni
0d80(033f): 17 7c fc 2c '  shl r11, #23 ' LSHU4 coni
0d84(0340): 43 7c bc 80 '  add r11, r16 ' ADDU (1)
0d88(0341): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
0d8c(0342): 16 6c fc a0 '  mov r3, #22 ' reg ARG coni
0d90(0343): 01 6e fc a0 '  mov r4, #1 ' reg ARG coni
0d94(0344): 0c 5e fc a0 '  mov BC, #12 ' arg size
0d98(0345): 0c 58 fc 84 '  sub SP, #12 ' stack space for reg ARGs
0d9c(0346): 0b 00 7c 5c '  jmp #CALA
0da0(0347): 3c 0d 00 00 '  long @C__short_plugin_request
0da4(0348): 0c 58 fc 80 '  add SP, #12 ' CALL addrg
0da8(0349): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
0dac(034a): 23 00 7c 5c '  jmp #POPM
0db0(034b): 00 08 03 00 '  long $30800 ' restore registers
0db4(034c): 0c 00 7c 5c '  jmp #RETN
0db8(034d):             '  long ' align long
0db8(034d):             ' C__short_plugin_request ' <symbol:_short_plugin_request>
0db8(034d): 22 00 7c 5c '  jmp #PSHM
0dbc(034e): 00 88 03 00 '  long $38800 ' save registers
0dc0(034f): 37 88 bc a0 '  mov r17, r4 ' reg var <- reg arg
0dc4(0350): 36 86 bc a0 '  mov r16, r3 ' reg var <- reg arg
0dc8(0351): 35 84 bc a0 '  mov r15, r2 ' reg var <- reg arg
0dcc(0352): 43 7c bc a0 '  mov r11, r16
0dd0(0353): 18 7c fc 2c '  shl r11, #24 ' LSHI4 coni
0dd4(0354): 3e 6a bc a0 '  mov r2, r11 ' ADDI/P
0dd8(0355): 42 6a bc d0 '  adds r2, r15 ' ADDI/P (3)
0ddc(0356): 44 6c bc a0 '  mov r3, r17 ' CVI, CVU or LOAD
0de0(0357): 08 5e fc a0 '  mov BC, #8 ' arg size
0de4(0358): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0de8(0359): 0b 00 7c 5c '  jmp #CALA
0dec(035a): 74 01 00 00 '  long @C__sys_plugin
0df0(035b): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0df4(035c): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
0df8(035d): 23 00 7c 5c '  jmp #POPM
0dfc(035e): 00 88 03 00 '  long $38800 ' restore registers
0e00(035f): 0c 00 7c 5c '  jmp #RETN
0e04(0360):             '  long ' align long
0e04(0360):             ' C__long_plugin_request ' <symbol:_long_plugin_request>
0e04(0360): 09 00 7c 5c '  jmp #NEWF
0e08(0361): 04 58 fc 84 '  sub SP, #4
0e0c(0362): 22 00 7c 5c '  jmp #PSHM
0e10(0363): 00 8c 03 00 '  long $38c00 ' save registers
0e14(0364): 37 88 bc a0 '  mov r17, r4 ' reg var <- reg arg
0e18(0365): 36 86 bc a0 '  mov r16, r3 ' reg var <- reg arg
0e1c(0366): 35 84 bc a0 '  mov r15, r2 ' reg var <- reg arg
0e20(0367): 05 00 7c 5c '  jmp #LODF
0e24(0368): fc ff ff ff '  long -4
0e28(0369): 2e 84 3c 08 '  wrlong r15, RI ' ASGNI4 addrl
0e2c(036a): 43 7c bc a0 '  mov r11, r16
0e30(036b): 18 7c fc 2c '  shl r11, #24 ' LSHI4 coni
0e34(036c): 2d 7a bc a0 '  mov r10, FP
0e38(036d): 04 7a fc 84 '  sub r10, #-(-4) ' reg <- addrli
0e3c(036e): 3e 6a bc a0 '  mov r2, r11 ' ADDI/P
0e40(036f): 3d 6a bc d0 '  adds r2, r10 ' ADDI/P (3)
0e44(0370): 44 6c bc a0 '  mov r3, r17 ' CVI, CVU or LOAD
0e48(0371): 08 5e fc a0 '  mov BC, #8 ' arg size
0e4c(0372): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0e50(0373): 0b 00 7c 5c '  jmp #CALA
0e54(0374): 74 01 00 00 '  long @C__sys_plugin
0e58(0375): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0e5c(0376): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
0e60(0377): 23 00 7c 5c '  jmp #POPM
0e64(0378): 00 8c 03 00 '  long $38c00 ' restore registers
0e68(0379): 04 58 fc 80 '  add SP, #4 ' framesize
0e6c(037a): 0a 00 7c 5c '  jmp #RETF
0e70(037b):             '  long ' align long
0e70(037b):             ' C__long_plugin_request_2 ' <symbol:_long_plugin_request_2>
0e70(037b): 09 00 7c 5c '  jmp #NEWF
0e74(037c): 08 58 fc 84 '  sub SP, #8
0e78(037d): 22 00 7c 5c '  jmp #PSHM
0e7c(037e): 00 cc 03 00 '  long $3cc00 ' save registers
0e80(037f): 38 88 bc a0 '  mov r17, r5 ' reg var <- reg arg
0e84(0380): 37 86 bc a0 '  mov r16, r4 ' reg var <- reg arg
0e88(0381): 36 84 bc a0 '  mov r15, r3 ' reg var <- reg arg
0e8c(0382): 35 82 bc a0 '  mov r14, r2 ' reg var <- reg arg
0e90(0383): 05 00 7c 5c '  jmp #LODF
0e94(0384): f8 ff ff ff '  long -8
0e98(0385): 2e 84 3c 08 '  wrlong r15, RI ' ASGNI4 addrl
0e9c(0386): 05 00 7c 5c '  jmp #LODF
0ea0(0387): fc ff ff ff '  long -4
0ea4(0388): 2e 82 3c 08 '  wrlong r14, RI ' ASGNI4 addrl
0ea8(0389): 43 7c bc a0 '  mov r11, r16
0eac(038a): 18 7c fc 2c '  shl r11, #24 ' LSHI4 coni
0eb0(038b): 2d 7a bc a0 '  mov r10, FP
0eb4(038c): 08 7a fc 84 '  sub r10, #-(-8) ' reg <- addrli
0eb8(038d): 3e 6a bc a0 '  mov r2, r11 ' ADDI/P
0ebc(038e): 3d 6a bc d0 '  adds r2, r10 ' ADDI/P (3)
0ec0(038f): 44 6c bc a0 '  mov r3, r17 ' CVI, CVU or LOAD
0ec4(0390): 08 5e fc a0 '  mov BC, #8 ' arg size
0ec8(0391): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0ecc(0392): 0b 00 7c 5c '  jmp #CALA
0ed0(0393): 74 01 00 00 '  long @C__sys_plugin
0ed4(0394): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0ed8(0395): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
0edc(0396): 23 00 7c 5c '  jmp #POPM
0ee0(0397): 00 cc 03 00 '  long $3cc00 ' restore registers
0ee4(0398): 08 58 fc 80 '  add SP, #8 ' framesize
0ee8(0399): 0a 00 7c 5c '  jmp #RETF
0eec(039a):             '  long ' align long
0eec(039a):             ' C_catalina_putc ' <symbol:catalina_putc>
0eec(039a): 22 00 7c 5c '  jmp #PSHM
0ef0(039b): 00 0c 03 00 '  long $30c00 ' save registers
0ef4(039c): 36 88 bc a0 '  mov r17, r3 ' reg var <- reg arg
0ef8(039d): 35 86 bc a0 '  mov r16, r2 ' reg var <- reg arg
0efc(039e): 43 7c bc a0 '  mov r11, r16 ' CVI, CVU or LOAD
0f00(039f): 04 00 7c 5c '  jmp #LODA
0f04(03a0): e4 28 00 00 '  long @C___stdout
0f08(03a1): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
0f0c(03a2): 3d 7c 3c 86 '  cmp r11, r10 wz
0f10(03a3): 14 00 7c 5c '  jmp #BRNZ
0f14(03a4): c0 0e 00 00 '  long @C_catalina_putc_2 ' NEU4
0f18(03a5): 44 6a bc a0 '  mov r2, r17 ' CVI, CVU or LOAD
0f1c(03a6): 01 6c fc a0 '  mov r3, #1 ' reg ARG coni
0f20(03a7): 08 5e fc a0 '  mov BC, #8 ' arg size
0f24(03a8): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0f28(03a9): 0b 00 7c 5c '  jmp #CALA
0f2c(03aa): ec 0c 00 00 '  long @C_t_char
0f30(03ab): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0f34(03ac): 0e 00 7c 5c '  jmp #JMPA
0f38(03ad): f8 0e 00 00 '  long @C_catalina_putc_3 ' JUMPV addrg
0f3c(03ae):             ' C_catalina_putc_2
0f3c(03ae): 43 7c bc a0 '  mov r11, r16 ' CVI, CVU or LOAD
0f40(03af): 04 00 7c 5c '  jmp #LODA
0f44(03b0): fc 28 00 00 '  long @C___stderr
0f48(03b1): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
0f4c(03b2): 3d 7c 3c 86 '  cmp r11, r10 wz
0f50(03b3): 14 00 7c 5c '  jmp #BRNZ
0f54(03b4): f8 0e 00 00 '  long @C_catalina_putc_4 ' NEU4
0f58(03b5): 44 6a bc a0 '  mov r2, r17 ' CVI, CVU or LOAD
0f5c(03b6): 01 6c fc a0 '  mov r3, #1 ' reg ARG coni
0f60(03b7): 08 5e fc a0 '  mov BC, #8 ' arg size
0f64(03b8): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0f68(03b9): 0b 00 7c 5c '  jmp #CALA
0f6c(03ba): ec 0c 00 00 '  long @C_t_char
0f70(03bb): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0f74(03bc):             ' C_catalina_putc_4
0f74(03bc):             ' C_catalina_putc_3
0f74(03bc): 44 66 bc a0 '  mov r0, r17 ' CVI, CVU or LOAD
0f78(03bd): 23 00 7c 5c '  jmp #POPM
0f7c(03be): 00 0c 03 00 '  long $30c00 ' restore registers
0f80(03bf): 0c 00 7c 5c '  jmp #RETN
0f84(03c0):             '  long ' align long
0f84(03c0):             ' C__clockfreq
0f84(03c0): 00 66 fc 08 '  rdlong r0,#0
0f88(03c1): 0c 00 7c 5c '  jmp #RETN
0f8c(03c2):             '  long ' align long
0f8c(03c2):             ' C__clockinit
0f8c(03c2): 00 6c 7c 0c '  clkset r3
0f90(03c3): 04 6c 7c 00 '  wrbyte r3, #4
0f94(03c4): 00 6a 7c 08 '  wrlong r2, #0
0f98(03c5): 0c 00 7c 5c '  jmp #RETN
0f9c(03c6):             '  long ' align long
0f9c(03c6):             ' C__cnt
0f9c(03c6): f1 67 bc a0 '  mov r0, CNT
0fa0(03c7): 0c 00 7c 5c '  jmp #RETN
0fa4(03c8):             '  long ' align long
0fa4(03c8):             ' C__dira
0fa4(03c8): f6 67 bc a0 '  mov r0, DIRA
0fa8(03c9): 36 ec bf 64 '  andn DIRA, r3
0fac(03ca): 35 ec bf 68 '  or DIRA, r2
0fb0(03cb): 0c 00 7c 5c '  jmp #RETN
0fb4(03cc):             '  long ' align long
0fb4(03cc):             ' C_tmpfilexMRBQL_4c2c6c11_gnum_L000001 ' <symbol:gnum>
0fb4(03cc): 22 00 7c 5c '  jmp #PSHM
0fb8(03cd): 00 ec 03 00 '  long $3ec00 ' save registers
0fbc(03ce): 37 88 bc a0 '  mov r17, r4 ' reg var <- reg arg
0fc0(03cf): 36 86 bc a0 '  mov r16, r3 ' reg var <- reg arg
0fc4(03d0): 35 84 bc a0 '  mov r15, r2 ' reg var <- reg arg
0fc8(03d1): 44 7c bc 00 '  rdbyte r11, r17 ' reg <- INDIRU1 reg
0fcc(03d2): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
0fd0(03d3): 2a 7c 7c c2 '  cmps r11,  #42 wz
0fd4(03d4): 14 00 7c 5c '  jmp #BRNZ
0fd8(03d5): 90 0f 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_3 ' NEI4
0fdc(03d6): 42 7c bc 08 '  rdlong r11, r15 ' reg <- INDIRP4 reg
0fe0(03d7): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
0fe4(03d8): 42 7c 3c 08 '  wrlong r11, r15 ' ASGNP4 reg
0fe8(03d9): 04 00 7c 5c '  jmp #LODA
0fec(03da): 74 28 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
0ff0(03db): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
0ff4(03dc): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
0ff8(03dd): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
0ffc(03de): 43 7c 3c 08 '  wrlong r11, r16 ' ASGNI4 reg
1000(03df): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1004(03e0): 0e 00 7c 5c '  jmp #JMPA
1008(03e1): e4 0f 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_4 ' JUMPV addrg
100c(03e2):             ' C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_3
100c(03e2): 00 82 fc a0 '  mov r14, #0 ' reg <- coni
1010(03e3): 0e 00 7c 5c '  jmp #JMPA
1014(03e4): b8 0f 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_9 ' JUMPV addrg
1018(03e5):             ' C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_8
1018(03e5): 0a 7c fc a0 '  mov r11, #10 ' reg <- coni
101c(03e6): 3e 66 bc a0 '  mov r0, r11 ' setup r0/r1 (2)
1020(03e7): 41 68 bc a0 '  mov r1, r14 ' setup r0/r1 (2)
1024(03e8): 12 00 7c 5c '  jmp #MULT ' MULT(I/U)
1028(03e9): 33 82 bc a0 '  mov r14, r0 ' ADDI/P
102c(03ea): 40 82 bc d0 '  adds r14, r13 ' ADDI/P (3)
1030(03eb): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1034(03ec):             ' C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_9
1034(03ec): 44 7c bc 00 '  rdbyte r11, r17 ' reg <- INDIRU1 reg
1038(03ed): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
103c(03ee): 30 7c fc d4 '  subs r11, #48 ' SUBI4 coni
1040(03ef): 3e 80 bc a0 '  mov r13, r11 ' CVI, CVU or LOAD
1044(03f0): 00 7c 7c c3 '  cmps r11,  #0 wz,wc
1048(03f1): 18 00 7c 5c '  jmp #BR_B
104c(03f2): e0 0f 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_11 ' LTI4
1050(03f3): 09 80 7c c3 '  cmps r13,  #9 wz,wc
1054(03f4): 17 00 7c 5c '  jmp #BRBE
1058(03f5): 9c 0f 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_8 ' LEI4
105c(03f6):             ' C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_11
105c(03f6): 43 82 3c 08 '  wrlong r14, r16 ' ASGNI4 reg
1060(03f7):             ' C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_4
1060(03f7): 44 66 bc a0 '  mov r0, r17 ' CVI, CVU or LOAD
1064(03f8): 23 00 7c 5c '  jmp #POPM
1068(03f9): 00 ec 03 00 '  long $3ec00 ' restore registers
106c(03fa): 0c 00 7c 5c '  jmp #RETN
1070(03fb):             '  long ' align long
1070(03fb):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012 ' <symbol:o_print>
1070(03fb): 09 00 7c 5c '  jmp #NEWF
1074(03fc): 10 58 fc 84 '  sub SP, #16
1078(03fd): 22 00 7c 5c '  jmp #PSHM
107c(03fe): 00 fc 03 00 '  long $3fc00 ' save registers
1080(03ff): 38 88 bc a0 '  mov r17, r5 ' reg var <- reg arg
1084(0400): 37 86 bc a0 '  mov r16, r4 ' reg var <- reg arg
1088(0401): 36 84 bc a0 '  mov r15, r3 ' reg var <- reg arg
108c(0402): 35 82 bc a0 '  mov r14, r2 ' reg var <- reg arg
1090(0403): 44 80 bc a0 '  mov r13, r17 ' CVI, CVU or LOAD
1094(0404): 2d 7c bc a0 '  mov r11, FP
1098(0405): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
109c(0406): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
10a0(0407): 3e 7e bc a0 '  mov r12, r11
10a4(0408): 60 7e fc 60 '  and r12, #96 ' BANDI4 coni
10a8(0409): 20 7c fc a0 '  mov r11, #32 ' reg <- coni
10ac(040a): 3e 7e 3c c2 '  cmps r12, r11 wz
10b0(040b): 13 00 7c 5c '  jmp #BR_Z
10b4(040c): 5c 10 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_17 ' EQI4
10b8(040d): 3e 7e 3c c3 '  cmps r12, r11 wz,wc
10bc(040e): 18 00 7c 5c '  jmp #BR_B
10c0(040f): 80 11 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_14 ' LTI4
10c4(0410): 40 7e 7c c2 '  cmps r12,  #64 wz
10c8(0411): 13 00 7c 5c '  jmp #BR_Z
10cc(0412): f4 10 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_20 ' EQI4
10d0(0413): 0e 00 7c 5c '  jmp #JMPA
10d4(0414): 80 11 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_14 ' JUMPV addrg
10d8(0415):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_17
10d8(0415): 00 82 7c c2 '  cmps r14,  #0 wz
10dc(0416): 13 00 7c 5c '  jmp #BR_Z
10e0(0417): b0 10 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_18 ' EQI4
10e4(0418): 2d 7c bc a0 '  mov r11, FP
10e8(0419): 08 7c fc 80 '  add r11, #8 ' reg <- addrfi
10ec(041a): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
10f0(041b): 3e 7a bc 08 '  rdlong r10, r11 ' reg <- INDIRP4 reg
10f4(041c): 04 7a fc d0 '  adds r10, #4 ' ADDP4 coni
10f8(041d): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
10fc(041e): 04 00 7c 5c '  jmp #LODA
1100(041f): 74 28 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
1104(0420): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1108(0421): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (2)
110c(0422): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1110(0423): 10 7c fc 2c '  shl r11, #16
1114(0424): 10 7c fc 38 '  sar r11, #16 ' sign extend
1118(0425): 05 00 7c 5c '  jmp #LODF
111c(0426): f8 ff ff ff '  long -8
1120(0427): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1124(0428): 0e 00 7c 5c '  jmp #JMPA
1128(0429): 04 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_15 ' JUMPV addrg
112c(042a):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_18
112c(042a): 2d 7c bc a0 '  mov r11, FP
1130(042b): 08 7c fc 80 '  add r11, #8 ' reg <- addrfi
1134(042c): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1138(042d): 3e 7a bc 08 '  rdlong r10, r11 ' reg <- INDIRP4 reg
113c(042e): 04 7a fc d0 '  adds r10, #4 ' ADDP4 coni
1140(042f): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
1144(0430): 04 00 7c 5c '  jmp #LODA
1148(0431): 74 28 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
114c(0432): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1150(0433): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (2)
1154(0434): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRU4 reg
1158(0435): 4e 7c bc 60 '  and r11, cviu_m2 ' zero extend
115c(0436): 05 00 7c 5c '  jmp #LODF
1160(0437): fc ff ff ff '  long -4
1164(0438): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNU4 addrl
1168(0439): 0e 00 7c 5c '  jmp #JMPA
116c(043a): 04 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_15 ' JUMPV addrg
1170(043b):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_20
1170(043b): 00 82 7c c2 '  cmps r14,  #0 wz
1174(043c): 13 00 7c 5c '  jmp #BR_Z
1178(043d): 40 11 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_21 ' EQI4
117c(043e): 2d 7c bc a0 '  mov r11, FP
1180(043f): 08 7c fc 80 '  add r11, #8 ' reg <- addrfi
1184(0440): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1188(0441): 3e 7a bc 08 '  rdlong r10, r11 ' reg <- INDIRP4 reg
118c(0442): 04 7a fc d0 '  adds r10, #4 ' ADDP4 coni
1190(0443): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
1194(0444): 04 00 7c 5c '  jmp #LODA
1198(0445): 74 28 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
119c(0446): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
11a0(0447): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (2)
11a4(0448): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
11a8(0449): 05 00 7c 5c '  jmp #LODF
11ac(044a): f8 ff ff ff '  long -8
11b0(044b): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
11b4(044c): 0e 00 7c 5c '  jmp #JMPA
11b8(044d): 04 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_15 ' JUMPV addrg
11bc(044e):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_21
11bc(044e): 2d 7c bc a0 '  mov r11, FP
11c0(044f): 08 7c fc 80 '  add r11, #8 ' reg <- addrfi
11c4(0450): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
11c8(0451): 3e 7a bc 08 '  rdlong r10, r11 ' reg <- INDIRP4 reg
11cc(0452): 04 7a fc d0 '  adds r10, #4 ' ADDP4 coni
11d0(0453): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
11d4(0454): 04 00 7c 5c '  jmp #LODA
11d8(0455): 74 28 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
11dc(0456): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
11e0(0457): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (2)
11e4(0458): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRU4 reg
11e8(0459): 05 00 7c 5c '  jmp #LODF
11ec(045a): fc ff ff ff '  long -4
11f0(045b): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNU4 addrl
11f4(045c): 0e 00 7c 5c '  jmp #JMPA
11f8(045d): 04 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_15 ' JUMPV addrg
11fc(045e):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_14
11fc(045e): 00 82 7c c2 '  cmps r14,  #0 wz
1200(045f): 13 00 7c 5c '  jmp #BR_Z
1204(0460): cc 11 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_23 ' EQI4
1208(0461): 2d 7c bc a0 '  mov r11, FP
120c(0462): 08 7c fc 80 '  add r11, #8 ' reg <- addrfi
1210(0463): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1214(0464): 3e 7a bc 08 '  rdlong r10, r11 ' reg <- INDIRP4 reg
1218(0465): 04 7a fc d0 '  adds r10, #4 ' ADDP4 coni
121c(0466): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
1220(0467): 04 00 7c 5c '  jmp #LODA
1224(0468): 74 28 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
1228(0469): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
122c(046a): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (2)
1230(046b): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1234(046c): 05 00 7c 5c '  jmp #LODF
1238(046d): f8 ff ff ff '  long -8
123c(046e): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1240(046f): 0e 00 7c 5c '  jmp #JMPA
1244(0470): 04 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_15 ' JUMPV addrg
1248(0471):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_23
1248(0471): 2d 7c bc a0 '  mov r11, FP
124c(0472): 08 7c fc 80 '  add r11, #8 ' reg <- addrfi
1250(0473): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1254(0474): 3e 7a bc 08 '  rdlong r10, r11 ' reg <- INDIRP4 reg
1258(0475): 04 7a fc d0 '  adds r10, #4 ' ADDP4 coni
125c(0476): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
1260(0477): 04 00 7c 5c '  jmp #LODA
1264(0478): 74 28 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
1268(0479): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
126c(047a): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (2)
1270(047b): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRU4 reg
1274(047c): 05 00 7c 5c '  jmp #LODF
1278(047d): fc ff ff ff '  long -4
127c(047e): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNU4 addrl
1280(047f):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_15
1280(047f): 00 82 7c c2 '  cmps r14,  #0 wz
1284(0480): 13 00 7c 5c '  jmp #BR_Z
1288(0481): e0 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_26 ' EQI4
128c(0482): 2d 7c bc a0 '  mov r11, FP
1290(0483): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
1294(0484): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1298(0485): 00 7c 7c c3 '  cmps r11,  #0 wz,wc
129c(0486): 15 00 7c 5c '  jmp #BRAE
12a0(0487): 60 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_28 ' GEI4
12a4(0488): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
12a8(0489): 3e 88 bc a0 '  mov r17, r11
12ac(048a): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
12b0(048b): 2d 7a fc a0 '  mov r10, #45 ' reg <- coni
12b4(048c): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
12b8(048d): 2d 7c bc a0 '  mov r11, FP
12bc(048e): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
12c0(048f): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
12c4(0490): 3e 7c bc a4 '  neg r11, r11 ' NEGI4
12c8(0491): 05 00 7c 5c '  jmp #LODF
12cc(0492): f8 ff ff ff '  long -8
12d0(0493): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
12d4(0494): 0e 00 7c 5c '  jmp #JMPA
12d8(0495): c8 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_29 ' JUMPV addrg
12dc(0496):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_28
12dc(0496): 2d 7c bc a0 '  mov r11, FP
12e0(0497): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
12e4(0498): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
12e8(0499): 02 7c fc 60 '  and r11, #2 ' BANDI4 coni
12ec(049a): 00 7c 7c c2 '  cmps r11,  #0 wz
12f0(049b): 13 00 7c 5c '  jmp #BR_Z
12f4(049c): 98 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_30 ' EQI4
12f8(049d): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
12fc(049e): 3e 88 bc a0 '  mov r17, r11
1300(049f): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1304(04a0): 2b 7a fc a0 '  mov r10, #43 ' reg <- coni
1308(04a1): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
130c(04a2): 0e 00 7c 5c '  jmp #JMPA
1310(04a3): c8 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_31 ' JUMPV addrg
1314(04a4):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_30
1314(04a4): 2d 7c bc a0 '  mov r11, FP
1318(04a5): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
131c(04a6): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1320(04a7): 04 7c fc 60 '  and r11, #4 ' BANDI4 coni
1324(04a8): 00 7c 7c c2 '  cmps r11,  #0 wz
1328(04a9): 13 00 7c 5c '  jmp #BR_Z
132c(04aa): c8 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_32 ' EQI4
1330(04ab): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
1334(04ac): 3e 88 bc a0 '  mov r17, r11
1338(04ad): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
133c(04ae): 20 7a fc a0 '  mov r10, #32 ' reg <- coni
1340(04af): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
1344(04b0):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_32
1344(04b0):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_31
1344(04b0):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_29
1344(04b0): 2d 7c bc a0 '  mov r11, FP
1348(04b1): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
134c(04b2): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1350(04b3): 05 00 7c 5c '  jmp #LODF
1354(04b4): fc ff ff ff '  long -4
1358(04b5): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNU4 addrl
135c(04b6):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_26
135c(04b6): 2d 7c bc a0 '  mov r11, FP
1360(04b7): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
1364(04b8): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1368(04b9): 08 7c fc 60 '  and r11, #8 ' BANDI4 coni
136c(04ba): 00 7c 7c c2 '  cmps r11,  #0 wz
1370(04bb): 13 00 7c 5c '  jmp #BR_Z
1374(04bc): 24 13 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_34 ' EQI4
1378(04bd): 43 7c bc a0 '  mov r11, r16 ' CVUI
137c(04be): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
1380(04bf): 6f 7c 7c c2 '  cmps r11,  #111 wz
1384(04c0): 14 00 7c 5c '  jmp #BRNZ
1388(04c1): 24 13 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_34 ' NEI4
138c(04c2): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
1390(04c3): 3e 88 bc a0 '  mov r17, r11
1394(04c4): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1398(04c5): 30 7a fc a0 '  mov r10, #48 ' reg <- coni
139c(04c6): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
13a0(04c7):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_34
13a0(04c7): 2d 7c bc a0 '  mov r11, FP
13a4(04c8): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
13a8(04c9): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRU4 reg
13ac(04ca): 00 7c 7c 86 '  cmp r11,  #0 wz
13b0(04cb): 14 00 7c 5c '  jmp #BRNZ
13b4(04cc): 54 13 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_36 ' NEU4
13b8(04cd): 00 84 7c c2 '  cmps r15,  #0 wz
13bc(04ce): 14 00 7c 5c '  jmp #BRNZ
13c0(04cf): 10 14 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_37 ' NEI4
13c4(04d0): 44 66 bc a0 '  mov r0, r17 ' CVI, CVU or LOAD
13c8(04d1): 0e 00 7c 5c '  jmp #JMPA
13cc(04d2): f0 15 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_13 ' JUMPV addrg
13d0(04d3):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_36
13d0(04d3): 2d 7c bc a0 '  mov r11, FP
13d4(04d4): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
13d8(04d5): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
13dc(04d6): 08 7c fc 60 '  and r11, #8 ' BANDI4 coni
13e0(04d7): 00 7c 7c c2 '  cmps r11,  #0 wz
13e4(04d8): 13 00 7c 5c '  jmp #BR_Z
13e8(04d9): 90 13 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_43 ' EQI4
13ec(04da): 43 7c bc a0 '  mov r11, r16 ' CVUI
13f0(04db): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
13f4(04dc): 78 7c 7c c2 '  cmps r11,  #120 wz
13f8(04dd): 13 00 7c 5c '  jmp #BR_Z
13fc(04de): a4 13 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_42 ' EQI4
1400(04df): 58 7c 7c c2 '  cmps r11,  #88 wz
1404(04e0): 13 00 7c 5c '  jmp #BR_Z
1408(04e1): a4 13 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_42 ' EQI4
140c(04e2):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_43
140c(04e2): 43 7c bc a0 '  mov r11, r16 ' CVUI
1410(04e3): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
1414(04e4): 70 7c 7c c2 '  cmps r11,  #112 wz
1418(04e5): 14 00 7c 5c '  jmp #BRNZ
141c(04e6): 10 14 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_40 ' NEI4
1420(04e7):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_42
1420(04e7): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
1424(04e8): 3e 88 bc a0 '  mov r17, r11
1428(04e9): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
142c(04ea): 30 7a fc a0 '  mov r10, #48 ' reg <- coni
1430(04eb): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
1434(04ec): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
1438(04ed): 3e 88 bc a0 '  mov r17, r11
143c(04ee): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1440(04ef): 43 7a bc a0 '  mov r10, r16 ' CVUI
1444(04f0): 4d 7a bc 60 '  and r10, cviu_m1 ' zero extend
1448(04f1): 58 7a 7c c2 '  cmps r10,  #88 wz
144c(04f2): 14 00 7c 5c '  jmp #BRNZ
1450(04f3): f0 13 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_45 ' NEI4
1454(04f4): 58 7a fc a0 '  mov r10, #88 ' reg <- coni
1458(04f5): 05 00 7c 5c '  jmp #LODF
145c(04f6): f0 ff ff ff '  long -16
1460(04f7): 2e 7a 3c 08 '  wrlong r10, RI ' ASGNI4 addrl
1464(04f8): 0e 00 7c 5c '  jmp #JMPA
1468(04f9): 00 14 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_46 ' JUMPV addrg
146c(04fa):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_45
146c(04fa): 78 7a fc a0 '  mov r10, #120 ' reg <- coni
1470(04fb): 05 00 7c 5c '  jmp #LODF
1474(04fc): f0 ff ff ff '  long -16
1478(04fd): 2e 7a 3c 08 '  wrlong r10, RI ' ASGNI4 addrl
147c(04fe):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_46
147c(04fe): 2d 7a bc a0 '  mov r10, FP
1480(04ff): 10 7a fc 84 '  sub r10, #-(-16) ' reg <- addrli
1484(0500): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRI4 reg
1488(0501): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
148c(0502):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_40
148c(0502):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_37
148c(0502): 43 7c bc a0 '  mov r11, r16 ' CVUI
1490(0503): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
1494(0504): 05 00 7c 5c '  jmp #LODF
1498(0505): f0 ff ff ff '  long -16
149c(0506): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
14a0(0507): 2d 7c bc a0 '  mov r11, FP
14a4(0508): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
14a8(0509): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
14ac(050a): 69 7a fc a0 '  mov r10, #105 ' reg <- coni
14b0(050b): 3d 7c 3c c2 '  cmps r11, r10 wz
14b4(050c): 13 00 7c 5c '  jmp #BR_Z
14b8(050d): 30 15 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_52 ' EQI4
14bc(050e): 3d 7c 3c c3 '  cmps r11, r10 wz,wc
14c0(050f): 16 00 7c 5c '  jmp #BR_A
14c4(0510): a0 14 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_55 ' GTI4
14c8(0511): 2d 7c bc a0 '  mov r11, FP
14cc(0512): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
14d0(0513): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
14d4(0514): 58 7a fc a0 '  mov r10, #88 ' reg <- coni
14d8(0515): 3d 7c 3c c2 '  cmps r11, r10 wz
14dc(0516): 13 00 7c 5c '  jmp #BR_Z
14e0(0517): 48 15 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_53 ' EQI4
14e4(0518): 3d 7c 3c c3 '  cmps r11, r10 wz,wc
14e8(0519): 18 00 7c 5c '  jmp #BR_B
14ec(051a): 58 15 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_47 ' LTI4
14f0(051b): 2d 7c bc a0 '  mov r11, FP
14f4(051c): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
14f8(051d): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
14fc(051e): 62 7c 7c c2 '  cmps r11,  #98 wz
1500(051f): 13 00 7c 5c '  jmp #BR_Z
1504(0520): 00 15 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_50 ' EQI4
1508(0521): 64 7c 7c c2 '  cmps r11,  #100 wz
150c(0522): 13 00 7c 5c '  jmp #BR_Z
1510(0523): 30 15 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_52 ' EQI4
1514(0524): 0e 00 7c 5c '  jmp #JMPA
1518(0525): 58 15 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_47 ' JUMPV addrg
151c(0526):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_55
151c(0526): 2d 7c bc a0 '  mov r11, FP
1520(0527): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
1524(0528): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1528(0529): 6f 7a fc a0 '  mov r10, #111 ' reg <- coni
152c(052a): 3d 7c 3c c2 '  cmps r11, r10 wz
1530(052b): 13 00 7c 5c '  jmp #BR_Z
1534(052c): 18 15 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_51 ' EQI4
1538(052d): 70 7c 7c c2 '  cmps r11,  #112 wz
153c(052e): 13 00 7c 5c '  jmp #BR_Z
1540(052f): 48 15 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_53 ' EQI4
1544(0530): 3d 7c 3c c3 '  cmps r11, r10 wz,wc
1548(0531): 18 00 7c 5c '  jmp #BR_B
154c(0532): 58 15 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_47 ' LTI4
1550(0533): 2d 7c bc a0 '  mov r11, FP
1554(0534): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
1558(0535): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
155c(0536): 75 7c 7c c2 '  cmps r11,  #117 wz
1560(0537): 13 00 7c 5c '  jmp #BR_Z
1564(0538): 30 15 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_52 ' EQI4
1568(0539): 78 7c 7c c2 '  cmps r11,  #120 wz
156c(053a): 13 00 7c 5c '  jmp #BR_Z
1570(053b): 48 15 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_53 ' EQI4
1574(053c): 0e 00 7c 5c '  jmp #JMPA
1578(053d): 58 15 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_47 ' JUMPV addrg
157c(053e):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_50
157c(053e): 02 7c fc a0 '  mov r11, #2 ' reg <- coni
1580(053f): 05 00 7c 5c '  jmp #LODF
1584(0540): f4 ff ff ff '  long -12
1588(0541): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
158c(0542): 0e 00 7c 5c '  jmp #JMPA
1590(0543): 58 15 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_48 ' JUMPV addrg
1594(0544):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_51
1594(0544): 08 7c fc a0 '  mov r11, #8 ' reg <- coni
1598(0545): 05 00 7c 5c '  jmp #LODF
159c(0546): f4 ff ff ff '  long -12
15a0(0547): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
15a4(0548): 0e 00 7c 5c '  jmp #JMPA
15a8(0549): 58 15 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_48 ' JUMPV addrg
15ac(054a):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_52
15ac(054a): 0a 7c fc a0 '  mov r11, #10 ' reg <- coni
15b0(054b): 05 00 7c 5c '  jmp #LODF
15b4(054c): f4 ff ff ff '  long -12
15b8(054d): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
15bc(054e): 0e 00 7c 5c '  jmp #JMPA
15c0(054f): 58 15 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_48 ' JUMPV addrg
15c4(0550):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_53
15c4(0550): 10 7c fc a0 '  mov r11, #16 ' reg <- coni
15c8(0551): 05 00 7c 5c '  jmp #LODF
15cc(0552): f4 ff ff ff '  long -12
15d0(0553): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
15d4(0554):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_47
15d4(0554):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_48
15d4(0554): 42 6a bc a0 '  mov r2, r15 ' CVI, CVU or LOAD
15d8(0555): 44 6c bc a0 '  mov r3, r17 ' CVI, CVU or LOAD
15dc(0556): 2d 5c bc a0 '  mov RI, FP
15e0(0557): 0c 5c fc 84 '  sub RI, #-(-12)
15e4(0558): 2e 6e bc 08 '  rdlong r4, RI ' reg ARG INDIR ADDRLi
15e8(0559): 2d 5c bc a0 '  mov RI, FP
15ec(055a): 04 5c fc 84 '  sub RI, #-(-4)
15f0(055b): 2e 70 bc 08 '  rdlong r5, RI ' reg ARG INDIR ADDRLi
15f4(055c): 10 5e fc a0 '  mov BC, #16 ' arg size
15f8(055d): 10 58 fc 84 '  sub SP, #16 ' stack space for reg ARGs
15fc(055e): 0b 00 7c 5c '  jmp #CALA
1600(055f): 8c 25 00 00 '  long @C__i_compute
1604(0560): 10 58 fc 80 '  add SP, #16 ' CALL addrg
1608(0561): 33 88 bc a0 '  mov r17, r0 ' CVI, CVU or LOAD
160c(0562): 43 7c bc a0 '  mov r11, r16 ' CVUI
1610(0563): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
1614(0564): 58 7c 7c c2 '  cmps r11,  #88 wz
1618(0565): 14 00 7c 5c '  jmp #BRNZ
161c(0566): ec 15 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_58 ' NEI4
1620(0567): 0e 00 7c 5c '  jmp #JMPA
1624(0568): d8 15 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_61 ' JUMPV addrg
1628(0569):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_60
1628(0569): 40 7c bc 00 '  rdbyte r11, r13 ' reg <- INDIRU1 reg
162c(056a): 3e 6a bc a0 '  mov r2, r11 ' CVUI
1630(056b): 4d 6a bc 60 '  and r2, cviu_m1 ' zero extend
1634(056c): 04 5e fc a0 '  mov BC, #4 ' arg size
1638(056d): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
163c(056e): 0b 00 7c 5c '  jmp #CALA
1640(056f): 64 27 00 00 '  long @C_toupper
1644(0570): 04 58 fc 80 '  add SP, #4 ' CALL addrg
1648(0571): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
164c(0572): 40 7c 3c 00 '  wrbyte r11, r13 ' ASGNU1 reg
1650(0573): 01 80 fc d0 '  adds r13, #1 ' ADDP4 coni
1654(0574):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_61
1654(0574): 40 7c bc a0 '  mov r11, r13 ' CVI, CVU or LOAD
1658(0575): 44 7a bc a0 '  mov r10, r17 ' CVI, CVU or LOAD
165c(0576): 3d 7c 3c 86 '  cmp r11, r10 wz
1660(0577): 14 00 7c 5c '  jmp #BRNZ
1664(0578): ac 15 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_60 ' NEU4
1668(0579):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_58
1668(0579): 44 66 bc a0 '  mov r0, r17 ' CVI, CVU or LOAD
166c(057a):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_13
166c(057a): 23 00 7c 5c '  jmp #POPM
1670(057b): 00 fc 03 00 '  long $3fc00 ' restore registers
1674(057c): 10 58 fc 80 '  add SP, #16 ' framesize
1678(057d): 0a 00 7c 5c '  jmp #RETF
167c(057e):             '  long ' align long
167c(057e):             ' C__doprnt ' <symbol:_doprnt>
167c(057e): 09 00 7c 5c '  jmp #NEWF
1680(057f): 03 00 7c 5c '  jmp #LODL
1684(0580): 30 04 00 00 '  long 1072
1688(0581): 2e 58 bc 84 '  sub SP, RI
168c(0582): 22 00 7c 5c '  jmp #PSHM
1690(0583): 00 fe 03 00 '  long $3fe00 ' save registers
1694(0584): 37 88 bc a0 '  mov r17, r4 ' reg var <- reg arg
1698(0585): 2d 5c bc a0 '  mov RI, FP
169c(0586): 0c 5c fc 80 '  add RI, #12
16a0(0587): 2e 6c 3c 08 '  wrlong r3, RI ' spill reg
16a4(0588): 35 86 bc a0 '  mov r16, r2 ' reg var <- reg arg
16a8(0589): 00 7e fc a0 '  mov r12, #0 ' reg <- coni
16ac(058a): 0e 00 7c 5c '  jmp #JMPA
16b0(058b): 44 25 00 00 '  long @C__doprnt_65 ' JUMPV addrg
16b4(058c):             ' C__doprnt_64
16b4(058c): 2d 7c bc a0 '  mov r11, FP
16b8(058d): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
16bc(058e): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
16c0(058f): 25 7c 7c c2 '  cmps r11,  #37 wz
16c4(0590): 13 00 7c 5c '  jmp #BR_Z
16c8(0591): e8 16 00 00 '  long @C__doprnt_67 ' EQI4
16cc(0592): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
16d0(0593): 2d 5c bc a0 '  mov RI, FP
16d4(0594): 10 5c fc 84 '  sub RI, #-(-16)
16d8(0595): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRLi
16dc(0596): 08 5e fc a0 '  mov BC, #8 ' arg size
16e0(0597): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
16e4(0598): 0b 00 7c 5c '  jmp #CALA
16e8(0599): 2c 27 00 00 '  long @C_putc
16ec(059a): 08 58 fc 80 '  add SP, #8 ' CALL addrg
16f0(059b): 04 00 7c 5c '  jmp #LODA
16f4(059c): 70 28 00 00 '  long @C__doprnt_L000071
16f8(059d): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
16fc(059e): 3d 66 3c c2 '  cmps r0, r10 wz
1700(059f): 14 00 7c 5c '  jmp #BRNZ
1704(05a0): dc 16 00 00 '  long @C__doprnt_69 ' NEI4
1708(05a1): 00 7e 7c c2 '  cmps r12,  #0 wz
170c(05a2): 13 00 7c 5c '  jmp #BR_Z
1710(05a3): b0 16 00 00 '  long @C__doprnt_75 ' EQI4
1714(05a4): 3f 7c bc a4 '  neg r11, r12 ' NEGI4
1718(05a5): 05 00 7c 5c '  jmp #LODF
171c(05a6): d8 fb ff ff '  long -1064
1720(05a7): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1724(05a8): 0e 00 7c 5c '  jmp #JMPA
1728(05a9): c8 16 00 00 '  long @C__doprnt_76 ' JUMPV addrg
172c(05aa):             ' C__doprnt_75
172c(05aa): 04 00 7c 5c '  jmp #LODA
1730(05ab): 70 28 00 00 '  long @C__doprnt_L000071
1734(05ac): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1738(05ad): 05 00 7c 5c '  jmp #LODF
173c(05ae): d8 fb ff ff '  long -1064
1740(05af): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1744(05b0):             ' C__doprnt_76
1744(05b0): 05 00 7c 5c '  jmp #LODF
1748(05b1): d8 fb ff ff '  long -1064
174c(05b2): 2e 66 bc 08 '  rdlong r0, RI ' reg <- INDIRI4 addrl
1750(05b3): 0e 00 7c 5c '  jmp #JMPA
1754(05b4): 74 25 00 00 '  long @C__doprnt_63 ' JUMPV addrg
1758(05b5):             ' C__doprnt_69
1758(05b5): 01 7e fc d0 '  adds r12, #1 ' ADDI4 coni
175c(05b6): 0e 00 7c 5c '  jmp #JMPA
1760(05b7): 44 25 00 00 '  long @C__doprnt_65 ' JUMPV addrg
1764(05b8):             ' C__doprnt_67
1764(05b8): 00 80 fc a0 '  mov r13, #0 ' reg <- coni
1768(05b9):             ' C__doprnt_77
1768(05b9): 44 7c bc 00 '  rdbyte r11, r17 ' reg <- INDIRU1 reg
176c(05ba): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
1770(05bb): 05 00 7c 5c '  jmp #LODF
1774(05bc): d8 fb ff ff '  long -1064
1778(05bd): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
177c(05be): 05 00 7c 5c '  jmp #LODF
1780(05bf): d8 fb ff ff '  long -1064
1784(05c0): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
1788(05c1): 20 7a fc a0 '  mov r10, #32 ' reg <- coni
178c(05c2): 3d 7c 3c c2 '  cmps r11, r10 wz
1790(05c3): 13 00 7c 5c '  jmp #BR_Z
1794(05c4): 84 17 00 00 '  long @C__doprnt_85 ' EQI4
1798(05c5): 23 7c 7c c2 '  cmps r11,  #35 wz
179c(05c6): 13 00 7c 5c '  jmp #BR_Z
17a0(05c7): 90 17 00 00 '  long @C__doprnt_86 ' EQI4
17a4(05c8): 3d 7c 3c c3 '  cmps r11, r10 wz,wc
17a8(05c9): 18 00 7c 5c '  jmp #BR_B
17ac(05ca): a8 17 00 00 '  long @C__doprnt_80 ' LTI4
17b0(05cb): 05 00 7c 5c '  jmp #LODF
17b4(05cc): d8 fb ff ff '  long -1064
17b8(05cd): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
17bc(05ce): 2b 7c 7c c2 '  cmps r11,  #43 wz
17c0(05cf): 13 00 7c 5c '  jmp #BR_Z
17c4(05d0): 78 17 00 00 '  long @C__doprnt_84 ' EQI4
17c8(05d1): 2d 7c 7c c2 '  cmps r11,  #45 wz
17cc(05d2): 13 00 7c 5c '  jmp #BR_Z
17d0(05d3): 6c 17 00 00 '  long @C__doprnt_83 ' EQI4
17d4(05d4): 30 7c 7c c2 '  cmps r11,  #48 wz
17d8(05d5): 13 00 7c 5c '  jmp #BR_Z
17dc(05d6): 9c 17 00 00 '  long @C__doprnt_87 ' EQI4
17e0(05d7): 0e 00 7c 5c '  jmp #JMPA
17e4(05d8): a8 17 00 00 '  long @C__doprnt_80 ' JUMPV addrg
17e8(05d9):             ' C__doprnt_83
17e8(05d9): 01 80 fc 68 '  or r13, #1 ' BORI4 coni
17ec(05da): 0e 00 7c 5c '  jmp #JMPA
17f0(05db): c0 17 00 00 '  long @C__doprnt_81 ' JUMPV addrg
17f4(05dc):             ' C__doprnt_84
17f4(05dc): 02 80 fc 68 '  or r13, #2 ' BORI4 coni
17f8(05dd): 0e 00 7c 5c '  jmp #JMPA
17fc(05de): c0 17 00 00 '  long @C__doprnt_81 ' JUMPV addrg
1800(05df):             ' C__doprnt_85
1800(05df): 04 80 fc 68 '  or r13, #4 ' BORI4 coni
1804(05e0): 0e 00 7c 5c '  jmp #JMPA
1808(05e1): c0 17 00 00 '  long @C__doprnt_81 ' JUMPV addrg
180c(05e2):             ' C__doprnt_86
180c(05e2): 08 80 fc 68 '  or r13, #8 ' BORI4 coni
1810(05e3): 0e 00 7c 5c '  jmp #JMPA
1814(05e4): c0 17 00 00 '  long @C__doprnt_81 ' JUMPV addrg
1818(05e5):             ' C__doprnt_87
1818(05e5): 10 80 fc 68 '  or r13, #16 ' BORI4 coni
181c(05e6): 0e 00 7c 5c '  jmp #JMPA
1820(05e7): c0 17 00 00 '  long @C__doprnt_81 ' JUMPV addrg
1824(05e8):             ' C__doprnt_80
1824(05e8): 04 00 7c 5c '  jmp #LODA
1828(05e9): 6c 28 00 00 '  long @C__doprnt_L000088
182c(05ea): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1830(05eb): 3e 80 bc 68 '  or r13, r11 ' BORI/U (1)
1834(05ec): 0e 00 7c 5c '  jmp #JMPA
1838(05ed): c4 17 00 00 '  long @C__doprnt_78 ' JUMPV addrg
183c(05ee):             ' C__doprnt_81
183c(05ee): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1840(05ef):             ' C__doprnt_78
1840(05ef): 04 00 7c 5c '  jmp #LODA
1844(05f0): 6c 28 00 00 '  long @C__doprnt_L000088
1848(05f1): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
184c(05f2): 40 7c bc 60 '  and r11, r13 ' BANDI/U (2)
1850(05f3): 00 7c 7c c2 '  cmps r11,  #0 wz
1854(05f4): 13 00 7c 5c '  jmp #BR_Z
1858(05f5): ec 16 00 00 '  long @C__doprnt_77 ' EQI4
185c(05f6): 05 00 7c 5c '  jmp #LODF
1860(05f7): e4 ff ff ff '  long -28
1864(05f8): 2e 88 3c 08 '  wrlong r17, RI ' ASGNP4 addrl
1868(05f9): 2d 6a bc a0 '  mov r2, FP
186c(05fa): 0c 6a fc 80 '  add r2, #12 ' reg ARG ADDRFi
1870(05fb): 2d 6c bc a0 '  mov r3, FP
1874(05fc): 14 6c fc 84 '  sub r3, #-(-20) ' reg ARG ADDRLi
1878(05fd): 44 6e bc a0 '  mov r4, r17 ' CVI, CVU or LOAD
187c(05fe): 0c 5e fc a0 '  mov BC, #12 ' arg size
1880(05ff): 0c 58 fc 84 '  sub SP, #12 ' stack space for reg ARGs
1884(0600): 0b 00 7c 5c '  jmp #CALA
1888(0601): 38 0f 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001
188c(0602): 0c 58 fc 80 '  add SP, #12 ' CALL addrg
1890(0603): 33 88 bc a0 '  mov r17, r0 ' CVI, CVU or LOAD
1894(0604): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
1898(0605): 2d 7a bc a0 '  mov r10, FP
189c(0606): 1c 7a fc 84 '  sub r10, #-(-28) ' reg <- addrli
18a0(0607): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRP4 reg
18a4(0608): 3d 7c 3c 86 '  cmp r11, r10 wz
18a8(0609): 13 00 7c 5c '  jmp #BR_Z
18ac(060a): 38 18 00 00 '  long @C__doprnt_92 ' EQU4
18b0(060b): 00 81 fc 68 '  or r13, #256 ' BORI4 coni
18b4(060c):             ' C__doprnt_92
18b4(060c): 44 7c bc 00 '  rdbyte r11, r17 ' reg <- INDIRU1 reg
18b8(060d): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
18bc(060e): 2e 7c 7c c2 '  cmps r11,  #46 wz
18c0(060f): 14 00 7c 5c '  jmp #BRNZ
18c4(0610): b0 18 00 00 '  long @C__doprnt_94 ' NEI4
18c8(0611): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
18cc(0612): 05 00 7c 5c '  jmp #LODF
18d0(0613): e4 ff ff ff '  long -28
18d4(0614): 2e 88 3c 08 '  wrlong r17, RI ' ASGNP4 addrl
18d8(0615): 2d 6a bc a0 '  mov r2, FP
18dc(0616): 0c 6a fc 80 '  add r2, #12 ' reg ARG ADDRFi
18e0(0617): 2d 6c bc a0 '  mov r3, FP
18e4(0618): 18 6c fc 84 '  sub r3, #-(-24) ' reg ARG ADDRLi
18e8(0619): 44 6e bc a0 '  mov r4, r17 ' CVI, CVU or LOAD
18ec(061a): 0c 5e fc a0 '  mov BC, #12 ' arg size
18f0(061b): 0c 58 fc 84 '  sub SP, #12 ' stack space for reg ARGs
18f4(061c): 0b 00 7c 5c '  jmp #CALA
18f8(061d): 38 0f 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001
18fc(061e): 0c 58 fc 80 '  add SP, #12 ' CALL addrg
1900(061f): 33 88 bc a0 '  mov r17, r0 ' CVI, CVU or LOAD
1904(0620): 2d 7c bc a0 '  mov r11, FP
1908(0621): 18 7c fc 84 '  sub r11, #-(-24) ' reg <- addrli
190c(0622): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1910(0623): 00 7c 7c c3 '  cmps r11,  #0 wz,wc
1914(0624): 18 00 7c 5c '  jmp #BR_B
1918(0625): b0 18 00 00 '  long @C__doprnt_96 ' LTI4
191c(0626): 04 00 7c 5c '  jmp #LODA
1920(0627): 68 28 00 00 '  long @C__doprnt_L000098
1924(0628): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1928(0629): 3e 80 bc 68 '  or r13, r11 ' BORI/U (1)
192c(062a):             ' C__doprnt_96
192c(062a):             ' C__doprnt_94
192c(062a): 00 7c fc a0 '  mov r11, #0 ' reg <- coni
1930(062b): 40 7a bc a0 '  mov r10, r13
1934(062c): 00 7b fc 60 '  and r10, #256 ' BANDI4 coni
1938(062d): 3e 7a 3c c2 '  cmps r10, r11 wz
193c(062e): 13 00 7c 5c '  jmp #BR_Z
1940(062f): 00 19 00 00 '  long @C__doprnt_101 ' EQI4
1944(0630): 2d 7a bc a0 '  mov r10, FP
1948(0631): 14 7a fc 84 '  sub r10, #-(-20) ' reg <- addrli
194c(0632): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRI4 reg
1950(0633): 3e 7a 3c c3 '  cmps r10, r11 wz,wc
1954(0634): 15 00 7c 5c '  jmp #BRAE
1958(0635): 00 19 00 00 '  long @C__doprnt_101 ' GEI4
195c(0636): 2d 7c bc a0 '  mov r11, FP
1960(0637): 14 7c fc 84 '  sub r11, #-(-20) ' reg <- addrli
1964(0638): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1968(0639): 3e 7c bc a4 '  neg r11, r11 ' NEGI4
196c(063a): 05 00 7c 5c '  jmp #LODF
1970(063b): ec ff ff ff '  long -20
1974(063c): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1978(063d): 01 80 fc 68 '  or r13, #1 ' BORI4 coni
197c(063e):             ' C__doprnt_101
197c(063e): 40 7c bc a0 '  mov r11, r13
1980(063f): 00 7d fc 60 '  and r11, #256 ' BANDI4 coni
1984(0640): 00 7c 7c c2 '  cmps r11,  #0 wz
1988(0641): 14 00 7c 5c '  jmp #BRNZ
198c(0642): 24 19 00 00 '  long @C__doprnt_103 ' NEI4
1990(0643): 00 7c fc a0 '  mov r11, #0 ' reg <- coni
1994(0644): 05 00 7c 5c '  jmp #LODF
1998(0645): ec ff ff ff '  long -20
199c(0646): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
19a0(0647):             ' C__doprnt_103
19a0(0647): 40 7c bc a0 '  mov r11, r13
19a4(0648): 02 7c fc 60 '  and r11, #2 ' BANDI4 coni
19a8(0649): 00 7c 7c c2 '  cmps r11,  #0 wz
19ac(064a): 13 00 7c 5c '  jmp #BR_Z
19b0(064b): 48 19 00 00 '  long @C__doprnt_105 ' EQI4
19b4(064c): 04 00 7c 5c '  jmp #LODA
19b8(064d): 64 28 00 00 '  long @C__doprnt_L000107
19bc(064e): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
19c0(064f): 3e 80 bc 60 '  and r13, r11 ' BANDI/U (1)
19c4(0650):             ' C__doprnt_105
19c4(0650): 40 7c bc a0 '  mov r11, r13
19c8(0651): 01 7c fc 60 '  and r11, #1 ' BANDI4 coni
19cc(0652): 00 7c 7c c2 '  cmps r11,  #0 wz
19d0(0653): 13 00 7c 5c '  jmp #BR_Z
19d4(0654): 6c 19 00 00 '  long @C__doprnt_110 ' EQI4
19d8(0655): 04 00 7c 5c '  jmp #LODA
19dc(0656): 60 28 00 00 '  long @C__doprnt_L000112
19e0(0657): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
19e4(0658): 3e 80 bc 60 '  and r13, r11 ' BANDI/U (1)
19e8(0659):             ' C__doprnt_110
19e8(0659): 05 00 7c 5c '  jmp #LODF
19ec(065a): dc fb ff ff '  long -1060
19f0(065b): 2e 7c bc a0 '  mov r11, RI ' reg <- addrl
19f4(065c): 05 00 7c 5c '  jmp #LODF
19f8(065d): fc ff ff ff '  long -4
19fc(065e): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
1a00(065f): 05 00 7c 5c '  jmp #LODF
1a04(0660): dc fb ff ff '  long -1060
1a08(0661): 2e 84 bc a0 '  mov r15, RI ' reg <- addrl
1a0c(0662): 44 7c bc 00 '  rdbyte r11, r17 ' reg <- INDIRU1 reg
1a10(0663): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
1a14(0664): 05 00 7c 5c '  jmp #LODF
1a18(0665): d8 fb ff ff '  long -1064
1a1c(0666): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1a20(0667): 05 00 7c 5c '  jmp #LODF
1a24(0668): d8 fb ff ff '  long -1064
1a28(0669): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
1a2c(066a): 68 7a fc a0 '  mov r10, #104 ' reg <- coni
1a30(066b): 3d 7c 3c c2 '  cmps r11, r10 wz
1a34(066c): 13 00 7c 5c '  jmp #BR_Z
1a38(066d): 0c 1a 00 00 '  long @C__doprnt_118 ' EQI4
1a3c(066e): 3d 7c 3c c3 '  cmps r11, r10 wz,wc
1a40(066f): 16 00 7c 5c '  jmp #BR_A
1a44(0670): ec 19 00 00 '  long @C__doprnt_122 ' GTI4
1a48(0671): 05 00 7c 5c '  jmp #LODF
1a4c(0672): d8 fb ff ff '  long -1064
1a50(0673): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
1a54(0674): 4c 7c 7c c2 '  cmps r11,  #76 wz
1a58(0675): 13 00 7c 5c '  jmp #BR_Z
1a5c(0676): 2c 1a 00 00 '  long @C__doprnt_120 ' EQI4
1a60(0677): 0e 00 7c 5c '  jmp #JMPA
1a64(0678): 34 1a 00 00 '  long @C__doprnt_115 ' JUMPV addrg
1a68(0679):             ' C__doprnt_122
1a68(0679): 05 00 7c 5c '  jmp #LODF
1a6c(067a): d8 fb ff ff '  long -1064
1a70(067b): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
1a74(067c): 6c 7c 7c c2 '  cmps r11,  #108 wz
1a78(067d): 13 00 7c 5c '  jmp #BR_Z
1a7c(067e): 1c 1a 00 00 '  long @C__doprnt_119 ' EQI4
1a80(067f): 0e 00 7c 5c '  jmp #JMPA
1a84(0680): 34 1a 00 00 '  long @C__doprnt_115 ' JUMPV addrg
1a88(0681):             ' C__doprnt_118
1a88(0681): 20 80 fc 68 '  or r13, #32 ' BORI4 coni
1a8c(0682): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1a90(0683): 0e 00 7c 5c '  jmp #JMPA
1a94(0684): 34 1a 00 00 '  long @C__doprnt_116 ' JUMPV addrg
1a98(0685):             ' C__doprnt_119
1a98(0685): 40 80 fc 68 '  or r13, #64 ' BORI4 coni
1a9c(0686): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1aa0(0687): 0e 00 7c 5c '  jmp #JMPA
1aa4(0688): 34 1a 00 00 '  long @C__doprnt_116 ' JUMPV addrg
1aa8(0689):             ' C__doprnt_120
1aa8(0689): 80 80 fc 68 '  or r13, #128 ' BORI4 coni
1aac(068a): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1ab0(068b):             ' C__doprnt_115
1ab0(068b):             ' C__doprnt_116
1ab0(068b): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
1ab4(068c): 3e 88 bc a0 '  mov r17, r11
1ab8(068d): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1abc(068e): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
1ac0(068f): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
1ac4(0690): 05 00 7c 5c '  jmp #LODF
1ac8(0691): f0 ff ff ff '  long -16
1acc(0692): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1ad0(0693): 05 00 7c 5c '  jmp #LODF
1ad4(0694): d4 fb ff ff '  long -1068
1ad8(0695): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1adc(0696): 05 00 7c 5c '  jmp #LODF
1ae0(0697): d4 fb ff ff '  long -1068
1ae4(0698): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
1ae8(0699): 62 7c 7c c3 '  cmps r11,  #98 wz,wc
1aec(069a): 18 00 7c 5c '  jmp #BR_B
1af0(069b): a0 1a 00 00 '  long @C__doprnt_160 ' LTI4
1af4(069c): 75 7c 7c c3 '  cmps r11,  #117 wz,wc
1af8(069d): 16 00 7c 5c '  jmp #BR_A
1afc(069e): c0 1a 00 00 '  long @C__doprnt_161 ' GTI4
1b00(069f): 02 7c fc 2c '  shl r11, #2 ' LSHI4 coni
1b04(06a0): 04 00 7c 5c '  jmp #LODA
1b08(06a1): 7c 26 00 00 '  long @C__doprnt_162_L000164-392
1b0c(06a2): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
1b10(06a3): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
1b14(06a4): 3e 5c bc 08 '  rdlong RI, r11
1b18(06a5): 0f 00 7c 5c '  jmp #JMPI ' JUMPV INDIR reg
1b1c(06a6):             ' C__doprnt_160
1b1c(06a6): 05 00 7c 5c '  jmp #LODF
1b20(06a7): d4 fb ff ff '  long -1068
1b24(06a8): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
1b28(06a9): 58 7c 7c c2 '  cmps r11,  #88 wz
1b2c(06aa): 13 00 7c 5c '  jmp #BR_Z
1b30(06ab): 50 1d 00 00 '  long @C__doprnt_147 ' EQI4
1b34(06ac): 0e 00 7c 5c '  jmp #JMPA
1b38(06ad): e0 1a 00 00 '  long @C__doprnt_123 ' JUMPV addrg
1b3c(06ae):             ' C__doprnt_161
1b3c(06ae): 05 00 7c 5c '  jmp #LODF
1b40(06af): d4 fb ff ff '  long -1068
1b44(06b0): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
1b48(06b1): 78 7c 7c c2 '  cmps r11,  #120 wz
1b4c(06b2): 13 00 7c 5c '  jmp #BR_Z
1b50(06b3): 50 1d 00 00 '  long @C__doprnt_147 ' EQI4
1b54(06b4): 0e 00 7c 5c '  jmp #JMPA
1b58(06b5): e0 1a 00 00 '  long @C__doprnt_123 ' JUMPV addrg
1b5c(06b6):             ' C__doprnt_123
1b5c(06b6): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
1b60(06b7): 2d 5c bc a0 '  mov RI, FP
1b64(06b8): 10 5c fc 84 '  sub RI, #-(-16)
1b68(06b9): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRLi
1b6c(06ba): 08 5e fc a0 '  mov BC, #8 ' arg size
1b70(06bb): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
1b74(06bc): 0b 00 7c 5c '  jmp #CALA
1b78(06bd): 2c 27 00 00 '  long @C_putc
1b7c(06be): 08 58 fc 80 '  add SP, #8 ' CALL addrg
1b80(06bf): 04 00 7c 5c '  jmp #LODA
1b84(06c0): 70 28 00 00 '  long @C__doprnt_L000071
1b88(06c1): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
1b8c(06c2): 3d 66 3c c2 '  cmps r0, r10 wz
1b90(06c3): 14 00 7c 5c '  jmp #BRNZ
1b94(06c4): 6c 1b 00 00 '  long @C__doprnt_126 ' NEI4
1b98(06c5): 00 7e 7c c2 '  cmps r12,  #0 wz
1b9c(06c6): 13 00 7c 5c '  jmp #BR_Z
1ba0(06c7): 40 1b 00 00 '  long @C__doprnt_129 ' EQI4
1ba4(06c8): 3f 7c bc a4 '  neg r11, r12 ' NEGI4
1ba8(06c9): 05 00 7c 5c '  jmp #LODF
1bac(06ca): d0 fb ff ff '  long -1072
1bb0(06cb): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1bb4(06cc): 0e 00 7c 5c '  jmp #JMPA
1bb8(06cd): 58 1b 00 00 '  long @C__doprnt_130 ' JUMPV addrg
1bbc(06ce):             ' C__doprnt_129
1bbc(06ce): 04 00 7c 5c '  jmp #LODA
1bc0(06cf): 70 28 00 00 '  long @C__doprnt_L000071
1bc4(06d0): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1bc8(06d1): 05 00 7c 5c '  jmp #LODF
1bcc(06d2): d0 fb ff ff '  long -1072
1bd0(06d3): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1bd4(06d4):             ' C__doprnt_130
1bd4(06d4): 05 00 7c 5c '  jmp #LODF
1bd8(06d5): d0 fb ff ff '  long -1072
1bdc(06d6): 2e 66 bc 08 '  rdlong r0, RI ' reg <- INDIRI4 addrl
1be0(06d7): 0e 00 7c 5c '  jmp #JMPA
1be4(06d8): 74 25 00 00 '  long @C__doprnt_63 ' JUMPV addrg
1be8(06d9):             ' C__doprnt_126
1be8(06d9): 01 7e fc d0 '  adds r12, #1 ' ADDI4 coni
1bec(06da): 0e 00 7c 5c '  jmp #JMPA
1bf0(06db): 44 25 00 00 '  long @C__doprnt_65 ' JUMPV addrg
1bf4(06dc):             ' C__doprnt_131
1bf4(06dc): 40 7c bc a0 '  mov r11, r13
1bf8(06dd): 20 7c fc 60 '  and r11, #32 ' BANDI4 coni
1bfc(06de): 00 7c 7c c2 '  cmps r11,  #0 wz
1c00(06df): 13 00 7c 5c '  jmp #BR_Z
1c04(06e0): cc 1b 00 00 '  long @C__doprnt_132 ' EQI4
1c08(06e1): 2d 7c bc a0 '  mov r11, FP
1c0c(06e2): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
1c10(06e3): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1c14(06e4): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
1c18(06e5): 05 00 7c 5c '  jmp #LODF
1c1c(06e6): 0c 00 00 00 '  long 12
1c20(06e7): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
1c24(06e8): 04 00 7c 5c '  jmp #LODA
1c28(06e9): 74 28 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
1c2c(06ea): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
1c30(06eb): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
1c34(06ec): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1c38(06ed): 3f 7a bc a0 '  mov r10, r12 ' CVI, CVU or LOAD
1c3c(06ee): 3e 7a 3c 04 '  wrword r10, r11 ' ASGNI2 reg
1c40(06ef): 0e 00 7c 5c '  jmp #JMPA
1c44(06f0): 44 25 00 00 '  long @C__doprnt_65 ' JUMPV addrg
1c48(06f1):             ' C__doprnt_132
1c48(06f1): 40 7c bc a0 '  mov r11, r13
1c4c(06f2): 40 7c fc 60 '  and r11, #64 ' BANDI4 coni
1c50(06f3): 00 7c 7c c2 '  cmps r11,  #0 wz
1c54(06f4): 13 00 7c 5c '  jmp #BR_Z
1c58(06f5): 1c 1c 00 00 '  long @C__doprnt_134 ' EQI4
1c5c(06f6): 2d 7c bc a0 '  mov r11, FP
1c60(06f7): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
1c64(06f8): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1c68(06f9): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
1c6c(06fa): 05 00 7c 5c '  jmp #LODF
1c70(06fb): 0c 00 00 00 '  long 12
1c74(06fc): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
1c78(06fd): 04 00 7c 5c '  jmp #LODA
1c7c(06fe): 74 28 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
1c80(06ff): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
1c84(0700): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
1c88(0701): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1c8c(0702): 3e 7e 3c 08 '  wrlong r12, r11 ' ASGNI4 reg
1c90(0703): 0e 00 7c 5c '  jmp #JMPA
1c94(0704): 44 25 00 00 '  long @C__doprnt_65 ' JUMPV addrg
1c98(0705):             ' C__doprnt_134
1c98(0705): 2d 7c bc a0 '  mov r11, FP
1c9c(0706): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
1ca0(0707): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1ca4(0708): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
1ca8(0709): 05 00 7c 5c '  jmp #LODF
1cac(070a): 0c 00 00 00 '  long 12
1cb0(070b): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
1cb4(070c): 04 00 7c 5c '  jmp #LODA
1cb8(070d): 74 28 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
1cbc(070e): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
1cc0(070f): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
1cc4(0710): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1cc8(0711): 3e 7e 3c 08 '  wrlong r12, r11 ' ASGNI4 reg
1ccc(0712): 0e 00 7c 5c '  jmp #JMPA
1cd0(0713): 44 25 00 00 '  long @C__doprnt_65 ' JUMPV addrg
1cd4(0714):             ' C__doprnt_136
1cd4(0714): 2d 7c bc a0 '  mov r11, FP
1cd8(0715): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
1cdc(0716): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1ce0(0717): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
1ce4(0718): 05 00 7c 5c '  jmp #LODF
1ce8(0719): 0c 00 00 00 '  long 12
1cec(071a): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
1cf0(071b): 04 00 7c 5c '  jmp #LODA
1cf4(071c): 74 28 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
1cf8(071d): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
1cfc(071e): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
1d00(071f): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1d04(0720): 05 00 7c 5c '  jmp #LODF
1d08(0721): fc ff ff ff '  long -4
1d0c(0722): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
1d10(0723): 2d 7c bc a0 '  mov r11, FP
1d14(0724): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
1d18(0725): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1d1c(0726): 00 7c 7c 86 '  cmp r11,  #0 wz
1d20(0727): 14 00 7c 5c '  jmp #BRNZ
1d24(0728): c0 1c 00 00 '  long @C__doprnt_137 ' NEU4
1d28(0729): 04 00 7c 5c '  jmp #LODA
1d2c(072a): 58 28 00 00 '  long @C__doprnt_139_L000140
1d30(072b): 2d 5e bc a0 '  mov BC, FP
1d34(072c): 04 5e fc 84 '  sub BC, #-(-4)
1d38(072d): 2f 5c 3c 08 '  wrlong RI, BC ' ASGNP4 addrli addrg
1d3c(072e):             ' C__doprnt_137
1d3c(072e): 2d 7c bc a0 '  mov r11, FP
1d40(072f): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
1d44(0730): 3e 84 bc 08 '  rdlong r15, r11 ' reg <- INDIRP4 reg
1d48(0731): 0e 00 7c 5c '  jmp #JMPA
1d4c(0732): 10 1d 00 00 '  long @C__doprnt_142 ' JUMPV addrg
1d50(0733):             ' C__doprnt_141
1d50(0733): 42 7c bc 00 '  rdbyte r11, r15 ' reg <- INDIRU1 reg
1d54(0734): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
1d58(0735): 00 7c 7c c2 '  cmps r11,  #0 wz
1d5c(0736): 14 00 7c 5c '  jmp #BRNZ
1d60(0737): f0 1c 00 00 '  long @C__doprnt_144 ' NEI4
1d64(0738): 0e 00 7c 5c '  jmp #JMPA
1d68(0739): 68 1f 00 00 '  long @C__doprnt_124 ' JUMPV addrg
1d6c(073a):             ' C__doprnt_144
1d6c(073a): 01 84 fc d0 '  adds r15, #1 ' ADDP4 coni
1d70(073b): 2d 7c bc a0 '  mov r11, FP
1d74(073c): 18 7c fc 84 '  sub r11, #-(-24) ' reg <- addrli
1d78(073d): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1d7c(073e): 01 7c fc d4 '  subs r11, #1 ' SUBI4 coni
1d80(073f): 05 00 7c 5c '  jmp #LODF
1d84(0740): e8 ff ff ff '  long -24
1d88(0741): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1d8c(0742):             ' C__doprnt_142
1d8c(0742): 00 7c fc a0 '  mov r11, #0 ' reg <- coni
1d90(0743): 2d 7a bc a0 '  mov r10, FP
1d94(0744): 18 7a fc 84 '  sub r10, #-(-24) ' reg <- addrli
1d98(0745): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRI4 reg
1d9c(0746): 3e 7a 3c c2 '  cmps r10, r11 wz
1da0(0747): 14 00 7c 5c '  jmp #BRNZ
1da4(0748): d4 1c 00 00 '  long @C__doprnt_141 ' NEI4
1da8(0749): 04 00 7c 5c '  jmp #LODA
1dac(074a): 68 28 00 00 '  long @C__doprnt_L000098
1db0(074b): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
1db4(074c): 40 7a bc 60 '  and r10, r13 ' BANDI/U (2)
1db8(074d): 3e 7a 3c c2 '  cmps r10, r11 wz
1dbc(074e): 13 00 7c 5c '  jmp #BR_Z
1dc0(074f): d4 1c 00 00 '  long @C__doprnt_141 ' EQI4
1dc4(0750): 0e 00 7c 5c '  jmp #JMPA
1dc8(0751): 68 1f 00 00 '  long @C__doprnt_124 ' JUMPV addrg
1dcc(0752):             ' C__doprnt_146
1dcc(0752):             ' C__doprnt_147
1dcc(0752): 04 00 7c 5c '  jmp #LODA
1dd0(0753): 68 28 00 00 '  long @C__doprnt_L000098
1dd4(0754): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1dd8(0755): 40 7c bc 60 '  and r11, r13 ' BANDI/U (2)
1ddc(0756): 00 7c 7c c2 '  cmps r11,  #0 wz
1de0(0757): 14 00 7c 5c '  jmp #BRNZ
1de4(0758): 84 1d 00 00 '  long @C__doprnt_148 ' NEI4
1de8(0759): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
1dec(075a): 05 00 7c 5c '  jmp #LODF
1df0(075b): e8 ff ff ff '  long -24
1df4(075c): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1df8(075d): 0e 00 7c 5c '  jmp #JMPA
1dfc(075e): ac 1d 00 00 '  long @C__doprnt_149 ' JUMPV addrg
1e00(075f):             ' C__doprnt_148
1e00(075f): 2d 7c bc a0 '  mov r11, FP
1e04(0760): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
1e08(0761): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1e0c(0762): 70 7c 7c c2 '  cmps r11,  #112 wz
1e10(0763): 13 00 7c 5c '  jmp #BR_Z
1e14(0764): ac 1d 00 00 '  long @C__doprnt_150 ' EQI4
1e18(0765): 04 00 7c 5c '  jmp #LODA
1e1c(0766): 60 28 00 00 '  long @C__doprnt_L000112
1e20(0767): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1e24(0768): 3e 80 bc 60 '  and r13, r11 ' BANDI/U (1)
1e28(0769):             ' C__doprnt_150
1e28(0769):             ' C__doprnt_149
1e28(0769): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
1e2c(076a): 2d 5c bc a0 '  mov RI, FP
1e30(076b): 18 5c fc 84 '  sub RI, #-(-24)
1e34(076c): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRLi
1e38(076d): 2d 7c bc a0 '  mov r11, FP
1e3c(076e): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
1e40(076f): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1e44(0770): 3e 6e bc a0 '  mov r4, r11 ' CVUI
1e48(0771): 4d 6e bc 60 '  and r4, cviu_m1 ' zero extend
1e4c(0772): 42 70 bc a0 '  mov r5, r15 ' CVI, CVU or LOAD
1e50(0773): 10 58 fc 84 '  sub SP, #16 ' stack space for reg ARGs
1e54(0774): 40 5c bc a0 '  mov RI, r13
1e58(0775): 06 00 7c 5c '  jmp #PSHL ' stack ARG
1e5c(0776): 2d 5c bc a0 '  mov RI, FP
1e60(0777): 0c 5c fc 80 '  add RI, #12
1e64(0778): 06 00 7c 5c '  jmp #PSHL ' stack ARG ADDRFi
1e68(0779): 18 5e fc a0 '  mov BC, #24 ' arg size
1e6c(077a): 0b 00 7c 5c '  jmp #CALA
1e70(077b): f4 0f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012
1e74(077c): 18 58 fc 80 '  add SP, #24 ' CALL addrg
1e78(077d): 33 84 bc a0 '  mov r15, r0 ' CVI, CVU or LOAD
1e7c(077e): 0e 00 7c 5c '  jmp #JMPA
1e80(077f): 68 1f 00 00 '  long @C__doprnt_124 ' JUMPV addrg
1e84(0780):             ' C__doprnt_152
1e84(0780): 04 00 7c 5c '  jmp #LODA
1e88(0781): 54 28 00 00 '  long @C__doprnt_L000153
1e8c(0782): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1e90(0783): 3e 80 bc 68 '  or r13, r11 ' BORI/U (1)
1e94(0784): 04 00 7c 5c '  jmp #LODA
1e98(0785): 68 28 00 00 '  long @C__doprnt_L000098
1e9c(0786): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1ea0(0787): 40 7c bc 60 '  and r11, r13 ' BANDI/U (2)
1ea4(0788): 00 7c 7c c2 '  cmps r11,  #0 wz
1ea8(0789): 14 00 7c 5c '  jmp #BRNZ
1eac(078a): 4c 1e 00 00 '  long @C__doprnt_156 ' NEI4
1eb0(078b): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
1eb4(078c): 05 00 7c 5c '  jmp #LODF
1eb8(078d): e8 ff ff ff '  long -24
1ebc(078e): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1ec0(078f): 0e 00 7c 5c '  jmp #JMPA
1ec4(0790): 5c 1e 00 00 '  long @C__doprnt_157 ' JUMPV addrg
1ec8(0791):             ' C__doprnt_156
1ec8(0791): 04 00 7c 5c '  jmp #LODA
1ecc(0792): 60 28 00 00 '  long @C__doprnt_L000112
1ed0(0793): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1ed4(0794): 3e 80 bc 60 '  and r13, r11 ' BANDI/U (1)
1ed8(0795):             ' C__doprnt_157
1ed8(0795): 01 6a fc a0 '  mov r2, #1 ' reg ARG coni
1edc(0796): 2d 5c bc a0 '  mov RI, FP
1ee0(0797): 18 5c fc 84 '  sub RI, #-(-24)
1ee4(0798): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRLi
1ee8(0799): 2d 7c bc a0 '  mov r11, FP
1eec(079a): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
1ef0(079b): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1ef4(079c): 3e 6e bc a0 '  mov r4, r11 ' CVUI
1ef8(079d): 4d 6e bc 60 '  and r4, cviu_m1 ' zero extend
1efc(079e): 42 70 bc a0 '  mov r5, r15 ' CVI, CVU or LOAD
1f00(079f): 10 58 fc 84 '  sub SP, #16 ' stack space for reg ARGs
1f04(07a0): 40 5c bc a0 '  mov RI, r13
1f08(07a1): 06 00 7c 5c '  jmp #PSHL ' stack ARG
1f0c(07a2): 2d 5c bc a0 '  mov RI, FP
1f10(07a3): 0c 5c fc 80 '  add RI, #12
1f14(07a4): 06 00 7c 5c '  jmp #PSHL ' stack ARG ADDRFi
1f18(07a5): 18 5e fc a0 '  mov BC, #24 ' arg size
1f1c(07a6): 0b 00 7c 5c '  jmp #CALA
1f20(07a7): f4 0f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012
1f24(07a8): 18 58 fc 80 '  add SP, #24 ' CALL addrg
1f28(07a9): 33 84 bc a0 '  mov r15, r0 ' CVI, CVU or LOAD
1f2c(07aa): 0e 00 7c 5c '  jmp #JMPA
1f30(07ab): 68 1f 00 00 '  long @C__doprnt_124 ' JUMPV addrg
1f34(07ac):             ' C__doprnt_158
1f34(07ac): 42 7c bc a0 '  mov r11, r15 ' CVI, CVU or LOAD
1f38(07ad): 3e 84 bc a0 '  mov r15, r11
1f3c(07ae): 01 84 fc d0 '  adds r15, #1 ' ADDP4 coni
1f40(07af): 2d 7a bc a0 '  mov r10, FP
1f44(07b0): 0c 7a fc 80 '  add r10, #12 ' reg <- addrfi
1f48(07b1): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRP4 reg
1f4c(07b2): 04 7a fc d0 '  adds r10, #4 ' ADDP4 coni
1f50(07b3): 05 00 7c 5c '  jmp #LODF
1f54(07b4): 0c 00 00 00 '  long 12
1f58(07b5): 2e 7a 3c 08 '  wrlong r10, RI ' ASGNP4 addrl
1f5c(07b6): 04 00 7c 5c '  jmp #LODA
1f60(07b7): 74 28 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
1f64(07b8): 2e 78 bc 08 '  rdlong  r9, RI ' reg <- con
1f68(07b9): 3c 7a bc d0 '  adds r10, r9 ' ADDI/P (1)
1f6c(07ba): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRI4 reg
1f70(07bb): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
1f74(07bc): 0e 00 7c 5c '  jmp #JMPA
1f78(07bd): 68 1f 00 00 '  long @C__doprnt_124 ' JUMPV addrg
1f7c(07be):             ' C__doprnt_159
1f7c(07be): 2d 7c bc a0 '  mov r11, FP
1f80(07bf): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
1f84(07c0): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1f88(07c1): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
1f8c(07c2): 05 00 7c 5c '  jmp #LODF
1f90(07c3): 0c 00 00 00 '  long 12
1f94(07c4): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
1f98(07c5): 04 00 7c 5c '  jmp #LODA
1f9c(07c6): 74 28 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
1fa0(07c7): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
1fa4(07c8): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
1fa8(07c9): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1fac(07ca): 05 00 7c 5c '  jmp #LODF
1fb0(07cb): 0c 00 00 00 '  long 12
1fb4(07cc): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
1fb8(07cd): 2d 7c bc a0 '  mov r11, FP
1fbc(07ce): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
1fc0(07cf): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1fc4(07d0): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
1fc8(07d1): 05 00 7c 5c '  jmp #LODF
1fcc(07d2): 0c 00 00 00 '  long 12
1fd0(07d3): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
1fd4(07d4): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
1fd8(07d5): 3e 88 bc 08 '  rdlong r17, r11 ' reg <- INDIRP4 reg
1fdc(07d6): 0e 00 7c 5c '  jmp #JMPA
1fe0(07d7): 44 25 00 00 '  long @C__doprnt_65 ' JUMPV addrg
1fe4(07d8):             ' C__doprnt_124
1fe4(07d8): 20 7c fc a0 '  mov r11, #32 ' reg <- coni
1fe8(07d9): 05 00 7c 5c '  jmp #LODF
1fec(07da): f4 ff ff ff '  long -12
1ff0(07db): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1ff4(07dc): 40 7c bc a0 '  mov r11, r13
1ff8(07dd): 10 7c fc 60 '  and r11, #16 ' BANDI4 coni
1ffc(07de): 00 7c 7c c2 '  cmps r11,  #0 wz
2000(07df): 13 00 7c 5c '  jmp #BR_Z
2004(07e0): 9c 1f 00 00 '  long @C__doprnt_166 ' EQI4
2008(07e1): 30 7c fc a0 '  mov r11, #48 ' reg <- coni
200c(07e2): 05 00 7c 5c '  jmp #LODF
2010(07e3): f4 ff ff ff '  long -12
2014(07e4): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2018(07e5):             ' C__doprnt_166
2018(07e5): 42 7c bc a0 '  mov r11, r15 ' CVI, CVU or LOAD
201c(07e6): 2d 7a bc a0 '  mov r10, FP
2020(07e7): 04 7a fc 84 '  sub r10, #-(-4) ' reg <- addrli
2024(07e8): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRP4 reg
2028(07e9): 3d 7c bc 84 '  sub r11, r10 ' SUBU (1)
202c(07ea): 3e 82 bc a0 '  mov r14, r11 ' CVI, CVU or LOAD
2030(07eb): 00 7c fc a0 '  mov r11, #0 ' reg <- coni
2034(07ec): 05 00 7c 5c '  jmp #LODF
2038(07ed): e0 ff ff ff '  long -32
203c(07ee): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2040(07ef): 40 7c bc a0 '  mov r11, r13
2044(07f0): 10 7c fc 60 '  and r11, #16 ' BANDI4 coni
2048(07f1): 00 7c 7c c2 '  cmps r11,  #0 wz
204c(07f2): 13 00 7c 5c '  jmp #BR_Z
2050(07f3): 98 20 00 00 '  long @C__doprnt_168 ' EQI4
2054(07f4): 2d 7c bc a0 '  mov r11, FP
2058(07f5): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
205c(07f6): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
2060(07f7): 78 7c 7c c2 '  cmps r11,  #120 wz
2064(07f8): 13 00 7c 5c '  jmp #BR_Z
2068(07f9): fc 1f 00 00 '  long @C__doprnt_172 ' EQI4
206c(07fa): 58 7c 7c c2 '  cmps r11,  #88 wz
2070(07fb): 14 00 7c 5c '  jmp #BRNZ
2074(07fc): 10 20 00 00 '  long @C__doprnt_171 ' NEI4
2078(07fd):             ' C__doprnt_172
2078(07fd): 40 7c bc a0 '  mov r11, r13
207c(07fe): 08 7c fc 60 '  and r11, #8 ' BANDI4 coni
2080(07ff): 00 7c 7c c2 '  cmps r11,  #0 wz
2084(0800): 14 00 7c 5c '  jmp #BRNZ
2088(0801): 7c 20 00 00 '  long @C__doprnt_175 ' NEI4
208c(0802):             ' C__doprnt_171
208c(0802): 2d 7c bc a0 '  mov r11, FP
2090(0803): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
2094(0804): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
2098(0805): 70 7c 7c c2 '  cmps r11,  #112 wz
209c(0806): 13 00 7c 5c '  jmp #BR_Z
20a0(0807): 7c 20 00 00 '  long @C__doprnt_175 ' EQI4
20a4(0808): 04 00 7c 5c '  jmp #LODA
20a8(0809): 54 28 00 00 '  long @C__doprnt_L000153
20ac(080a): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
20b0(080b): 40 7c bc 60 '  and r11, r13 ' BANDI/U (2)
20b4(080c): 00 7c 7c c2 '  cmps r11,  #0 wz
20b8(080d): 13 00 7c 5c '  jmp #BR_Z
20bc(080e): 98 20 00 00 '  long @C__doprnt_168 ' EQI4
20c0(080f): 2d 7c bc a0 '  mov r11, FP
20c4(0810): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
20c8(0811): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
20cc(0812): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
20d0(0813): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
20d4(0814): 2b 7c 7c c2 '  cmps r11,  #43 wz
20d8(0815): 13 00 7c 5c '  jmp #BR_Z
20dc(0816): 7c 20 00 00 '  long @C__doprnt_175 ' EQI4
20e0(0817): 2d 7c 7c c2 '  cmps r11,  #45 wz
20e4(0818): 13 00 7c 5c '  jmp #BR_Z
20e8(0819): 7c 20 00 00 '  long @C__doprnt_175 ' EQI4
20ec(081a): 20 7c 7c c2 '  cmps r11,  #32 wz
20f0(081b): 14 00 7c 5c '  jmp #BRNZ
20f4(081c): 98 20 00 00 '  long @C__doprnt_168 ' NEI4
20f8(081d):             ' C__doprnt_175
20f8(081d): 2d 7c bc a0 '  mov r11, FP
20fc(081e): 20 7c fc 84 '  sub r11, #-(-32) ' reg <- addrli
2100(081f): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
2104(0820): 01 7c fc d0 '  adds r11, #1 ' ADDI4 coni
2108(0821): 05 00 7c 5c '  jmp #LODF
210c(0822): e0 ff ff ff '  long -32
2110(0823): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2114(0824):             ' C__doprnt_168
2114(0824): 2d 7c bc a0 '  mov r11, FP
2118(0825): 14 7c fc 84 '  sub r11, #-(-20) ' reg <- addrli
211c(0826): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
2120(0827): 41 7c bc d4 '  subs r11, r14 ' SUBI/P (1)
2124(0828): 05 00 7c 5c '  jmp #LODF
2128(0829): f8 ff ff ff '  long -8
212c(082a): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2130(082b): 00 7c 7c c3 '  cmps r11,  #0 wz,wc
2134(082c): 17 00 7c 5c '  jmp #BRBE
2138(082d): 90 23 00 00 '  long @C__doprnt_176 ' LEI4
213c(082e): 40 7c bc a0 '  mov r11, r13
2140(082f): 01 7c fc 60 '  and r11, #1 ' BANDI4 coni
2144(0830): 00 7c 7c c2 '  cmps r11,  #0 wz
2148(0831): 14 00 7c 5c '  jmp #BRNZ
214c(0832): 90 23 00 00 '  long @C__doprnt_178 ' NEI4
2150(0833): 2d 7c bc a0 '  mov r11, FP
2154(0834): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
2158(0835): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
215c(0836): 3e 7e bc d0 '  adds r12, r11 ' ADDI/P (1)
2160(0837): 2d 7c bc a0 '  mov r11, FP
2164(0838): 20 7c fc 84 '  sub r11, #-(-32) ' reg <- addrli
2168(0839): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
216c(083a): 00 7c 7c c2 '  cmps r11,  #0 wz
2170(083b): 13 00 7c 5c '  jmp #BR_Z
2174(083c): dc 22 00 00 '  long @C__doprnt_180 ' EQI4
2178(083d): 04 00 7c 5c '  jmp #LODA
217c(083e): 54 28 00 00 '  long @C__doprnt_L000153
2180(083f): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
2184(0840): 40 7c bc 60 '  and r11, r13 ' BANDI/U (2)
2188(0841): 00 7c 7c c2 '  cmps r11,  #0 wz
218c(0842): 13 00 7c 5c '  jmp #BR_Z
2190(0843): cc 21 00 00 '  long @C__doprnt_182 ' EQI4
2194(0844): 01 82 fc d4 '  subs r14, #1 ' SUBI4 coni
2198(0845): 01 7e fc d0 '  adds r12, #1 ' ADDI4 coni
219c(0846): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
21a0(0847): 2d 7c bc a0 '  mov r11, FP
21a4(0848): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
21a8(0849): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
21ac(084a): 3e 7a bc a0 '  mov r10, r11
21b0(084b): 01 7a fc d0 '  adds r10, #1 ' ADDP4 coni
21b4(084c): 05 00 7c 5c '  jmp #LODF
21b8(084d): fc ff ff ff '  long -4
21bc(084e): 2e 7a 3c 08 '  wrlong r10, RI ' ASGNP4 addrl
21c0(084f): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
21c4(0850): 3e 6c bc a0 '  mov r3, r11 ' CVUI
21c8(0851): 4d 6c bc 60 '  and r3, cviu_m1 ' zero extend
21cc(0852): 08 5e fc a0 '  mov BC, #8 ' arg size
21d0(0853): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
21d4(0854): 0b 00 7c 5c '  jmp #CALA
21d8(0855): 2c 27 00 00 '  long @C_putc
21dc(0856): 08 58 fc 80 '  add SP, #8 ' CALL addrg
21e0(0857): 04 00 7c 5c '  jmp #LODA
21e4(0858): 70 28 00 00 '  long @C__doprnt_L000071
21e8(0859): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
21ec(085a): 3d 66 3c c2 '  cmps r0, r10 wz
21f0(085b): 14 00 7c 5c '  jmp #BRNZ
21f4(085c): dc 22 00 00 '  long @C__doprnt_183 ' NEI4
21f8(085d): 00 7e 7c c2 '  cmps r12,  #0 wz
21fc(085e): 13 00 7c 5c '  jmp #BR_Z
2200(085f): a0 21 00 00 '  long @C__doprnt_187 ' EQI4
2204(0860): 3f 7c bc a4 '  neg r11, r12 ' NEGI4
2208(0861): 05 00 7c 5c '  jmp #LODF
220c(0862): d0 fb ff ff '  long -1072
2210(0863): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2214(0864): 0e 00 7c 5c '  jmp #JMPA
2218(0865): b8 21 00 00 '  long @C__doprnt_188 ' JUMPV addrg
221c(0866):             ' C__doprnt_187
221c(0866): 04 00 7c 5c '  jmp #LODA
2220(0867): 70 28 00 00 '  long @C__doprnt_L000071
2224(0868): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
2228(0869): 05 00 7c 5c '  jmp #LODF
222c(086a): d0 fb ff ff '  long -1072
2230(086b): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2234(086c):             ' C__doprnt_188
2234(086c): 05 00 7c 5c '  jmp #LODF
2238(086d): d0 fb ff ff '  long -1072
223c(086e): 2e 66 bc 08 '  rdlong r0, RI ' reg <- INDIRI4 addrl
2240(086f): 0e 00 7c 5c '  jmp #JMPA
2244(0870): 74 25 00 00 '  long @C__doprnt_63 ' JUMPV addrg
2248(0871):             ' C__doprnt_182
2248(0871): 02 82 fc d4 '  subs r14, #2 ' SUBI4 coni
224c(0872): 02 7e fc d0 '  adds r12, #2 ' ADDI4 coni
2250(0873): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
2254(0874): 2d 7c bc a0 '  mov r11, FP
2258(0875): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
225c(0876): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
2260(0877): 3e 7a bc a0 '  mov r10, r11
2264(0878): 01 7a fc d0 '  adds r10, #1 ' ADDP4 coni
2268(0879): 05 00 7c 5c '  jmp #LODF
226c(087a): fc ff ff ff '  long -4
2270(087b): 2e 7a 3c 08 '  wrlong r10, RI ' ASGNP4 addrl
2274(087c): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
2278(087d): 3e 6c bc a0 '  mov r3, r11 ' CVUI
227c(087e): 4d 6c bc 60 '  and r3, cviu_m1 ' zero extend
2280(087f): 08 5e fc a0 '  mov BC, #8 ' arg size
2284(0880): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
2288(0881): 0b 00 7c 5c '  jmp #CALA
228c(0882): 2c 27 00 00 '  long @C_putc
2290(0883): 08 58 fc 80 '  add SP, #8 ' CALL addrg
2294(0884): 04 00 7c 5c '  jmp #LODA
2298(0885): 70 28 00 00 '  long @C__doprnt_L000071
229c(0886): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
22a0(0887): 3d 66 3c c2 '  cmps r0, r10 wz
22a4(0888): 13 00 7c 5c '  jmp #BR_Z
22a8(0889): 8c 22 00 00 '  long @C__doprnt_191 ' EQI4
22ac(088a): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
22b0(088b): 2d 7c bc a0 '  mov r11, FP
22b4(088c): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
22b8(088d): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
22bc(088e): 3e 7a bc a0 '  mov r10, r11
22c0(088f): 01 7a fc d0 '  adds r10, #1 ' ADDP4 coni
22c4(0890): 05 00 7c 5c '  jmp #LODF
22c8(0891): fc ff ff ff '  long -4
22cc(0892): 2e 7a 3c 08 '  wrlong r10, RI ' ASGNP4 addrl
22d0(0893): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
22d4(0894): 3e 6c bc a0 '  mov r3, r11 ' CVUI
22d8(0895): 4d 6c bc 60 '  and r3, cviu_m1 ' zero extend
22dc(0896): 08 5e fc a0 '  mov BC, #8 ' arg size
22e0(0897): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
22e4(0898): 0b 00 7c 5c '  jmp #CALA
22e8(0899): 2c 27 00 00 '  long @C_putc
22ec(089a): 08 58 fc 80 '  add SP, #8 ' CALL addrg
22f0(089b): 04 00 7c 5c '  jmp #LODA
22f4(089c): 70 28 00 00 '  long @C__doprnt_L000071
22f8(089d): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
22fc(089e): 3d 66 3c c2 '  cmps r0, r10 wz
2300(089f): 14 00 7c 5c '  jmp #BRNZ
2304(08a0): dc 22 00 00 '  long @C__doprnt_189 ' NEI4
2308(08a1):             ' C__doprnt_191
2308(08a1): 00 7e 7c c2 '  cmps r12,  #0 wz
230c(08a2): 13 00 7c 5c '  jmp #BR_Z
2310(08a3): b0 22 00 00 '  long @C__doprnt_193 ' EQI4
2314(08a4): 3f 7c bc a4 '  neg r11, r12 ' NEGI4
2318(08a5): 05 00 7c 5c '  jmp #LODF
231c(08a6): d0 fb ff ff '  long -1072
2320(08a7): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2324(08a8): 0e 00 7c 5c '  jmp #JMPA
2328(08a9): c8 22 00 00 '  long @C__doprnt_194 ' JUMPV addrg
232c(08aa):             ' C__doprnt_193
232c(08aa): 04 00 7c 5c '  jmp #LODA
2330(08ab): 70 28 00 00 '  long @C__doprnt_L000071
2334(08ac): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
2338(08ad): 05 00 7c 5c '  jmp #LODF
233c(08ae): d0 fb ff ff '  long -1072
2340(08af): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2344(08b0):             ' C__doprnt_194
2344(08b0): 05 00 7c 5c '  jmp #LODF
2348(08b1): d0 fb ff ff '  long -1072
234c(08b2): 2e 66 bc 08 '  rdlong r0, RI ' reg <- INDIRI4 addrl
2350(08b3): 0e 00 7c 5c '  jmp #JMPA
2354(08b4): 74 25 00 00 '  long @C__doprnt_63 ' JUMPV addrg
2358(08b5):             ' C__doprnt_189
2358(08b5):             ' C__doprnt_183
2358(08b5):             ' C__doprnt_180
2358(08b5):             ' C__doprnt_195
2358(08b5): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
235c(08b6): 2d 5c bc a0 '  mov RI, FP
2360(08b7): 0c 5c fc 84 '  sub RI, #-(-12)
2364(08b8): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRLi
2368(08b9): 08 5e fc a0 '  mov BC, #8 ' arg size
236c(08ba): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
2370(08bb): 0b 00 7c 5c '  jmp #CALA
2374(08bc): 2c 27 00 00 '  long @C_putc
2378(08bd): 08 58 fc 80 '  add SP, #8 ' CALL addrg
237c(08be): 04 00 7c 5c '  jmp #LODA
2380(08bf): 70 28 00 00 '  long @C__doprnt_L000071
2384(08c0): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
2388(08c1): 3d 66 3c c2 '  cmps r0, r10 wz
238c(08c2): 14 00 7c 5c '  jmp #BRNZ
2390(08c3): 68 23 00 00 '  long @C__doprnt_198 ' NEI4
2394(08c4): 00 7e 7c c2 '  cmps r12,  #0 wz
2398(08c5): 13 00 7c 5c '  jmp #BR_Z
239c(08c6): 3c 23 00 00 '  long @C__doprnt_201 ' EQI4
23a0(08c7): 3f 7c bc a4 '  neg r11, r12 ' NEGI4
23a4(08c8): 05 00 7c 5c '  jmp #LODF
23a8(08c9): d0 fb ff ff '  long -1072
23ac(08ca): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
23b0(08cb): 0e 00 7c 5c '  jmp #JMPA
23b4(08cc): 54 23 00 00 '  long @C__doprnt_202 ' JUMPV addrg
23b8(08cd):             ' C__doprnt_201
23b8(08cd): 04 00 7c 5c '  jmp #LODA
23bc(08ce): 70 28 00 00 '  long @C__doprnt_L000071
23c0(08cf): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
23c4(08d0): 05 00 7c 5c '  jmp #LODF
23c8(08d1): d0 fb ff ff '  long -1072
23cc(08d2): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
23d0(08d3):             ' C__doprnt_202
23d0(08d3): 05 00 7c 5c '  jmp #LODF
23d4(08d4): d0 fb ff ff '  long -1072
23d8(08d5): 2e 66 bc 08 '  rdlong r0, RI ' reg <- INDIRI4 addrl
23dc(08d6): 0e 00 7c 5c '  jmp #JMPA
23e0(08d7): 74 25 00 00 '  long @C__doprnt_63 ' JUMPV addrg
23e4(08d8):             ' C__doprnt_198
23e4(08d8): 2d 7c bc a0 '  mov r11, FP
23e8(08d9): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
23ec(08da): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
23f0(08db): 01 7c fc d4 '  subs r11, #1 ' SUBI4 coni
23f4(08dc): 05 00 7c 5c '  jmp #LODF
23f8(08dd): f8 ff ff ff '  long -8
23fc(08de): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2400(08df): 00 7c 7c c2 '  cmps r11,  #0 wz
2404(08e0): 14 00 7c 5c '  jmp #BRNZ
2408(08e1): dc 22 00 00 '  long @C__doprnt_195 ' NEI4
240c(08e2):             ' C__doprnt_178
240c(08e2):             ' C__doprnt_176
240c(08e2): 41 7e bc d0 '  adds r12, r14 ' ADDI/P (1)
2410(08e3): 0e 00 7c 5c '  jmp #JMPA
2414(08e4): 48 24 00 00 '  long @C__doprnt_204 ' JUMPV addrg
2418(08e5):             ' C__doprnt_203
2418(08e5): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
241c(08e6): 2d 7c bc a0 '  mov r11, FP
2420(08e7): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
2424(08e8): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
2428(08e9): 3e 7a bc a0 '  mov r10, r11
242c(08ea): 01 7a fc d0 '  adds r10, #1 ' ADDP4 coni
2430(08eb): 05 00 7c 5c '  jmp #LODF
2434(08ec): fc ff ff ff '  long -4
2438(08ed): 2e 7a 3c 08 '  wrlong r10, RI ' ASGNP4 addrl
243c(08ee): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
2440(08ef): 3e 6c bc a0 '  mov r3, r11 ' CVUI
2444(08f0): 4d 6c bc 60 '  and r3, cviu_m1 ' zero extend
2448(08f1): 08 5e fc a0 '  mov BC, #8 ' arg size
244c(08f2): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
2450(08f3): 0b 00 7c 5c '  jmp #CALA
2454(08f4): 2c 27 00 00 '  long @C_putc
2458(08f5): 08 58 fc 80 '  add SP, #8 ' CALL addrg
245c(08f6): 04 00 7c 5c '  jmp #LODA
2460(08f7): 70 28 00 00 '  long @C__doprnt_L000071
2464(08f8): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
2468(08f9): 3d 66 3c c2 '  cmps r0, r10 wz
246c(08fa): 14 00 7c 5c '  jmp #BRNZ
2470(08fb): 48 24 00 00 '  long @C__doprnt_206 ' NEI4
2474(08fc): 00 7e 7c c2 '  cmps r12,  #0 wz
2478(08fd): 13 00 7c 5c '  jmp #BR_Z
247c(08fe): 1c 24 00 00 '  long @C__doprnt_209 ' EQI4
2480(08ff): 3f 7c bc a4 '  neg r11, r12 ' NEGI4
2484(0900): 05 00 7c 5c '  jmp #LODF
2488(0901): d0 fb ff ff '  long -1072
248c(0902): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2490(0903): 0e 00 7c 5c '  jmp #JMPA
2494(0904): 34 24 00 00 '  long @C__doprnt_210 ' JUMPV addrg
2498(0905):             ' C__doprnt_209
2498(0905): 04 00 7c 5c '  jmp #LODA
249c(0906): 70 28 00 00 '  long @C__doprnt_L000071
24a0(0907): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
24a4(0908): 05 00 7c 5c '  jmp #LODF
24a8(0909): d0 fb ff ff '  long -1072
24ac(090a): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
24b0(090b):             ' C__doprnt_210
24b0(090b): 05 00 7c 5c '  jmp #LODF
24b4(090c): d0 fb ff ff '  long -1072
24b8(090d): 2e 66 bc 08 '  rdlong r0, RI ' reg <- INDIRI4 addrl
24bc(090e): 0e 00 7c 5c '  jmp #JMPA
24c0(090f): 74 25 00 00 '  long @C__doprnt_63 ' JUMPV addrg
24c4(0910):             ' C__doprnt_206
24c4(0910):             ' C__doprnt_204
24c4(0910): 41 7c bc a0 '  mov r11, r14
24c8(0911): 01 7c fc d4 '  subs r11, #1 ' SUBI4 coni
24cc(0912): 3e 82 bc a0 '  mov r14, r11 ' CVI, CVU or LOAD
24d0(0913): 00 7c 7c c3 '  cmps r11,  #0 wz,wc
24d4(0914): 15 00 7c 5c '  jmp #BRAE
24d8(0915): 9c 23 00 00 '  long @C__doprnt_203 ' GEI4
24dc(0916): 2d 7c bc a0 '  mov r11, FP
24e0(0917): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
24e4(0918): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
24e8(0919): 00 7c 7c c3 '  cmps r11,  #0 wz,wc
24ec(091a): 17 00 7c 5c '  jmp #BRBE
24f0(091b): 1c 25 00 00 '  long @C__doprnt_214 ' LEI4
24f4(091c): 2d 7c bc a0 '  mov r11, FP
24f8(091d): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
24fc(091e): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
2500(091f): 3e 7e bc d0 '  adds r12, r11 ' ADDI/P (1)
2504(0920): 0e 00 7c 5c '  jmp #JMPA
2508(0921): 1c 25 00 00 '  long @C__doprnt_214 ' JUMPV addrg
250c(0922):             ' C__doprnt_213
250c(0922): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
2510(0923): 2d 5c bc a0 '  mov RI, FP
2514(0924): 0c 5c fc 84 '  sub RI, #-(-12)
2518(0925): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRLi
251c(0926): 08 5e fc a0 '  mov BC, #8 ' arg size
2520(0927): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
2524(0928): 0b 00 7c 5c '  jmp #CALA
2528(0929): 2c 27 00 00 '  long @C_putc
252c(092a): 08 58 fc 80 '  add SP, #8 ' CALL addrg
2530(092b): 04 00 7c 5c '  jmp #LODA
2534(092c): 70 28 00 00 '  long @C__doprnt_L000071
2538(092d): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
253c(092e): 3d 66 3c c2 '  cmps r0, r10 wz
2540(092f): 14 00 7c 5c '  jmp #BRNZ
2544(0930): 1c 25 00 00 '  long @C__doprnt_216 ' NEI4
2548(0931): 00 7e 7c c2 '  cmps r12,  #0 wz
254c(0932): 13 00 7c 5c '  jmp #BR_Z
2550(0933): f0 24 00 00 '  long @C__doprnt_219 ' EQI4
2554(0934): 3f 7c bc a4 '  neg r11, r12 ' NEGI4
2558(0935): 05 00 7c 5c '  jmp #LODF
255c(0936): d0 fb ff ff '  long -1072
2560(0937): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2564(0938): 0e 00 7c 5c '  jmp #JMPA
2568(0939): 08 25 00 00 '  long @C__doprnt_220 ' JUMPV addrg
256c(093a):             ' C__doprnt_219
256c(093a): 04 00 7c 5c '  jmp #LODA
2570(093b): 70 28 00 00 '  long @C__doprnt_L000071
2574(093c): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
2578(093d): 05 00 7c 5c '  jmp #LODF
257c(093e): d0 fb ff ff '  long -1072
2580(093f): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2584(0940):             ' C__doprnt_220
2584(0940): 05 00 7c 5c '  jmp #LODF
2588(0941): d0 fb ff ff '  long -1072
258c(0942): 2e 66 bc 08 '  rdlong r0, RI ' reg <- INDIRI4 addrl
2590(0943): 0e 00 7c 5c '  jmp #JMPA
2594(0944): 74 25 00 00 '  long @C__doprnt_63 ' JUMPV addrg
2598(0945):             ' C__doprnt_216
2598(0945):             ' C__doprnt_214
2598(0945): 2d 7c bc a0 '  mov r11, FP
259c(0946): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
25a0(0947): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
25a4(0948): 01 7c fc d4 '  subs r11, #1 ' SUBI4 coni
25a8(0949): 05 00 7c 5c '  jmp #LODF
25ac(094a): f8 ff ff ff '  long -8
25b0(094b): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
25b4(094c): 00 7c 7c c3 '  cmps r11,  #0 wz,wc
25b8(094d): 15 00 7c 5c '  jmp #BRAE
25bc(094e): 90 24 00 00 '  long @C__doprnt_213 ' GEI4
25c0(094f):             ' C__doprnt_65
25c0(094f): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
25c4(0950): 3e 88 bc a0 '  mov r17, r11
25c8(0951): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
25cc(0952): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
25d0(0953): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
25d4(0954): 05 00 7c 5c '  jmp #LODF
25d8(0955): f0 ff ff ff '  long -16
25dc(0956): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
25e0(0957): 00 7c 7c c2 '  cmps r11,  #0 wz
25e4(0958): 14 00 7c 5c '  jmp #BRNZ
25e8(0959): 38 16 00 00 '  long @C__doprnt_64 ' NEI4
25ec(095a): 3f 66 bc a0 '  mov r0, r12 ' CVI, CVU or LOAD
25f0(095b):             ' C__doprnt_63
25f0(095b): 23 00 7c 5c '  jmp #POPM
25f4(095c): 00 fe 03 00 '  long $3fe00 ' restore registers
25f8(095d): 03 00 7c 5c '  jmp #LODL
25fc(095e): 30 04 00 00 '  long 1072
2600(095f): 2e 58 bc 80 '  add SP, RI ' framesize
2604(0960): 0a 00 7c 5c '  jmp #RETF
2608(0961):             '  long ' align long
2608(0961):             ' C__i_compute ' <symbol:_i_compute>
2608(0961): 22 00 7c 5c '  jmp #PSHM
260c(0962): 00 fc 03 00 '  long $3fc00 ' save registers
2610(0963): 38 88 bc a0 '  mov r17, r5 ' reg var <- reg arg
2614(0964): 37 86 bc a0 '  mov r16, r4 ' reg var <- reg arg
2618(0965): 36 84 bc a0 '  mov r15, r3 ' reg var <- reg arg
261c(0966): 35 82 bc a0 '  mov r14, r2 ' reg var <- reg arg
2620(0967): 44 66 bc a0 '  mov r0, r17 ' setup r0/r1 (2)
2624(0968): 43 68 bc a0 '  mov r1, r16 ' setup r0/r1 (2)
2628(0969): 11 00 7c 5c '  jmp #DIVU ' DIVU
262c(096a): 34 80 bc a0 '  mov r13, r1 ' CVI, CVU or LOAD
2630(096b): 44 66 bc a0 '  mov r0, r17 ' setup r0/r1 (2)
2634(096c): 43 68 bc a0 '  mov r1, r16 ' setup r0/r1 (2)
2638(096d): 11 00 7c 5c '  jmp #DIVU ' DIVU
263c(096e): 33 88 bc a0 '  mov r17, r0 ' CVI, CVU or LOAD
2640(096f): 00 88 7c 86 '  cmp r17,  #0 wz
2644(0970): 14 00 7c 5c '  jmp #BRNZ
2648(0971): dc 25 00 00 '  long @C__i_compute_4 ' NEU4
264c(0972): 01 82 7c c3 '  cmps r14,  #1 wz,wc
2650(0973): 17 00 7c 5c '  jmp #BRBE
2654(0974): 08 26 00 00 '  long @C__i_compute_2 ' LEI4
2658(0975):             ' C__i_compute_4
2658(0975): 41 6a bc a0 '  mov r2, r14
265c(0976): 01 6a fc d4 '  subs r2, #1 ' SUBI4 coni
2660(0977): 42 6c bc a0 '  mov r3, r15 ' CVI, CVU or LOAD
2664(0978): 43 6e bc a0 '  mov r4, r16 ' CVI, CVU or LOAD
2668(0979): 44 70 bc a0 '  mov r5, r17 ' CVI, CVU or LOAD
266c(097a): 10 5e fc a0 '  mov BC, #16 ' arg size
2670(097b): 10 58 fc 84 '  sub SP, #16 ' stack space for reg ARGs
2674(097c): 0b 00 7c 5c '  jmp #CALA
2678(097d): 8c 25 00 00 '  long @C__i_compute
267c(097e): 10 58 fc 80 '  add SP, #16 ' CALL addrg
2680(097f): 33 84 bc a0 '  mov r15, r0 ' CVI, CVU or LOAD
2684(0980):             ' C__i_compute_2
2684(0980): 42 7c bc a0 '  mov r11, r15 ' CVI, CVU or LOAD
2688(0981): 3e 84 bc a0 '  mov r15, r11
268c(0982): 01 84 fc d0 '  adds r15, #1 ' ADDP4 coni
2690(0983): 09 80 7c c3 '  cmps r13,  #9 wz,wc
2694(0984): 17 00 7c 5c '  jmp #BRBE
2698(0985): 38 26 00 00 '  long @C__i_compute_6 ' LEI4
269c(0986): 40 7a bc a0 '  mov r10, r13
26a0(0987): 0a 7a fc d4 '  subs r10, #10 ' SUBI4 coni
26a4(0988): 3d 7e bc a0 '  mov r12, r10
26a8(0989): 61 7e fc d0 '  adds r12, #97 ' ADDI4 coni
26ac(098a): 0e 00 7c 5c '  jmp #JMPA
26b0(098b): 40 26 00 00 '  long @C__i_compute_7 ' JUMPV addrg
26b4(098c):             ' C__i_compute_6
26b4(098c): 40 7e bc a0 '  mov r12, r13
26b8(098d): 30 7e fc d0 '  adds r12, #48 ' ADDI4 coni
26bc(098e):             ' C__i_compute_7
26bc(098e): 3f 7a bc a0 '  mov r10, r12 ' CVI, CVU or LOAD
26c0(098f): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
26c4(0990): 42 66 bc a0 '  mov r0, r15 ' CVI, CVU or LOAD
26c8(0991): 23 00 7c 5c '  jmp #POPM
26cc(0992): 00 fc 03 00 '  long $3fc00 ' restore registers
26d0(0993): 0c 00 7c 5c '  jmp #RETN
26d4(0994):             '  long ' align long
26d4(0994):             ' C__ina
26d4(0994): f2 67 bc a0 '  mov r0, INA
26d8(0995): 0c 00 7c 5c '  jmp #RETN
26dc(0996):             '  long ' align long
26dc(0996):             ' C__outa
26dc(0996): f4 67 bc a0 '  mov r0, OUTA
26e0(0997): 36 e8 bf 64 '  andn OUTA, r3
26e4(0998): 35 e8 bf 68 '  or OUTA, r2
26e8(0999): 0c 00 7c 5c '  jmp #RETN
26ec(099a):             '  long ' align long
26ec(099a):             ' C_printf ' <symbol:printf>
26ec(099a): 09 00 7c 5c '  jmp #NEWF
26f0(099b): 08 58 fc 84 '  sub SP, #8
26f4(099c): 22 00 7c 5c '  jmp #PSHM
26f8(099d): 00 08 00 00 '  long $800 ' save registers
26fc(099e): 2d 5c bc a0 '  mov RI, FP
2700(099f): 08 5c fc 80 '  add RI, #8
2704(09a0): 04 5e fc 84 '  sub BC, #4
2708(09a1): 2e 5e 3c 87 '  cmp BC, RI wz,wc
270c(09a2): 2f 6a 0c 08 '  if_ae wrlong r2, BC ' spill reg (varadic)
2710(09a3): 04 5e fc 84 '  sub BC, #4
2714(09a4): 2e 5e 3c 87 '  cmp BC, RI wz,wc
2718(09a5): 2f 6c 0c 08 '  if_ae wrlong r3, BC ' spill reg (varadic)
271c(09a6): 04 5e fc 84 '  sub BC, #4
2720(09a7): 2e 5e 3c 87 '  cmp BC, RI wz,wc
2724(09a8): 2f 6e 0c 08 '  if_ae wrlong r4, BC ' spill reg (varadic)
2728(09a9): 04 5e fc 84 '  sub BC, #4
272c(09aa): 2e 5e 3c 87 '  cmp BC, RI wz,wc
2730(09ab): 2f 70 0c 08 '  if_ae wrlong r5, BC ' spill reg (varadic)
2734(09ac): 2d 7c bc a0 '  mov r11, FP
2738(09ad): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
273c(09ae): 05 00 7c 5c '  jmp #LODF
2740(09af): fc ff ff ff '  long -4
2744(09b0): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
2748(09b1): 04 00 7c 5c '  jmp #LODA
274c(09b2): e4 28 00 00 '  long @C___stdout
2750(09b3): 2e 6a bc a0 '  mov r2, RI ' reg ARG ADDRG
2754(09b4): 2d 5c bc a0 '  mov RI, FP
2758(09b5): 04 5c fc 84 '  sub RI, #-(-4)
275c(09b6): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRLi
2760(09b7): 2d 5c bc a0 '  mov RI, FP
2764(09b8): 08 5c fc 80 '  add RI, #8
2768(09b9): 2e 6e bc 08 '  rdlong r4, RI ' reg ARG INDIR ADDRFi
276c(09ba): 0c 5e fc a0 '  mov BC, #12 ' arg size
2770(09bb): 0c 58 fc 84 '  sub SP, #12 ' stack space for reg ARGs
2774(09bc): 0b 00 7c 5c '  jmp #CALA
2778(09bd): 00 16 00 00 '  long @C__doprnt
277c(09be): 0c 58 fc 80 '  add SP, #12 ' CALL addrg
2780(09bf): 05 00 7c 5c '  jmp #LODF
2784(09c0): f8 ff ff ff '  long -8
2788(09c1): 2e 66 3c 08 '  wrlong r0, RI ' ASGNI4 addrl
278c(09c2): 2d 7c bc a0 '  mov r11, FP
2790(09c3): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
2794(09c4): 3e 66 bc 08 '  rdlong r0, r11 ' reg <- INDIRI4 reg
2798(09c5): 23 00 7c 5c '  jmp #POPM
279c(09c6): 00 08 00 00 '  long $800 ' restore registers
27a0(09c7): 08 58 fc 80 '  add SP, #8 ' framesize
27a4(09c8): 0a 00 7c 5c '  jmp #RETF
27a8(09c9):             '  long ' align long
27a8(09c9):             ' C_putc ' <symbol:putc>
27a8(09c9): 22 00 7c 5c '  jmp #PSHM
27ac(09ca): 00 08 03 00 '  long $30800 ' save registers
27b0(09cb): 36 88 bc a0 '  mov r17, r3 ' reg var <- reg arg
27b4(09cc): 35 86 bc a0 '  mov r16, r2 ' reg var <- reg arg
27b8(09cd): 44 6c bc a0 '  mov r3, r17 ' CVI, CVU or LOAD
27bc(09ce): 08 5e fc a0 '  mov BC, #8 ' arg size
27c0(09cf): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
27c4(09d0): 0b 00 7c 5c '  jmp #CALA
27c8(09d1): 70 0e 00 00 '  long @C_catalina_putc
27cc(09d2): 08 58 fc 80 '  add SP, #8 ' CALL addrg
27d0(09d3): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
27d4(09d4): 23 00 7c 5c '  jmp #POPM
27d8(09d5): 00 08 03 00 '  long $30800 ' restore registers
27dc(09d6): 0c 00 7c 5c '  jmp #RETN
27e0(09d7):             '  long ' align long
27e0(09d7):             ' C_toupper ' <symbol:toupper>
27e0(09d7): 22 00 7c 5c '  jmp #PSHM
27e4(09d8): 00 08 02 00 '  long $20800 ' save registers
27e8(09d9): 35 7c bc a0 '  mov r11, r2
27ec(09da): 61 7c fc d4 '  subs r11, #97 ' SUBI4 coni
27f0(09db): 1a 7c 7c 87 '  cmp r11,  #26 wz,wc 
27f4(09dc): 15 00 7c 5c '  jmp #BRAE
27f8(09dd): 98 27 00 00 '  long @C_toupper_3 ' GEU4
27fc(09de): 35 7c bc a0 '  mov r11, r2
2800(09df): 61 7c fc d4 '  subs r11, #97 ' SUBI4 coni
2804(09e0): 3e 88 bc a0 '  mov r17, r11
2808(09e1): 41 88 fc d0 '  adds r17, #65 ' ADDI4 coni
280c(09e2): 0e 00 7c 5c '  jmp #JMPA
2810(09e3): 9c 27 00 00 '  long @C_toupper_4 ' JUMPV addrg
2814(09e4):             ' C_toupper_3
2814(09e4): 35 88 bc a0 '  mov r17, r2 ' CVI, CVU or LOAD
2818(09e5):             ' C_toupper_4
2818(09e5): 44 66 bc a0 '  mov r0, r17 ' CVI, CVU or LOAD
281c(09e6): 23 00 7c 5c '  jmp #POPM
2820(09e7): 00 08 02 00 '  long $20800 ' restore registers
2824(09e8): 0c 00 7c 5c '  jmp #RETN
2828(09e9):             '  long ' align long
2828(09e9):             ' C__waitcnt
2828(09e9): 00 6a fc f8 '  waitcnt r2, #0
282c(09ea): 0c 00 7c 5c '  jmp #RETN
2830(09eb):             '  long ' align long
2830(09eb):             ' Catalina_Cnst
2830(09eb):             '  long ' align long
2830(09eb):             ' C_main_L000026 ' <symbol:27>
2830(09eb): 00 00 ff 00 '  long 16711680
2834(09ec):             '  long ' align long
2834(09ec):             ' C_main_21_L000022 ' <symbol:21>
2834(09ec): 47          '  byte 71
2835(----): 2d          '  byte 45
2836(----): 58          '  byte 88
2837(----): 59          '  byte 89
2838(09ed): 5a          '  byte 90
2839(----): 20          '  byte 32
283a(----): 5b          '  byte 91
283b(----): 25          '  byte 37
283c(09ee): 64          '  byte 100
283d(----): 2c          '  byte 44
283e(----): 20          '  byte 32
283f(----): 25          '  byte 37
2840(09ef): 64          '  byte 100
2841(----): 2c          '  byte 44
2842(----): 20          '  byte 32
2843(----): 25          '  byte 37
2844(09f0): 64          '  byte 100
2845(----): 5d          '  byte 93
2846(----): 0a          '  byte 10
2847(----): 00          '  byte 0
2848(09f1):             '  long ' align long
2848(09f1):             ' C_main_16_L000017 ' <symbol:16>
2848(09f1): 43          '  byte 67
2849(----): 75          '  byte 117
284a(----): 72          '  byte 114
284b(----): 72          '  byte 114
284c(09f2): 65          '  byte 101
284d(----): 6e          '  byte 110
284e(----): 74          '  byte 116
284f(----): 20          '  byte 32
2850(09f3): 66          '  byte 102
2851(----): 72          '  byte 114
2852(----): 65          '  byte 101
2853(----): 71          '  byte 113
2854(09f4): 75          '  byte 117
2855(----): 65          '  byte 101
2856(----): 6e          '  byte 110
2857(----): 63          '  byte 99
2858(09f5): 79          '  byte 121
2859(----): 20          '  byte 32
285a(----): 3d          '  byte 61
285b(----): 20          '  byte 32
285c(09f6): 25          '  byte 37
285d(----): 75          '  byte 117
285e(----): 0a          '  byte 10
285f(----): 00          '  byte 0
2860(09f7):             '  long ' align long
2860(09f7):             ' C_main_L000013 ' <symbol:14>
2860(09f7): 40 4b 4c 00 '  long 5000000
2864(09f8):             '  long ' align long
2864(09f8):             ' C_bbos_time_init_L000008 ' <symbol:9>
2864(09f8): 40 42 0f 00 '  long 1000000
2868(09f9):             '  long ' align long
2868(09f9):             ' C_bbos_time_init_L000004 ' <symbol:5>
2868(09f9): 3f 42 0f 00 '  long 999999
286c(09fa):             '  long ' align long
286c(09fa):             ' C_tmpfilex4T4vf_4d178bb2_post_clock_pulse_L000002_L000004 ' <symbol:5>
286c(09fa): 58 02 00 00 '  long 600
2870(09fb):             '  long ' align long
2870(09fb):             ' C_h48c_read_value_L000029 ' <symbol:30>
2870(09fb): ff 1f 00 00 '  long 8191
2874(09fc):             '  long ' align long
2874(09fc):             ' C_tmpfileCxgKZh_4d178bb2_umulf_L000002_12_L000013 ' <symbol:12>
2874(09fc): 52          '  byte 82
2875(----): 65          '  byte 101
2876(----): 73          '  byte 115
2877(----): 75          '  byte 117
2878(09fd): 6c          '  byte 108
2879(----): 74          '  byte 116
287a(----): 3a          '  byte 58
287b(----): 20          '  byte 32
287c(09fe): 25          '  byte 37
287d(----): 64          '  byte 100
287e(----): 0a          '  byte 10
287f(----): 00          '  byte 0
2880(09ff):             '  long ' align long
2880(09ff):             ' C__doprnt_162_L000164 ' <symbol:162>
2880(09ff): 50 1d 00 00 '  long @C__doprnt_147
2884(0a00): b8 1e 00 00 '  long @C__doprnt_158
2888(0a01): 08 1e 00 00 '  long @C__doprnt_152
288c(0a02): e0 1a 00 00 '  long @C__doprnt_123
2890(0a03): e0 1a 00 00 '  long @C__doprnt_123
2894(0a04): e0 1a 00 00 '  long @C__doprnt_123
2898(0a05): e0 1a 00 00 '  long @C__doprnt_123
289c(0a06): 08 1e 00 00 '  long @C__doprnt_152
28a0(0a07): e0 1a 00 00 '  long @C__doprnt_123
28a4(0a08): e0 1a 00 00 '  long @C__doprnt_123
28a8(0a09): e0 1a 00 00 '  long @C__doprnt_123
28ac(0a0a): e0 1a 00 00 '  long @C__doprnt_123
28b0(0a0b): 78 1b 00 00 '  long @C__doprnt_131
28b4(0a0c): 50 1d 00 00 '  long @C__doprnt_147
28b8(0a0d): 50 1d 00 00 '  long @C__doprnt_146
28bc(0a0e): e0 1a 00 00 '  long @C__doprnt_123
28c0(0a0f): 00 1f 00 00 '  long @C__doprnt_159
28c4(0a10): 58 1c 00 00 '  long @C__doprnt_136
28c8(0a11): e0 1a 00 00 '  long @C__doprnt_123
28cc(0a12): 50 1d 00 00 '  long @C__doprnt_147
28d0(0a13):             '  long ' align long
28d0(0a13):             ' C__doprnt_L000153 ' <symbol:154>
28d0(0a13): 00 04 00 00 '  long 1024
28d4(0a14):             '  long ' align long
28d4(0a14):             ' C__doprnt_139_L000140 ' <symbol:139>
28d4(0a14): 28          '  byte 40
28d5(----): 6e          '  byte 110
28d6(----): 75          '  byte 117
28d7(----): 6c          '  byte 108
28d8(0a15): 6c          '  byte 108
28d9(----): 29          '  byte 41
28da(----): 00          '  byte 0
28db(----): 00          
28dc(0a16):             '  long ' align long
28dc(0a16):             ' C__doprnt_L000112 ' <symbol:113>
28dc(0a16): ef ff ff ff '  long -17
28e0(0a17):             '  long ' align long
28e0(0a17):             ' C__doprnt_L000107 ' <symbol:108>
28e0(0a17): fb ff ff ff '  long -5
28e4(0a18):             '  long ' align long
28e4(0a18):             ' C__doprnt_L000098 ' <symbol:99>
28e4(0a18): 00 02 00 00 '  long 512
28e8(0a19):             '  long ' align long
28e8(0a19):             ' C__doprnt_L000088 ' <symbol:89>
28e8(0a19): 00 10 00 00 '  long 4096
28ec(0a1a):             '  long ' align long
28ec(0a1a):             ' C__doprnt_L000071 ' <symbol:72>
28ec(0a1a): ff ff ff ff '  long -1
28f0(0a1b):             '  long ' align long
28f0(0a1b):             ' C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005 ' <symbol:6>
28f0(0a1b): fc ff ff ff '  long -4
28f4(0a1c):             '  long ' align long
28f4(0a1c):             ' Catalina_Init
28f4(0a1c):             '  long ' align long
28f4(0a1c): 00 00 00 00 ' C_errno long 0
28f8(0a1d):             '  long ' align long
28f8(0a1d):             ' C_table ' <symbol:table>
28f8(0a1d): 00 00 00 20 '  long 536870912
28fc(0a1e): 1e 05 e4 12 '  long 316933406
2900(0a1f): 5b 38 fb 09 '  long 167458907
2904(0a20): d4 11 11 05 '  long 85004756
2908(0a21): 43 0d 8b 02 '  long 42667331
290c(0a22): e1 d7 45 01 '  long 21354465
2910(0a23): 1e f6 a2 00 '  long 10679838
2914(0a24): 55 7c 51 00 '  long 5340245
2918(0a25): 53 be 28 00 '  long 2670163
291c(0a26): 2f 5f 14 00 '  long 1335087
2920(0a27): 98 2f 0a 00 '  long 667544
2924(0a28): cc 17 05 00 '  long 333772
2928(0a29): e6 8b 02 00 '  long 166886
292c(0a2a): f3 45 01 00 '  long 83443
2930(0a2b): fa a2 00 00 '  long 41722
2934(0a2c): 7d 51 00 00 '  long 20861
2938(0a2d): be 28 00 00 '  long 10430
293c(0a2e): 5f 14 00 00 '  long 5215
2940(0a2f): 30 0a 00 00 '  long 2608
2944(0a30): 18 05 00 00 '  long 1304
2948(0a31):             '  long ' align long
2948(0a31):             ' C___stdin ' <symbol:__stdin>
2948(0a31): 00 00 00 00 '  long 0
294c(0a32): 00 00 00 00 '  long 0
2950(0a33): 01 00 00 00 '  long 1
2954(0a34): 00 00 00 00 '  long 0
2958(0a35): 00 00 00 00 '  long $0
295c(0a36): 00 00 00 00 '  long $0
2960(0a37):             '  long ' align long
2960(0a37):             ' C___stdout ' <symbol:__stdout>
2960(0a37): 00 00 00 00 '  long 0
2964(0a38): 01 00 00 00 '  long 1
2968(0a39): 02 00 00 00 '  long 2
296c(0a3a): 00 00 00 00 '  long 0
2970(0a3b): 00 00 00 00 '  long $0
2974(0a3c): 00 00 00 00 '  long $0
2978(0a3d):             '  long ' align long
2978(0a3d):             ' C___stderr ' <symbol:__stderr>
2978(0a3d): 00 00 00 00 '  long 0
297c(0a3e): 02 00 00 00 '  long 2
2980(0a3f): 42 00 00 00 '  long 66
2984(0a40): 00 00 00 00 '  long 0
2988(0a41): 00 00 00 00 '  long $0
298c(0a42): 00 00 00 00 '  long $0
2990(0a43):             '  long ' align long
2990(0a43):             ' C___iotab ' <symbol:__iotab>
2990(0a43): cc 28 00 00 '  long @C___stdin
2994(0a44): e4 28 00 00 '  long @C___stdout
2998(0a45): fc 28 00 00 '  long @C___stderr
299c(0a46): 00 00 00 00 '  long $0
29a0(0a47): 00 00 00 00 '  byte 0[64]
29a4(0a48): 00 00 00 00 ' 
29a8(0a49): 00 00 00 00 ' 
29ac(0a4a): 00 00 00 00 ' 
29b0(0a4b): 00 00 00 00 ' 
29b4(0a4c): 00 00 00 00 ' 
29b8(0a4d): 00 00 00 00 ' 
29bc(0a4e): 00 00 00 00 ' 
29c0(0a4f): 00 00 00 00 ' 
29c4(0a50): 00 00 00 00 ' 
29c8(0a51): 00 00 00 00 ' 
29cc(0a52): 00 00 00 00 ' 
29d0(0a53): 00 00 00 00 ' 
29d4(0a54): 00 00 00 00 ' 
29d8(0a55): 00 00 00 00 ' 
29dc(0a56): 00 00 00 00 ' 
29e0(0a57):             '  long ' align long
29e0(0a57):             ' Catalina_Data
29e0(0a57):             '  long ' align long
29e0(0a57):             ' C_usec_delay ' <symbol:usec_delay>
29e0(0a57): 00 00 00 00 '  byte 0[4]
29e4(0a58):             '  long ' align long
29e4(0a58):             ' C_h48c_theta_c ' <symbol:h48c_theta_c>
29e4(0a58): 00 00 00 00 '  byte 0[4]
29e8(0a59):             '  long ' align long
29e8(0a59):             ' C_h48c_theta_b ' <symbol:h48c_theta_b>
29e8(0a59): 00 00 00 00 '  byte 0[4]
29ec(0a5a):             '  long ' align long
29ec(0a5a):             ' C_h48c_theta_a ' <symbol:h48c_theta_a>
29ec(0a5a): 00 00 00 00 '  byte 0[4]
29f0(0a5b):             '  long ' align long
29f0(0a5b):             ' C_gforce_z ' <symbol:gforce_z>
29f0(0a5b): 00 00 00 00 '  byte 0[4]
29f4(0a5c):             '  long ' align long
29f4(0a5c):             ' C_gforce_y ' <symbol:gforce_y>
29f4(0a5c): 00 00 00 00 '  byte 0[4]
29f8(0a5d):             '  long ' align long
29f8(0a5d):             ' C_gforce_x ' <symbol:gforce_x>
29f8(0a5d): 00 00 00 00 '  byte 0[4]
29fc(0a5e):             '  long ' align long
29fc(0a5e):             ' C_tmpfileSpHr4Y_4d178bb2_h48c_zerog_pin_L000017 ' <symbol:h48c_zerog_pin>
29fc(0a5e): 00 00 00 00 '  byte 0[4]
2a00(0a5f):             '  long ' align long
2a00(0a5f):             ' C_tmpfileQ8dHEr_4d178bb2_h48c_cs_pin_L000016 ' <symbol:h48c_cs_pin>
2a00(0a5f): 00 00 00 00 '  byte 0[4]
2a04(0a60):             '  long ' align long
2a04(0a60):             ' C_tmpfileYkNWeU_4d178bb2_h48c_clk_pin_L000015 ' <symbol:h48c_clk_pin>
2a04(0a60): 00 00 00 00 '  byte 0[4]
2a08(0a61):             '  long ' align long
2a08(0a61):             ' C_tmpfileqjwcPm_4d178bb2_h48c_dio_pin_L000014 ' <symbol:h48c_dio_pin>
2a08(0a61): 00 00 00 00 '  byte 0[4]
2a0c(0a62):             '  long ' align long
2a0c(0a62):             ' sbrkinit  ' heap starts here
2a0c(0a62): 00 00 00 00 '  long 0 ' this long is required to workaround an obscure homespun bug!!!
2a10(0a63):             '  long ' align long
2a10(0a63):             ' Catalina_Ends ' end of segments
'============================ Method #1: PUB Base =============================
'PUB Base : addr
'------------------------------------------------------------------------------
   addr := @@0 ' Catalina Base Address
'------------------------------------------------------------------------------
2a10: 35             PUSH#0	
2a11: 97 00          PUSH#.B	OBJ+0[]
2a13: 61             POP  	Locals+0
2a14: 32             RETURN	
2a15: 00 00 00    

'******************************************************************************
'                           Catalina_Cogstore.spin                             
'******************************************************************************

'=================================== CONs =====================================
MAX_LONGS = 300
COGSTORE = 32508
ARGC_ADDR = 32560
ARGV_ADDR = 32562
ARGV_0 = 32564
ARGV_MAX = 32
CMD_READ = 268435456
CMD_WRITE = 536870912
CMD_SIZE = 805306368
CMD_SETUP = 1073741824
CMD_RESPONSE = -17958194
QUOTE_CHAR = 34
'=============================== Object Header ================================
2a18: ac 03 08 01 ' 940 bytes, 8-1 methods, 1 object pointers
2a1c: 94 02 00 00 ' ptr #1 to $2cac: PUB Start (locals size: 0)
2a20: 9b 02 00 00 ' ptr #2 to $2cb3: PUB Valid (locals size: 0)
2a24: b7 02 00 00 ' ptr #3 to $2ccf: PUB Stop (locals size: 0)
2a28: c0 02 00 00 ' ptr #4 to $2cd8: PUB Write (locals size: 0)
2a2c: e6 02 00 00 ' ptr #5 to $2cfe: PUB Read (locals size: 0)
2a30: 0c 03 04 00 ' ptr #6 to $2d24: PUB Size (locals size: 4)
2a34: 41 03 00 00 ' ptr #7 to $2d59: PUB Setup (locals size: 0)
2a38: 4c 11 00 00 ' ptr #8 to $3b64: OBJ common : Catalina_Common.spin (VAR offset: 0)
'================================ DAT Section =================================
2a3c(0000):             '               org       0
2a3c(0000):             ' entry
2a3c(0000):             ' done
2a3c(0000): 00 18 fd a0 '               mov       t0,#0
2a40(0001): 91 18 3d 08 '               wrlong    t0,command
2a44(0002):             ' loop
2a44(0002): 91 18 bd 0a '               rdlong    t0,command wz           ' loop ...
2a48(0003): 02 00 68 5c '         if_z  jmp       #loop                   ' ... till ...
2a4c(0004): 93 18 3d 86 '               cmp       t0,response wz          ' ... we get ...
2a50(0005): 02 00 68 5c '         if_z  jmp       #loop                   ' ... a command
2a54(0006): 8c 1a bd a0 '               mov       t1,t0                   ' extract ...
2a58(0007): 90 1a bd 60 '               and       t1,low24                ' ... address argument
2a5c(0008): 1c 18 fd 28 '               shr       t0,#28                  ' extract command
2a60(0009): 01 18 7d 86 '               cmp       t0,#CMD_READ>>28 wz     ' do ...
2a64(000a): 13 00 68 5c '         if_z  jmp       #do_read                ' ... read
2a68(000b): 02 18 7d 86 '               cmp       t0,#CMD_WRITE>>28 wz    ' do ... 
2a6c(000c): 1b 00 68 5c '         if_z  jmp       #do_write               ' ... write               
2a70(000d): 03 18 7d 86 '               cmp       t0,#CMD_SIZE>>28 wz     ' do ...
2a74(000e): 2a 00 68 5c '         if_z  jmp       #do_size                ' ... size
2a78(000f): 04 18 7d 86 '               cmp       t0,#CMD_SETUP>>28 wz    ' do ...
2a7c(0010): 30 00 68 5c '         if_z  jmp       #do_setup               ' ... setup
2a80(0011):             ' identify        
2a80(0011): 91 26 3d 08 '               wrlong    response,command        ' otherwise return unlikely response ...
2a84(0012): 02 00 7c 5c '               jmp       #loop                   ' ... and loop till we get a known command
2a88(0013):             ' do_read
2a88(0013): 9b 2c fc 54 '               movd      rd_inst,#storage        ' read a copy ...                                
2a8c(0014): 98 18 bd a2 '               mov       t0,len wz               ' ... of ...                                
2a90(0015):             ' rd_loop                                         ' ... the ...                                  
2a90(0015): 00 00 68 5c '         if_z  jmp       #done                   ' ... string ...                                
2a94(0016): 8d 00 3c 08 ' rd_inst       wrlong    0-0,t1                  ' ... to ...                              
2a98(0017): 97 2c bc 80 '               add       rd_inst,d_inc           ' ... the ...                                 
2a9c(0018): 04 1a fd 80 '               add       t1,#4                   ' ... address ...                                   
2aa0(0019): 01 18 fd 86 '               sub       t0,#1 wz                ' ... provided ...                              
2aa4(001a): 15 00 7c 5c '               jmp       #rd_loop                ' ... (assume there is enough space!)
2aa8(001b):             ' do_write
2aa8(001b): 9b 3c fc 54 '               movd      wr_inst,#storage        ' write ...
2aac(001c): 00 30 fd a0 '               mov       len,#0                  ' ... a ...
2ab0(001d):             ' wr_loop                                         ' ... copy ...
2ab0(001d): 8d 1c bd 08 '               rdlong    t2,t1                   ' ... of ...
2ab4(001e): 8e 00 bc a0 ' wr_inst       mov       0-0,t2                  ' ... the ...
2ab8(001f): 97 3c bc 80 '               add       wr_inst,d_inc           ' ... string ...
2abc(0020): 04 1a fd 80 '               add       t1,#4                   ' ... to ...
2ac0(0021): 01 30 fd 80 '               add       len,#1                  ' ... cog ...
2ac4(0022): 2c 31 7d 86 '               cmp       len,#MAX_LONGS wz       ' ... RAM ...
2ac8(0023): 00 00 68 5c '         if_z  jmp       #done                   ' ... stopping ...
2acc(0024): 04 18 fd a0 '               mov       t0,#4                   ' ... when ... 
2ad0(0025): ff 1c 7d 62 ' wr_test       test      t2,#$FF wz              ' ... cog ...
2ad4(0026): 00 00 68 5c '       if_z    jmp       #done                   ' ... full ...
2ad8(0027): 08 1c fd 28 '               shr       t2,#8                   ' ... or ...
2adc(0028): 25 18 fd e4 '               djnz      t0,#wr_test             ' ... termination ... 
2ae0(0029): 1d 00 7c 5c '               jmp       #wr_loop                ' ... detected
2ae4(002a):             ' do_size
2ae4(002a): 90 1a 3d 86 '               cmp       t1,low24 wz             ' return ...
2ae8(002b): 02 00 54 5c '         if_nz jmp       #loop                   ' ... the ...                     
2aec(002c): 98 18 bd a0 '               mov       t0,len                  ' ... size (in LONGs) ...
2af0(002d): 92 18 bd 68 '               or        t0,size_cmd             ' ... of ...
2af4(002e): 91 18 3d 08 '               wrlong    t0,command              ' ... the stored ...
2af8(002f): 02 00 7c 5c '               jmp       #loop                   ' ... command line
2afc(0030):             ' do_setup                                        
2afc(0030): 77 30 7d ec '               tjz       len,#no_args            ' if no stored string, set argc/argv to default values
2b00(0031): 8d 1c bd a0 '               mov       t2,t1                   ' save the address argument
2b04(0032): 9b 6a fc 54 '               movd      su_inst,#storage        ' otherwise ...
2b08(0033): 98 18 bd a2 '               mov       t0,len wz               ' ... read ...
2b0c(0034):             ' su_loop                                         ' ... the ...             
2b0c(0034): 3a 00 68 5c '         if_z  jmp       #su_count_args          ' ... stored ...
2b10(0035): 8d 00 3c 08 ' su_inst       wrlong    0-0,t1                  ' ... string ...
2b14(0036): 97 6a bc 80 '               add       su_inst,d_inc           ' ... to ...
2b18(0037): 04 1a fd 80 '               add       t1,#4                   ' ... the ...
2b1c(0038): 01 18 fd 86 '               sub       t0,#1 wz                ' ... address ...
2b20(0039): 34 00 7c 5c '               jmp       #su_loop                ' ... provided (assume there is enough space!) 
2b24(003a):             ' su_count_args
2b24(003a): 8e 1a bd a0 '               mov       t1,t2                   ' count the number of arguments in the string
2b28(003b): 00 32 fd a0 '               mov       n,#0                    ' no arguments yet           
2b2c(003c): 00 34 fd a0 '               mov       q,#0                    ' not in a quoted string                                                    
2b30(003d):             ' su_count_loop
2b30(003d): 7c 00 fd 5c '               call      #skip_to_non_space      ' find next non-space
2b34(003e): 00 18 7d 86 '               cmp       t0,#0 wz                ' end of string?
2b38(003f): 43 00 68 5c '         if_z  jmp       #su_save_argc           ' yes - set up argc
2b3c(0040): 01 32 fd 80 '               add       n,#1                    ' no - found an argument
2b40(0041): 81 16 fd 5c '               call      #skip_to_space          ' skip to next space (i.e. end of argument)                            
2b44(0042): 3d 00 7c 5c '               jmp       #su_count_loop                         
2b48(0043):             ' su_save_argc
2b48(0043): 20 32 7d 87 '               cmp       n,#ARGV_MAX wz,wc       ' set up argc and first element of argv                                 
2b4c(0044): 20 32 c5 a0 '         if_a  mov       n,#ARGV_MAX             '                                    
2b50(0045): 94 32 3d 04 '               wrword    n,argc                  ' word[common#ARGC_ADDR] := n                                              
2b54(0046): 95 2c 3d 04 '               wrword    argv_start,argv         ' word[common#ARGV_ADDR] := argv_0                               
2b58(0047): 8e 1a bd a0 '               mov       t1,t2      
2b5c(0048): 7c 00 fd 5c '               call      #skip_to_non_space      ' find start of first argument ...
2b60(0049): 96 1e bd a0 '               mov       t3,argv_start           ' ... and save it ...                                
2b64(004a): 8f 1a 3d 08 '               wrlong    t1,t3                   ' ... in long[common#ARGV_0] 
2b68(004b): 00 34 fd a0 '               mov       q,#0                    ' not currently within quoted string
2b6c(004c):             ' su_argv_loop
2b6c(004c): 8d 18 bd 02 '               rdbyte    t0,t1 wz                ' deconstruct command line, creating the argv array as we go                 
2b70(004d): 73 00 68 5c '         if_z  jmp       #su_argv_done           ' end of string found - terminate the argv array                                                                    
2b74(004e): 22 18 7d 86 '               cmp       t0,#QUOTE_CHAR wz       ' found a quote?                                                            
2b78(004f): 62 00 54 5c '         if_nz jmp       #su_argv_notquote       ' no - just copy character (or terminate argument of it is a space)
2b7c(0050): 01 34 fd 6e '               xor       q,#1 wz                 ' yes - toggle marker indicating we are within quoted string
2b80(0051): 71 00 54 5c '         if_nz jmp       #su_argv_nextchar       ' if this is the start of a quoted string, just keep processing
2b84(0052): 8d 18 bd a0 '               mov       t0,t1                   ' otherwise, is the end ...
2b88(0053): 01 18 fd 80 '               add       t0,#1                   ' ... of the quoted string ...
2b8c(0054): 8c 18 bd 02 '               rdbyte    t0,t0 wz                ' ... also ... 
2b90(0055): 58 00 68 5c '         if_z  jmp       #su_argv_chkquote       ' ... the end ...
2b94(0056): 20 18 7d 86 '               cmp       t0,#" " wz              ' ... of the argument?
2b98(0057): 71 00 54 5c '         if_nz jmp       #su_argv_nextchar       ' no - just keep processing 
2b9c(0058):             ' su_argv_chkquote
2b9c(0058): 8f 18 bd 08 '               rdlong    t0,t3                   ' yes - is there a quote ...
2ba0(0059): 8c 18 bd 00 '               rdbyte    t0,t0                   ' ... at the start ...
2ba4(005a): 22 18 7d 86 '               cmp       t0,#QUOTE_CHAR wz       ' ... of the argument?
2ba8(005b): 5e 00 68 5c '         if_z  jmp       #su_argv_delquote       ' yes - delete the start and end quotes 
2bac(005c): 01 1a fd 80 '               add       t1,#1                   ' no - do not delete the start or end quotes ...
2bb0(005d): 65 00 7c 5c '               jmp       #su_argv_nextarg        ' ... just save the argument        
2bb4(005e):             ' su_argv_delquote             
2bb4(005e): 8f 18 bd 08 '               rdlong    t0,t3                   ' remove quote ...
2bb8(005f): 01 18 fd 80 '               add       t0,#1                   ' ... from start ...     
2bbc(0060): 8f 18 3d 08 '               wrlong    t0,t3                   ' ... of string
2bc0(0061): 65 00 7c 5c '               jmp       #su_argv_nextarg        ' save next argument
2bc4(0062):             ' su_argv_notquote                                 
2bc4(0062): 20 18 7d 86 '               cmp       t0,#" " wz              ' found a space?              
2bc8(0063): 71 00 54 5c '         if_nz jmp       #su_argv_nextchar       ' no - just keep processing                                       
2bcc(0064): 71 34 7d e8 '               tjnz      q,#su_argv_nextchar     ' yes - are we within a quote? If yes, just keep processing
2bd0(0065):             ' su_argv_nextarg              
2bd0(0065): 01 32 fd 80 '               add       n,#1                    ' no - found the end of an argument                                       
2bd4(0066): 20 32 7d 87 '               cmp       n,#ARGV_MAX wz,wc       ' too many arguments?                                      
2bd8(0067): 73 00 4c 5c '         if_ae jmp       #su_argv_done           ' yes - just terminate argv array                                       
2bdc(0068): 00 18 fd a0 '               mov       t0,#0                   ' no - zero terminate ...
2be0(0069): 8d 18 3d 00 '               wrbyte    t0,t1                   ' ... the current argument                                          
2be4(006a): 01 1a fd 80 '               add       t1,#1                   ' find the start ...    
2be8(006b): 7c 00 fd 5c '               call      #skip_to_non_space      ' ... of the next argument
2bec(006c): 8d 18 bd 02 '               rdbyte    t0,t1 wz                ' end of string?
2bf0(006d): 73 00 68 5c '         if_z  jmp       #su_argv_done           ' yes - terminate qrgv array
2bf4(006e): 04 1e fd 80 '               add       t3,#4                   ' no - save new pointer ...          
2bf8(006f): 8f 1a 3d 08 '               wrlong    t1,t3                   ' ... in the argv array          
2bfc(0070): 4c 00 7c 5c '               jmp       #su_argv_loop           ' ... and keep processing
2c00(0071):             ' su_argv_nextchar        
2c00(0071): 01 1a fd 80 '               add       t1,#1                   '  process ...              
2c04(0072): 4c 00 7c 5c '               jmp       #su_argv_loop           '  ... the next character          
2c08(0073):             ' su_argv_done                                                        
2c08(0073): 04 1e fd 80 '               add       t3,#4                   '   ' terminate argv array with a null entry   
2c0c(0074): 00 18 fd a0 '               mov       t0,#0                   '   long[b] := 0                               
2c10(0075): 8f 18 3d 08 '               wrlong    t0,t3                   '                                              
2c14(0076): 00 00 7c 5c '               jmp       #done                   '   
2c18(0077):             ' no_args                                         ' 
2c18(0077): 00 18 fd a0 '               mov       t0,#0                   ' if no stored string ...   
2c1c(0078): 94 18 3d 04 '               wrword    t0,argc                 ' ... set argc ...                    
2c20(0079): 96 18 3d 08 '               wrlong    t0,argv_start           ' ... and argv_0 to zero                 
2c24(007a): 95 2c 3d 04 '               wrword    argv_start,argv         ' set argv to argv_0          
2c28(007b): 00 00 7c 5c '               jmp       #done                   
2c2c(007c):             ' skip_to_non_space
2c2c(007c): 8d 18 bd 00 '               rdbyte    t0,t1
2c30(007d): 20 18 7d 86 '               cmp       t0,#" " wz
2c34(007e): 01 1a e9 80 '         if_z  add       t1,#1     
2c38(007f): 7c 00 68 5c '         if_z  jmp       #skip_to_non_space          
2c3c(0080):             ' skip_to_non_space_ret
2c3c(0080): 00 00 7c 5c '               ret
2c40(0081):             ' skip_to_space
2c40(0081): 8d 18 bd 02 '               rdbyte    t0,t1 wz
2c44(0082): 8b 00 68 5c '         if_z  jmp       #skip_to_space_ret
2c48(0083): 22 18 7d 86 '               cmp       t0,#QUOTE_CHAR wz
2c4c(0084): 01 34 e9 6c '         if_z  xor       q,#1
2c50(0085): 89 00 68 5c '         if_z  jmp       #:skip_char
2c54(0086): 20 18 7d 86 '               cmp       t0,#" " wz
2c58(0087): 89 00 54 5c '         if_nz jmp       #:skip_char
2c5c(0088): 8b 34 7d ec '               tjz       q,#skip_to_space_ret
2c60(0089):             ' :skip_char              
2c60(0089): 01 1a fd 80 '               add       t1,#1
2c64(008a): 81 00 7c 5c '               jmp       #skip_to_space          
2c68(008b):             ' skip_to_space_ret
2c68(008b): 00 00 7c 5c '               ret
2c6c(008c): 00 00 00 00 ' t0            long      0
2c70(008d): 00 00 00 00 ' t1            long      0
2c74(008e): 00 00 00 00 ' t2            long      0
2c78(008f): 00 00 00 00 ' t3            long      0
2c7c(0090): ff ff ff 00 ' low24         long      $FFFFFF
2c80(0091): fc 7e 00 00 ' command       long      COGSTORE   
2c84(0092): 00 00 00 30 ' size_cmd      long      CMD_SIZE
2c88(0093): ce fa ed fe ' response      long      CMD_RESPONSE
2c8c(0094): 30 7f 00 00 ' argc          long      ARGC_ADDR
2c90(0095): 32 7f 00 00 ' argv          long      ARGV_ADDR
2c94(0096): 34 7f 00 00 ' argv_start    long      ARGV_0
2c98(0097): 00 02 00 00 ' d_inc         long      1<<9
2c9c(0098): 00 00 00 00 ' len           long      0                       ' storage used (longs)
2ca0(0099): 00 00 00 00 ' n             long      0
2ca4(009a): 00 00 00 00 ' q             long      0
2ca8(009b): 00 00 00 00 ' storage       long      0                       ' long storage starts here      
'=========================== Method #1: PUB Start =============================
'PUB Start
'------------------------------------------------------------------------------
  coginit(7, @entry, 0)
'------------------------------------------------------------------------------
2cac: 37 22          PUSH#kp	7 ($7)
2cae: c7 24          PUSH#.L	OBJ+36
2cb0: 35             PUSH#0	
2cb1: 2c             COGISUB	
2cb2: 32             RETURN	
'=========================== Method #2: PUB Valid =============================
'PUB Valid : ok
'------------------------------------------------------------------------------
  long[COGSTORE] := -1 ' any invalid command
'------------------------------------------------------------------------------
2cb3: 34             PUSH#-1	
2cb4: 39 7e fc       PUSH#k2	32508
2cb7: c1             POP.L	Mem[]
'------------------------------------------------------------------------------
  repeat 100
'------------------------------------------------------------------------------
2cb8: 38 64          PUSH#k1	100
2cba: 08 10          LOOPJPF	.+16 (dest:$2ccc)
'------------------------------------------------------------------------------
    if long[COGSTORE] == CMD_RESPONSE
'------------------------------------------------------------------------------
2cbc: 39 7e fc       PUSH#k2	32508
2cbf: c0             PUSH.L	Mem[]
2cc0: 3b fe ed fa ce PUSH#k4	-17958194
2cc5: fc             EQ   	
2cc6: 0a 02          JPF  	.+2 (dest:$2cca)
'------------------------------------------------------------------------------
      return -1
'------------------------------------------------------------------------------
2cc8: 34             PUSH#-1	
2cc9: 33             RETVAL	
2cca: 09 70          LOOPRPT	.-16 (dest:$2cbc)
'------------------------------------------------------------------------------
  return 0
'------------------------------------------------------------------------------
2ccc: 35             PUSH#0	
2ccd: 33             RETVAL	
2cce: 32             RETURN	
'============================ Method #3: PUB Stop =============================
'PUB Stop
'------------------------------------------------------------------------------
  if Valid
'------------------------------------------------------------------------------
2ccf: 00             FRAME	Call with return value	
2cd0: 05 02          CALL 	+2 
2cd2: 0a 03          JPF  	.+3 (dest:$2cd7)
'------------------------------------------------------------------------------
    cogstop(7)
'------------------------------------------------------------------------------
2cd4: 37 22          PUSH#kp	7 ($7)
2cd6: 21             COGSTOP	
2cd7: 32             RETURN	
'=========================== Method #4: PUB Write =============================
'PUB Write(Addr) : ok
'------------------------------------------------------------------------------
  if Valid
'------------------------------------------------------------------------------
2cd8: 00             FRAME	Call with return value	
2cd9: 05 02          CALL 	+2 
2cdb: 0a 1e          JPF  	.+30 (dest:$2cfb)
'------------------------------------------------------------------------------
    long[COGSTORE] := CMD_WRITE | Addr
'------------------------------------------------------------------------------
2cdd: 37 1c          PUSH#kp	536870912 ($20000000)
2cdf: 64             PUSH 	Locals+4
2ce0: ea             BIT_OR	
2ce1: 39 7e fc       PUSH#k2	32508
2ce4: c1             POP.L	Mem[]
'------------------------------------------------------------------------------
    repeat 100000
'------------------------------------------------------------------------------
2ce5: 3a 01 86 a0    PUSH#k3	100000
2ce9: 08 0c          LOOPJPF	.+12 (dest:$2cf7)
'------------------------------------------------------------------------------
      if long[COGSTORE] == 0
'------------------------------------------------------------------------------
2ceb: 39 7e fc       PUSH#k2	32508
2cee: c0             PUSH.L	Mem[]
2cef: 35             PUSH#0	
2cf0: fc             EQ   	
2cf1: 0a 02          JPF  	.+2 (dest:$2cf5)
'------------------------------------------------------------------------------
        return -1
'------------------------------------------------------------------------------
2cf3: 34             PUSH#-1	
2cf4: 33             RETVAL	
2cf5: 09 74          LOOPRPT	.-12 (dest:$2ceb)
'------------------------------------------------------------------------------
    return 0
'------------------------------------------------------------------------------
2cf7: 35             PUSH#0	
2cf8: 33             RETVAL	
'------------------------------------------------------------------------------
  else
'------------------------------------------------------------------------------
2cf9: 04 02          GOTO 	.+2 (dest:$2cfd)
'------------------------------------------------------------------------------
    return 0
'------------------------------------------------------------------------------
2cfb: 35             PUSH#0	
2cfc: 33             RETVAL	
2cfd: 32             RETURN	
'============================ Method #5: PUB Read =============================
'PUB Read(Addr) : ok
'------------------------------------------------------------------------------
  if Valid
'------------------------------------------------------------------------------
2cfe: 00             FRAME	Call with return value	
2cff: 05 02          CALL 	+2 
2d01: 0a 1e          JPF  	.+30 (dest:$2d21)
'------------------------------------------------------------------------------
    long[COGSTORE] := CMD_READ | Addr
'------------------------------------------------------------------------------
2d03: 37 1b          PUSH#kp	268435456 ($10000000)
2d05: 64             PUSH 	Locals+4
2d06: ea             BIT_OR	
2d07: 39 7e fc       PUSH#k2	32508
2d0a: c1             POP.L	Mem[]
'------------------------------------------------------------------------------
    repeat 100000
'------------------------------------------------------------------------------
2d0b: 3a 01 86 a0    PUSH#k3	100000
2d0f: 08 0c          LOOPJPF	.+12 (dest:$2d1d)
'------------------------------------------------------------------------------
      if long[COGSTORE] == 0
'------------------------------------------------------------------------------
2d11: 39 7e fc       PUSH#k2	32508
2d14: c0             PUSH.L	Mem[]
2d15: 35             PUSH#0	
2d16: fc             EQ   	
2d17: 0a 02          JPF  	.+2 (dest:$2d1b)
'------------------------------------------------------------------------------
        return -1
'------------------------------------------------------------------------------
2d19: 34             PUSH#-1	
2d1a: 33             RETVAL	
2d1b: 09 74          LOOPRPT	.-12 (dest:$2d11)
'------------------------------------------------------------------------------
    return 0
'------------------------------------------------------------------------------
2d1d: 35             PUSH#0	
2d1e: 33             RETVAL	
'------------------------------------------------------------------------------
  else
'------------------------------------------------------------------------------
2d1f: 04 02          GOTO 	.+2 (dest:$2d23)
'------------------------------------------------------------------------------
    return 0
'------------------------------------------------------------------------------
2d21: 35             PUSH#0	
2d22: 33             RETVAL	
2d23: 32             RETURN	
'============================ Method #6: PUB Size =============================
'PUB Size | s
'------------------------------------------------------------------------------
  if not Valid
'------------------------------------------------------------------------------
2d24: 00             FRAME	Call with return value	
2d25: 05 02          CALL 	+2 
2d27: ff             LOG_NOT	
2d28: 0a 02          JPF  	.+2 (dest:$2d2c)
'------------------------------------------------------------------------------
    return -1
'------------------------------------------------------------------------------
2d2a: 34             PUSH#-1	
2d2b: 33             RETVAL	
'------------------------------------------------------------------------------
  long[COGSTORE] := CMD_SIZE | $FFFFFF 
'------------------------------------------------------------------------------
2d2c: 3b 30 00 00 00 PUSH#k4	805306368
2d31: 37 37          PUSH#kp	16777215 ($ffffff)
2d33: ea             BIT_OR	
2d34: 39 7e fc       PUSH#k2	32508
2d37: c1             POP.L	Mem[]
'------------------------------------------------------------------------------
  repeat 100
'------------------------------------------------------------------------------
2d38: 38 64          PUSH#k1	100
2d3a: 08 19          LOOPJPF	.+25 (dest:$2d55)
'------------------------------------------------------------------------------
    if long[COGSTORE] <> CMD_SIZE | $FFFFFF
'------------------------------------------------------------------------------
2d3c: 39 7e fc       PUSH#k2	32508
2d3f: c0             PUSH.L	Mem[]
2d40: 3b 30 00 00 00 PUSH#k4	805306368
2d45: 37 37          PUSH#kp	16777215 ($ffffff)
2d47: ea             BIT_OR	
2d48: fb             NE   	
2d49: 0a 08          JPF  	.+8 (dest:$2d53)
'------------------------------------------------------------------------------
      return long[COGSTORE] & $FFFFFF
'------------------------------------------------------------------------------
2d4b: 39 7e fc       PUSH#k2	32508
2d4e: c0             PUSH.L	Mem[]
2d4f: 37 37          PUSH#kp	16777215 ($ffffff)
2d51: e8             BIT_AND	
2d52: 33             RETVAL	
2d53: 09 67          LOOPRPT	.-25 (dest:$2d3c)
'------------------------------------------------------------------------------
  return -2
'------------------------------------------------------------------------------
2d55: 37 60          PUSH#kp	-2 ($fffffffe)
2d57: 33             RETVAL	
2d58: 32             RETURN	
'=========================== Method #7: PUB Setup =============================
'PUB Setup(addr) : i
'------------------------------------------------------------------------------
  word[ARGC_ADDR] := 0
'------------------------------------------------------------------------------
2d59: 35             PUSH#0	
2d5a: 39 7f 30       PUSH#k2	32560
2d5d: a1             POP.W	Mem[]
'------------------------------------------------------------------------------
  word[ARGV_ADDR] := 0
'------------------------------------------------------------------------------
2d5e: 35             PUSH#0	
2d5f: 39 7f 32       PUSH#k2	32562
2d62: a1             POP.W	Mem[]
'------------------------------------------------------------------------------
  repeat i from 0 to ARGV_MAX-1
'------------------------------------------------------------------------------
2d63: 35             PUSH#0	
2d64: 61             POP  	Locals+0
'------------------------------------------------------------------------------
    long[ARGV_0][i] := 0
'------------------------------------------------------------------------------
2d65: 35             PUSH#0	
2d66: 39 7f 34       PUSH#k2	32564
2d69: 60             PUSH 	Locals+0
2d6a: d1             POP.L	Mem[][]
2d6b: 35             PUSH#0	
2d6c: 37 04          PUSH#kp	32 ($20)
2d6e: 36             PUSH#1	
2d6f: ed             SUB  	
2d70: 62 02 72       USING	Locals+0, RPTINCJ .-14 (dest:$2d65)
'------------------------------------------------------------------------------
  if not Valid
'------------------------------------------------------------------------------
2d73: 00             FRAME	Call with return value	
2d74: 05 02          CALL 	+2 
2d76: ff             LOG_NOT	
2d77: 0a 2c          JPF  	.+44 (dest:$2da5)
'------------------------------------------------------------------------------
    word[ARGC_ADDR] := 1
'------------------------------------------------------------------------------
2d79: 36             PUSH#1	
2d7a: 39 7f 30       PUSH#k2	32560
2d7d: a1             POP.W	Mem[]
'------------------------------------------------------------------------------
    word[ARGV_ADDR] := ARGV_0
'------------------------------------------------------------------------------
2d7e: 39 7f 34       PUSH#k2	32564
2d81: 39 7f 32       PUSH#k2	32562
2d84: a1             POP.W	Mem[]
'------------------------------------------------------------------------------
    long[ARGV_0] := ARGV_0 + 4*(ARGV_MAX-2)
'------------------------------------------------------------------------------
2d85: 39 7f 34       PUSH#k2	32564
2d88: 37 01          PUSH#kp	4 ($4)
2d8a: 37 04          PUSH#kp	32 ($20)
2d8c: 37 00          PUSH#kp	2 ($2)
2d8e: ed             SUB  	
2d8f: f4             MPY  	
2d90: ec             ADD  	
2d91: 39 7f 34       PUSH#k2	32564
2d94: c1             POP.L	Mem[]
'------------------------------------------------------------------------------
    long[ARGV_0][ARGV_MAX-2] := $6C6C756E ' null
'------------------------------------------------------------------------------
2d95: 3b 6c 6c 75 6e PUSH#k4	1819047278
2d9a: 39 7f 34       PUSH#k2	32564
2d9d: 37 04          PUSH#kp	32 ($20)
2d9f: 37 00          PUSH#kp	2 ($2)
2da1: ed             SUB  	
2da2: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  else
'------------------------------------------------------------------------------
2da3: 04 1c          GOTO 	.+28 (dest:$2dc1)
'------------------------------------------------------------------------------
    long[COGSTORE] := CMD_SETUP | Addr
'------------------------------------------------------------------------------
2da5: 37 1d          PUSH#kp	1073741824 ($40000000)
2da7: 64             PUSH 	Locals+4
2da8: ea             BIT_OR	
2da9: 39 7e fc       PUSH#k2	32508
2dac: c1             POP.L	Mem[]
'------------------------------------------------------------------------------
    repeat 100000
'------------------------------------------------------------------------------
2dad: 3a 01 86 a0    PUSH#k3	100000
2db1: 08 0c          LOOPJPF	.+12 (dest:$2dbf)
'------------------------------------------------------------------------------
      if long[COGSTORE] == 0
'------------------------------------------------------------------------------
2db3: 39 7e fc       PUSH#k2	32508
2db6: c0             PUSH.L	Mem[]
2db7: 35             PUSH#0	
2db8: fc             EQ   	
2db9: 0a 02          JPF  	.+2 (dest:$2dbd)
'------------------------------------------------------------------------------
        return -1
'------------------------------------------------------------------------------
2dbb: 34             PUSH#-1	
2dbc: 33             RETVAL	
2dbd: 09 74          LOOPRPT	.-12 (dest:$2db3)
'------------------------------------------------------------------------------
    return 0
'------------------------------------------------------------------------------
2dbf: 35             PUSH#0	
2dc0: 33             RETVAL	
2dc1: 32             RETURN	
2dc2: 00 00       

'******************************************************************************
'                              Catalina_LMM.spin                               
'******************************************************************************

'=================================== CONs =====================================
SignFlag = 1
ZeroFlag = 2
NaNFlag = 8
'=============================== Object Header ================================
2dc4: a8 07 03 00 ' 1960 bytes, 3-1 methods, 0 object pointers
2dc8: 88 07 00 00 ' ptr #1 to $354c: PUB Entry_Addr (locals size: 0)
2dcc: 8c 07 00 00 ' ptr #2 to $3550: PUB Run (locals size: 0)
'================================ DAT Section =================================
2dd0(0000):             '  org 0
2dd0(0000):             ' entry
2dd0(0000): 02 00 7c 5c '    jmp #INIT            '$00
2dd4(0001): 02 00 7c 5c '    jmp #INIT            '$01 remove this line when using POD, since it
2dd8(0002): 53 00 7c 5c ' INIT    jmp #lmm_init   '$02
2ddc(0003): 81 00 7c 5c ' LODL    jmp #load_l     '$03
2de0(0004): 83 00 7c 5c ' LODA    jmp #load_a     '$04
2de4(0005): 85 00 7c 5c ' LODF    jmp #fp_ind     '$05
2de8(0006): 88 00 7c 5c ' PSHL    jmp #push_l     '$06
2dec(0007): a9 00 7c 5c ' PSHB    jmp #push_b     '$07
2df0(0008): b1 00 7c 5c ' CPYB    jmp #copy_b     '$08
2df4(0009): be 00 7c 5c ' NEWF    jmp #new_fp     '$09
2df8(000a): c4 00 7c 5c ' RETF    jmp #fp_ret     '$0a
2dfc(000b): c9 00 7c 5c ' CALA    jmp #f_call     '$0b
2e00(000c): c6 00 7c 5c ' RETN    jmp #f_ret      '$0c
2e04(000d): cb 00 7c 5c ' CALI    jmp #f_cali     '$0d
2e08(000e): ce 00 7c 5c ' JMPA    jmp #f_jump     '$0e
2e0c(000f): d0 00 7c 5c ' JMPI    jmp #f_jmpi     '$0f
2e10(0010): de 00 7c 5c ' DIVS    jmp #f_d32s     '$10
2e14(0011): f0 00 7c 5c ' DIVU    jmp #f_d32u     '$11
2e18(0012): fc 00 7c 5c ' MULT    jmp #f_m32      '$12
2e1c(0013): 06 01 7c 5c ' BR_Z    jmp #bra_z      '$13
2e20(0014): 08 01 7c 5c ' BRNZ    jmp #bra_nz     '$14
2e24(0015): 0a 01 7c 5c ' BRAE    jmp #bra_ae     '$15
2e28(0016): 0c 01 7c 5c ' BR_A    jmp #bra_a      '$16
2e2c(0017): 0e 01 7c 5c ' BRBE    jmp #bra_be     '$17
2e30(0018): 10 01 7c 5c ' BR_B    jmp #bra_b      '$18
2e34(0019): 12 01 7c 5c ' SYSP    jmp #plugin     '$19
2e38(001a): 8b 00 7c 5c ' PSHA    jmp #push_a     '$1a
2e3c(001b): 32 01 7c 5c ' FADD    jmp #flt_add    '$1b
2e40(001c): 31 01 7c 5c ' FSUB    jmp #flt_sub    '$1c
2e44(001d): 47 01 7c 5c ' FMUL    jmp #flt_mul    '$1d
2e48(001e): 56 01 7c 5c ' FDIV    jmp #flt_div    '$1e
2e4c(001f): 82 01 7c 5c ' FCMP    jmp #flt_cmp    '$1f
2e50(0020): 66 01 7c 5c ' FLIN    jmp #flt_int    '$20
2e54(0021): 73 01 7c 5c ' INFL    jmp #int_flt    '$21
2e58(0022): 93 00 7c 5c ' PSHM    jmp #push_m     '$22
2e5c(0023): 9e 00 7c 5c ' POPM    jmp #pop_m      '$23
2e60(0024): 8d 00 7c 5c ' PSHF    jmp #push_i     '$24
2e64(0025): d2 00 7c 5c ' RLNG    jmp #rd_long    '$25
2e68(0026): d4 00 7c 5c ' RWRD    jmp #rd_word    '$26
2e6c(0027): d6 00 7c 5c ' RBYT    jmp #rd_byte    '$27
2e70(0028): d8 00 7c 5c ' WLNG    jmp #wr_long    '$28
2e74(0029): da 00 7c 5c ' WWRD    jmp #wr_word    '$29
2e78(002a): dc 00 7c 5c ' WBYT    jmp #wr_byte    '$2a
2e7c(002b): 00 00 00 00 ' PC      long 0          '$2b
2e80(002c): 00 00 00 00 ' SP      long 0          '$2c
2e84(002d): 00 00 00 00 ' FP      long 0          '$2d
2e88(002e): 00 00 00 00 ' RI      long 0          '$2e
2e8c(002f): 00 00 00 00 ' BC      long 0          '$2f
2e90(0030): 00 00 00 00 ' BA      long 0          '$30
2e94(0031): 00 00 00 00 ' BZ      long 0          '$31
2e98(0032): 00 00 00 00 ' CS      long 0          '$32
2e9c(0033): 00 00 00 00 ' r0      long 0          '$33
2ea0(0034): 00 00 00 00 ' r1      long 0          '$34
2ea4(0035): 00 00 00 00 ' r2      long 0          '$35
2ea8(0036): 00 00 00 00 ' r3      long 0          '$36
2eac(0037): 00 00 00 00 ' r4      long 0          '$37
2eb0(0038): 00 00 00 00 ' r5      long 0          '$38
2eb4(0039): 00 00 00 00 ' r6      long 0          '$39
2eb8(003a): 00 00 00 00 ' r7      long 0          '$3a
2ebc(003b): 00 00 00 00 ' r8      long 0          '$3b
2ec0(003c): 00 00 00 00 ' r9      long 0          '$3c
2ec4(003d): 00 00 00 00 ' r10     long 0          '$3d
2ec8(003e): 00 00 00 00 ' r11     long 0          '$3e
2ecc(003f): 00 00 00 00 ' r12     long 0          '$3f
2ed0(0040): 00 00 00 00 ' r13     long 0          '$40
2ed4(0041): 00 00 00 00 ' r14     long 0          '$41
2ed8(0042): 00 00 00 00 ' r15     long 0          '$42
2edc(0043): 00 00 00 00 ' r16     long 0          '$43
2ee0(0044): 00 00 00 00 ' r17     long 0          '$44
2ee4(0045): 00 00 00 00 ' r18     long 0          '$45
2ee8(0046): 00 00 00 00 ' r19     long 0          '$46
2eec(0047): 00 00 00 00 ' r20     long 0          '$47
2ef0(0048): 00 00 00 00 ' r21     long 0          '$48
2ef4(0049): 00 00 00 00 ' r22     long 0          '$49
2ef8(004a): 00 00 00 00 ' r23     long 0          '$4a
2efc(004b): 00 00 00 80 ' Bit31   long  $80000000 '$4b
2f00(004c): ff ff ff ff ' all_1s  long  $ffffffff '$4c
2f04(004d): ff 00 00 00 ' cviu_m1 long  $000000ff '$4d
2f08(004e): ff ff 00 00 ' cviu_m2 long  $0000ffff '$4e
2f0c(004f): 00 00 00 ff ' top8    long  $ff000000 '$4f   ' top 8 bits bitmask
2f10(0050): ff ff ff 00 ' low24   long  $00ffffff '$50   ' low 24 bits bitmask
2f14(0051): 00 00 00 00 ' init_BZ long  $00000000 '$51   ' end of code / start of heap
2f18(0052): 00 00 00 00 ' init_PC long  $00000000 '$52   ' the initial PC
2f1c(0053):             ' lmm_init
2f1c(0053): 01 66 fc 0c '         cogid   r0              '1 convert ...
2f20(0054): 02 66 fc 2c '         shl     r0,#2           '2 ... my cog id ...
2f24(0055): f0 67 bc 80 '         add     r0,par          '3 ... to my registration addr
2f28(0056): 33 66 bc 08 '         rdlong  r0,r0           '4 get my request block addr
2f2c(0057):             ' wait
2f2c(0057): 33 60 bc 0a '         rdlong  BA,r0 wz        '5 Wait till we are given the base address ...
2f30(0058): 57 00 68 5c '   if_z  jmp     #wait           '6 .. (required to relocate segments)
2f34(0059): 04 66 fc 80 '         add     r0,#4           '7 Load our initial SP ...
2f38(005a): 33 58 bc 08 '         rdlong  SP,r0           '8 ... from the request block
2f3c(005b): 4c 63 fc a0 '         mov     BZ,#init_BZ<<2+8 '9 calculate ...
2f40(005c): 30 62 bc 80 '         add     BZ,BA           '10 ... pointer to initial BZ
2f44(005d): 31 56 bc a0 '         mov     PC,BZ           '11 load ...
2f48(005e): 04 56 fc 80 '         add     PC,#4           '12 ... initial  ...
2f4c(005f): 2b 56 bc 08 '         rdlong  PC,PC           '13 ... PC and ...
2f50(0060): 31 62 bc 08 '         rdlong  BZ,BZ           '14 ... BZ and ...
2f54(0061): 72 00 fd 5c '         call    #Reloc          '15 ... relocate segments 
2f58(0062): 65 00 7c 5c '         jmp     #LMM_loop       '16 we can now start executing LMM code
2f5c(0063): 00 00 00 00 '         nop                     '17
2f60(0064):             ' LMM_next
2f60(0064): 04 56 fc 80 '         add    PC,#4
2f64(0065):             ' LMM_loop
2f64(0065): 2b ce bc 08 '         rdlong LMM_1,PC
2f68(0066): 04 56 fc 80 '         add    PC,#4
2f6c(0067):             ' LMM_1
2f6c(0067): 00 00 00 00 '         nop
2f70(0068): 2b d4 bc 08 '         rdlong LMM_2,PC
2f74(0069): 04 56 fc 80 '         add    PC,#4
2f78(006a):             ' LMM_2
2f78(006a): 00 00 00 00 '         nop
2f7c(006b): 2b da bc 08 '         rdlong LMM_3,PC
2f80(006c): 04 56 fc 80 '         add    PC,#4
2f84(006d):             ' LMM_3
2f84(006d): 00 00 00 00 '         nop
2f88(006e): 2b e0 bc 08 '         rdlong LMM_4,PC
2f8c(006f): 04 56 fc 80 '         add    PC,#4
2f90(0070):             ' LMM_4
2f90(0070): 00 00 00 00 '         nop
2f94(0071): 65 00 7c 5c '         jmp    #LMM_loop
2f98(0072):             ' Reloc
2f98(0072): 31 5e bc a0 '         mov   BC,BZ         ' length of data to be relocated
2f9c(0073): 03 5e fc 80 '         add   BC,#3         ' round up ...
2fa0(0074): 03 5e fc 64 '         andn  BC,#3         ' ... to a multiple of 4 bytes
2fa4(0075): 10 5e fc 84 '         sub   BC,#$10       ' omit first 16 bytes
2fa8(0076): 10 b6 ff a0 '         mov   t2,#$10       ' destination is byte 16
2fac(0077): 30 b4 bf a0 '         mov   t1,BA         ' source is BA ...
2fb0(0078): 10 b4 ff 80 '         add   t1,#$10       ' ... plus 16 bytes 
2fb4(0079):             ' reloc_loop
2fb4(0079): 80 5e 7c ec '        tjz    BC,#Reloc_ret ' no more to copy
2fb8(007a): da b9 bf 08 '        rdlong t3,t1         ' read from src to t3
2fbc(007b): db b9 3f 08 '        wrlong t3,t2         ' write t3 to dst
2fc0(007c): 04 b4 ff 80 '        add    t1,#4         ' increment source
2fc4(007d): 04 b6 ff 80 '        add    t2,#4         ' increment destination
2fc8(007e): 04 5e fc 84 '        sub    BC,#4         ' decrement count ...
2fcc(007f): 79 00 7c 5c '        jmp    #reloc_loop   ' ... and keep copying
2fd0(0080):             ' Reloc_ret
2fd0(0080): 00 00 7c 5c '        ret        
2fd4(0081):             ' load_l
2fd4(0081): 2b 5c bc 08 '        rdlong RI,PC         ' load the long value
2fd8(0082): 64 00 7c 5c '        jmp    #LMM_next     ' increment PC, execute next instruction
2fdc(0083):             ' load_a
2fdc(0083): 2b 5c bc 08 '        rdlong RI,PC         ' load the address
2fe0(0084): 64 00 7c 5c '        jmp    #LMM_next     ' increment PC, execute next instruction
2fe4(0085):             ' fp_ind
2fe4(0085): 2b 5c bc 08 '        rdlong RI,PC         ' load the long value
2fe8(0086): 2d 5c bc d0 '        adds   RI,FP         ' add the frame pointer
2fec(0087): 64 00 7c 5c '        jmp    #LMM_next     ' increment PC, execute next instruction
2ff0(0088):             ' push_l
2ff0(0088): 04 58 fc 84 '        sub    SP,#4         ' decrement SP
2ff4(0089): 2c 5c 3c 08 '        wrlong RI,SP         ' save value on stack
2ff8(008a): 65 00 7c 5c '        jmp    #LMM_loop     ' increment PC, execute next instruction
2ffc(008b):             ' push_a
2ffc(008b): 2b 5c bc 08 '        rdlong RI,PC         ' load the address
3000(008c): 8f 00 7c 5c '        jmp    #push_x       ' use the result as an address of the value to push
3004(008d):             ' push_i
3004(008d): 2b 5c bc 08 '        rdlong RI,PC         ' load the long value
3008(008e): 2d 5c bc d0 '        adds   RI,FP         ' add the frame pointer
300c(008f):             ' push_x
300c(008f): 2e 5c bc 08 '        rdlong RI,RI         ' read the value at that address
3010(0090): 04 58 fc 84 '        sub    SP,#4         ' decrement SP
3014(0091): 2c 5c 3c 08 '        wrlong RI,SP         ' save value on stack
3018(0092): 64 00 7c 5c '        jmp    #LMM_next     ' increment PC, execute next instruction
301c(0093):             ' push_m
301c(0093): 2b 5c bc 08 '        rdlong RI,PC         ' load the long value specifying the registers to push
3020(0094): 39 32 fd 54 '        movd   :push_x,#r6   ' start with ...
3024(0095): 06 5c fc 28 '        shr    RI,#6         ' ... r6
3028(0096): 12 b4 ff a0 '        mov    t1,#18        ' we will push up to 18 registers (up to R24)
302c(0097):             ' :push_nxt
302c(0097): 01 5c fc 2b '        shr    RI,#1 wc,wz   ' save rx?
3030(0098): 04 58 f0 84 '  if_c  sub    SP,#4         ' if so ...
3034(0099):             ' :push_x                     ' ... save ...
3034(0099): 2c 00 30 08 '  if_c  wrlong 0,SP          ' ... the register
3038(009a): 64 00 68 5c '  if_z  jmp    #LMM_next     ' no more to save
303c(009b): d9 33 bd 80 '        add    :push_x,dlsb  ' point to next register
3040(009c): 97 b4 ff e4 '        djnz   t1,#:push_nxt ' continue till all 24 registers checked
3044(009d): 64 00 7c 5c '        jmp    #LMM_next     ' increment PC, execute next instruction
3048(009e):             ' pop_m
3048(009e): 2b 5c bc 08 '        rdlong RI,PC         ' load the long value specifying the registers to push
304c(009f): 4a 46 fd 54 '        movd   :pop_x,#r23   ' start with ...
3050(00a0): 08 5c fc 2c '        shl    RI,#(32-24)   ' ... r23         
3054(00a1): 12 b4 ff a0 '        mov    t1,#18        ' we will pop up to 18 registers (down to r6)
3058(00a2):             ' :pop_nxt
3058(00a2): 01 5c fc 2f '        shl    RI,#1 wc,wz   ' load rx?
305c(00a3):             ' :pop_x                      ' if so ...
305c(00a3): 2c 00 b0 08 '  if_c  rdlong 0,SP          ' ... load ...
3060(00a4): 04 58 f0 80 '  if_c  add    SP,#4         ' ... the register
3064(00a5): 64 00 68 5c '  if_z  jmp    #LMM_next
3068(00a6): d9 47 bd 84 '        sub    :pop_x,dlsb   ' point to previous register
306c(00a7): a2 b4 ff e4 '        djnz   t1,#:pop_nxt  ' continue till all 24 registers checked
3070(00a8): 64 00 7c 5c '        jmp    #LMM_next     ' increment PC, execute next instruction
3074(00a9):             ' push_b
3074(00a9): 2b 5e bc 08 '        rdlong BC,PC         ' load the byte count
3078(00aa): 04 56 fc 80 '        add    PC,#4         ' increment the PC
307c(00ab): 03 5e fc 80 '        add    BC,#3         ' round up BC ...
3080(00ac): 03 5e fc 64 '        andn   BC,#3         ' ... to be a multiple of 4
3084(00ad): 2f 58 bc 84 '        sub    SP,BC         ' decrement SP by rounded up size
3088(00ae): 33 b4 bf a0 '        mov    t1,R0         ' source is in R0
308c(00af): 2c b6 bf a0 '        mov    t2,SP         ' destination is SP
3090(00b0): b7 00 7c 5c '        jmp    #copy_longs   ' do the copy
3094(00b1):             ' copy_b
3094(00b1): 2b 5e bc 08 '        rdlong BC,PC         ' load the byte count
3098(00b2): 04 56 fc 80 '        add    PC,#4         ' increment the PC
309c(00b3): 03 5e fc 80 '        add    BC,#3         ' round up BC ...
30a0(00b4): 03 5e fc 64 '        andn   BC,#3         ' ... to be a multiple of 4
30a4(00b5): 34 b4 bf a0 '        mov    t1,R1         ' source is in R1
30a8(00b6): 33 b6 bf a0 '        mov    t2,R0         ' destination is in R0
30ac(00b7):             ' copy_longs
30ac(00b7): 65 5e 7c ec '        tjz    BC,#LMM_Loop  ' no more to copy
30b0(00b8): da b9 bf 08 '        rdlong t3,t1         ' read from src to t3
30b4(00b9): db b9 3f 08 '        wrlong t3,t2         ' write t3 to dst
30b8(00ba): 04 b4 ff 80 '        add    t1,#4         ' increment source
30bc(00bb): 04 b6 ff 80 '        add    t2,#4         ' increment destination
30c0(00bc): 04 5e fc 84 '        sub    BC,#4         ' decrement count ...
30c4(00bd): b7 00 7c 5c '        jmp    #copy_longs   ' ... and keep copying
30c8(00be):             ' new_fp
30c8(00be): 04 58 fc 84 '        sub     SP,#4         ' decrement the stack pointer
30cc(00bf): 2c 5a 3c 08 '        wrlong FP,SP         ' save FP to stack
30d0(00c0): 2c 5a bc a0 '        mov    FP,SP         ' set up new FP
30d4(00c1): 08 5e fc 80 '        add    BC,#8         ' calculate what SP was ...
30d8(00c2): 2d 5e bc 80 '        add    BC,FP         ' ... before arguments were pushed
30dc(00c3): 65 00 7c 5c '        jmp    #LMM_loop     ' execute the next instruction
30e0(00c4):             ' fp_ret
30e0(00c4): 2c 5a bc 08 '        rdlong FP,SP         ' restore previous FP
30e4(00c5): 04 58 fc 80 '        add    SP,#4         ' increment the SP
30e8(00c6):             ' f_ret
30e8(00c6): 2c 56 bc 08 '        rdlong PC,SP         ' read the PC
30ec(00c7): 04 58 fc 80 '        add    SP,#4         ' increment the SP
30f0(00c8): 65 00 7c 5c '        jmp    #LMM_loop     ' execute the next instruction
30f4(00c9):             ' f_call                    
30f4(00c9): 2b 5c bc 08 '        rdlong RI,PC         ' get the address to call
30f8(00ca): 04 56 fc 80 '        add    PC,#4         ' increment the PC (this is the return address)
30fc(00cb):             ' f_cali
30fc(00cb): 04 58 fc 84 '        sub    SP,#4         ' decrement the SP
3100(00cc): 2c 56 3c 08 '        wrlong PC,SP         ' save current PC to stack
3104(00cd): d0 00 7c 5c '        jmp    #f_jmpi       ' jump to location in RI
3108(00ce):             ' f_jump
3108(00ce): 2b 56 bc 08 '        rdlong PC,PC         ' get the address to jump to
310c(00cf): 65 00 7c 5c '        jmp    #LMM_loop     ' execute next instruction
3110(00d0):             ' f_jmpi
3110(00d0): 2e 56 bc a0 '        mov    PC,RI         ' get the address to jump to
3114(00d1): 65 00 7c 5c '        jmp    #LMM_loop     ' execute next instruction
3118(00d2):             ' rd_long
3118(00d2): 2e 5e bc 08 '         rdlong  BC,RI
311c(00d3): 64 00 7c 5c '         jmp     #LMM_Next
3120(00d4):             ' rd_word
3120(00d4): 2e 5e bc 04 '         rdword  BC,RI
3124(00d5): 64 00 7c 5c '         jmp     #LMM_Next
3128(00d6):             ' rd_byte
3128(00d6): 2e 5e bc 00 '         rdbyte  BC,RI
312c(00d7): 64 00 7c 5c '         jmp     #LMM_Next
3130(00d8):             ' wr_long
3130(00d8): 2e 5e 3c 08 '         wrlong  BC,RI
3134(00d9): 64 00 7c 5c '         jmp     #LMM_Next
3138(00da):             ' wr_word
3138(00da): 2e 5e 3c 04 '         wrword  BC,RI
313c(00db): 64 00 7c 5c '         jmp     #LMM_Next
3140(00dc):             ' wr_byte
3140(00dc): 2e 5e 3c 00 '         wrbyte  BC,RI
3144(00dd): 64 00 7c 5c '         jmp     #LMM_Next
3148(00de):             ' f_d32s
3148(00de): 20 b4 ff a0 '         mov  t1,#32
314c(00df): 00 b6 ff a0 '         mov  t2,#0           ' tmp2 is temp register to hold the remainder
3150(00e0): 34 c6 bf a0 '         mov  ftemp,r1
3154(00e1): 33 c8 bf a0 '         mov  ftmp2,r0
3158(00e2): 34 68 bc a8 '         abs  r1, r1
315c(00e3): 33 66 bc a8 '         abs  r0, r0
3160(00e4): e4 c7 bf 6c '         xor  ftemp, ftmp2
3164(00e5):             ' :loop
3164(00e5): 01 66 fc 2d '         shl  r0,#1 WC
3168(00e6): 01 b6 ff 35 '         rcl  t2,#1 WC
316c(00e7): 34 b6 bf e3 '         cmpsub t2,r1 WC,WZ
3170(00e8): 01 66 f8 80 '  if_be add  r0,#1
3174(00e9): e5 b4 ff e4 '         djnz t1,#:loop
3178(00ea): db 69 bc a0 '         mov  r1,t2
317c(00eb): e4 c9 bf a1 '         mov  ftmp2,ftmp2 WC  ' get bit #31 into carry
3180(00ec): 34 68 bc b0 '         negc r1,r1                   ' adjust the sign of the remainder
3184(00ed): e3 c7 bf a1 '         mov  ftemp,ftemp WC  ' get bit #31 into carry
3188(00ee): 33 66 bc b0 '         negc r0,r0                   ' adjust the sign of the result
318c(00ef): 65 00 7c 5c '         jmp  #LMM_loop
3190(00f0):             ' f_d32u
3190(00f0): 20 c6 ff a0 '         mov ftemp,#32
3194(00f1): 00 c8 ff a0 '         mov ftmp2, #0
3198(00f2):             ' :up2
3198(00f2): 01 66 fc 2d '         shl r0,#1       WC
319c(00f3): 01 c8 ff 35 '         rcl ftmp2,#1    WC
31a0(00f4): e4 69 3c 87 '         cmp r1,ftmp2    WC,WZ
31a4(00f5): f8 00 44 5c '  if_a   jmp #:down
31a8(00f6): 34 c8 bf 84 '         sub ftmp2,r1
31ac(00f7): 01 66 fc 80 '         add r0,#1
31b0(00f8):             ' :down
31b0(00f8): 01 c6 ff 86 '         sub ftemp, #1   WZ
31b4(00f9): f2 00 54 5c '  if_ne  jmp #:up2
31b8(00fa): e4 69 bc a0 '         mov r1,ftmp2
31bc(00fb): 65 00 7c 5c '         jmp #LMM_loop
31c0(00fc):             ' f_m32
31c0(00fc): 00 c6 ff a0 '         mov ftemp,#0
31c4(00fd):             ' :start
31c4(00fd): 00 66 7c 86 '         cmp r0,#0       WZ
31c8(00fe): 04 01 68 5c '  if_e   jmp #:down3
31cc(00ff): 01 66 fc 29 '         shr r0,#1       WC
31d0(0100): 02 01 4c 5c '  if_ae  jmp #:down2
31d4(0101): 34 c6 bf 81 '         add ftemp,r1    WC
31d8(0102):             ' :down2
31d8(0102): 01 68 fc 2d '         shl r1,#1       WC
31dc(0103): fd 00 7c 5c '         jmp #:start
31e0(0104):             ' :down3
31e0(0104): e3 67 bc a0 '         mov r0,ftemp
31e4(0105): 65 00 7c 5c '         jmp #LMM_loop
31e8(0106):             ' bra_z
31e8(0106): ce 00 68 5c '   if_z  jmp    #f_jump       ' if condition true, branch is equiv to jump
31ec(0107): 64 00 7c 5c '         jmp    #LMM_next     ' increment PC, execute next instruction
31f0(0108):             ' bra_nz
31f0(0108): ce 00 54 5c '  if_nz  jmp    #f_jump       ' if condition true, branch is equiv to jump
31f4(0109): 64 00 7c 5c '         jmp    #LMM_next     ' increment PC, execute next instruction
31f8(010a):             ' bra_ae
31f8(010a): ce 00 4c 5c '  if_ae  jmp    #f_jump       ' if condition true, branch is equiv to jump
31fc(010b): 64 00 7c 5c '         jmp    #LMM_next     ' increment PC, execute next instruction
3200(010c):             ' bra_a
3200(010c): ce 00 44 5c '  if_a   jmp    #f_jump       ' if condition true, branch is equiv to jump
3204(010d): 64 00 7c 5c '         jmp    #LMM_next     ' increment PC, execute next instruction
3208(010e):             ' bra_be
3208(010e): ce 00 78 5c '  if_be  jmp    #f_jump       ' if condition true, branch is equiv to jump
320c(010f): 64 00 7c 5c '         jmp    #LMM_next     ' increment PC, execute next instruction
3210(0110):             ' bra_b
3210(0110): ce 00 70 5c '  if_b   jmp    #f_jump       ' if condition true, branch is equiv to jump
3214(0111): 64 00 7c 5c '         jmp    #LMM_next     ' increment PC, execute next instruction
3218(0112):             ' plugin
3218(0112): 36 66 bc a0 '         mov     r0,r3           ' get plugin type
321c(0113): 80 66 7c 62 '         test    r0,#$80 wz      ' request by type?
3220(0114): 17 01 68 5c '  if_z   jmp     #ptype          ' yes - must find plugin of this type
3224(0115): 7f 66 fc 60 '         and     r0,#$7f         ' no - code is cog id
3228(0116): 23 01 7c 5c '         jmp     #pid            ' invoke plugin by cog id
322c(0117):             ' ptype
322c(0117): f0 b5 bf a0 '         mov     t1,par          ' no - point to registry
3230(0118): 00 b6 ff a0 '         mov     t2,#0           ' start at cog 0
3234(0119):             ' plgt1
3234(0119): 08 b6 7f 87 '         cmp     t2,#8 wc,wz     ' run out of plugins?
3238(011a): 2f 01 4c 5c '  if_ae  jmp     #plugerr        ' yes - no such plugin
323c(011b): da b9 bf 08 '         rdlong  t3,t1           ' no - check next plugin type
3240(011c): 18 b8 ff 28 '         shr     t3,#24          ' is it ...
3244(011d): 33 b8 3f 86 '         cmp     t3,r0 wz        ' ... the type what we wanted?
3248(011e): 22 01 68 5c '  if_z   jmp     #plgt2          ' yes - use this plugin
324c(011f): 01 b6 ff 80 '         add     t2,#1           ' no ...
3250(0120): 04 b4 ff 80 '         add     t1,#4           ' ... check ...
3254(0121): 19 01 7c 5c '         jmp     #plgt1          ' ... next cog
3258(0122):             ' plgt2
3258(0122): db 67 bc a0 '         mov     r0,t2           ' use the cog where we found the plugin
325c(0123):             ' pid
325c(0123): 02 66 fc 2c '         shl     r0,#2           ' multiply plugin (cog) id by 4 ...
3260(0124): f0 67 bc 80 '         add     r0,par          ' add registry base to get registry entry
3264(0125): 33 66 bc 08 '         rdlong  r0,r0           ' get request block from registry
3268(0126): 4f 66 3c 62 '         test    r0,top8 wz      ' plugin registered?
326c(0127): 2f 01 68 5c '  if_z   jmp     #plugerr        ' no - error 255
3270(0128): 50 66 bc 60 '         and     r0,low24        ' yes - write request ...
3274(0129): 33 6a 3c 08 '         wrlong  r2,r0           ' ... to request block
3278(012a): 33 6c bc 0a ' loop    rdlong  r3,r0   wz      ' wait till ...
327c(012b): 2a 01 54 5c '  if_nz  jmp     #loop           ' ... request completed
3280(012c): 04 66 fc 80 '         add     r0,#4           ' get results ...
3284(012d): 33 66 bc 08 '         rdlong  r0,r0           ' ... from request block
3288(012e): 65 00 7c 5c '         jmp     #LMM_loop       'done
328c(012f): 01 66 fc a4 ' plugerr neg     r0,#1           ' plugin not registered
3290(0130): 65 00 7c 5c '         jmp     #LMM_loop
3294(0131): 4b 68 bc 6c ' flt_sub                 xor     r1, Bit31               ' negate B
3298(0132): 92 3b ff 5c ' flt_add                 call    #_Unpack2               ' unpack two variables
329c(0133): 65 00 78 5c '           if_c_or_z     jmp     #LMM_Loop               ' check for NaN or B = 0
32a0(0134): 01 ba 7f 62 '                         test    flagA, #SignFlag wz     ' negate A mantissa if negative
32a4(0135): df bf 97 a4 '           if_nz         neg     manA, manA
32a8(0136): 01 c0 7f 62 '                         test    flagB, #SignFlag wz     ' negate B mantissa if negative
32ac(0137): e2 c5 97 a4 '           if_nz         neg     manB, manB
32b0(0138): de b5 bf a0 '                         mov     t1, expA                ' align mantissas
32b4(0139): e1 b5 bf 84 '                         sub     t1, expB
32b8(013a): da b5 bf a8 '                         abs     t1, t1
32bc(013b): 1f b4 ff 4c '                         max     t1, #31
32c0(013c): e1 bd 3f c3 '                         cmps    expA, expB wz,wc
32c4(013d): da c5 87 38 '           if_nz_and_nc  sar     manB, t1
32c8(013e): da bf 93 38 '           if_nz_and_c   sar     manA, t1
32cc(013f): e1 bd 93 a0 '           if_nz_and_c   mov     expA, expB
32d0(0140): e2 bf bf 80 '                         add     manA, manB              ' add the two mantissas
32d4(0141): 00 be 7f c1 '                         cmps    manA, #0 wc, nr         ' set sign of result
32d8(0142): 01 ba f3 68 '           if_c          or      flagA, #SignFlag
32dc(0143): 01 ba cf 64 '           if_nc         andn    flagA, #SignFlag
32e0(0144): df bf bf a8 '                         abs     manA, manA              ' pack result and exit
32e4(0145): bc a9 ff 5c '                         call    #_Pack
32e8(0146): 65 00 7c 5c '                         jmp     #LMM_Loop
32ec(0147): 92 3b ff 5c ' flt_mul                 call    #_Unpack2               ' unpack two variables
32f0(0148): 65 00 70 5c '           if_c          jmp     #LMM_Loop               ' check for NaN
32f4(0149): e0 bb bf 6c '                         xor     flagA, flagB            ' get sign of result
32f8(014a): e1 bd bf 80 '                         add     expA, expB              ' add exponents
32fc(014b): 00 b4 ff a0 '                         mov     t1, #0                  ' t2 = upper 32 bits of manB
3300(014c): 20 b6 ff a0 '                         mov     t2, #32                 ' loop counter for multiply
3304(014d): 01 c4 ff 29 '                         shr     manB, #1 wc             ' get initial multiplier bit
3308(014e): df b5 b3 81 ' :multiply if_c          add     t1, manA wc             ' 32x32 bit multiply
330c(014f): 01 b4 ff 31 '                         rcr     t1, #1 wc
3310(0150): 01 c4 ff 31 '                         rcr     manB, #1 wc
3314(0151): 4e b7 ff e4 '                         djnz    t2, #:multiply
3318(0152): 03 b4 ff 2c '                         shl     t1, #3                  ' justify result and exit
331c(0153): da bf bf a0 '                         mov     manA, t1
3320(0154): bc a9 ff 5c '                         call    #_Pack
3324(0155): 65 00 7c 5c '                         jmp     #LMM_Loop
3328(0156): 92 3b ff 5c ' flt_div                 call    #_Unpack2               ' unpack two variables
332c(0157): d5 67 b8 a0 '           if_c_or_z     mov     r0, NaN                 ' check for NaN or divide by 0
3330(0158): 65 00 78 5c '           if_c_or_z     jmp     #LMM_Loop
3334(0159): e0 bb bf 6c '                         xor     flagA, flagB            ' get sign of result
3338(015a): e1 bd bf 84 '                         sub     expA, expB              ' subtract exponents
333c(015b): 00 b4 ff a0 '                         mov     t1, #0                  ' clear quotient
3340(015c): 1e b6 ff a0 '                         mov     t2, #30                 ' loop counter for divide
3344(015d): 01 b4 ff 2c ' :divide                 shl     t1, #1                  ' divide the mantissas
3348(015e): e2 bf 3f c3 '                         cmps    manA, manB wz,wc
334c(015f): e2 bf af 84 '           if_z_or_nc    sub     manA, manB
3350(0160): 01 b4 ef 80 '           if_z_or_nc    add     t1, #1
3354(0161): 01 be ff 2c '                         shl     manA, #1
3358(0162): 5d b7 ff e4 '                         djnz    t2, #:divide
335c(0163): da bf bf a0 '                         mov     manA, t1                ' get result and exit
3360(0164): bc a9 ff 5c '                         call    #_Pack
3364(0165): 65 00 7c 5c '                         jmp     #LMM_Loop
3368(0166): 33 ba bf a0 ' flt_int                 mov     flagA, r0               ' get integer value
336c(0167): 00 66 fc a0 '                         mov     r0, #0                  ' set initial result to zero
3370(0168): dd bf bf aa '                         abs     manA, flagA wz          ' get absolute value of integer
3374(0169): 65 00 68 5c '           if_z          jmp     #LMM_Loop               ' if zero, exit
3378(016a): 1f ba ff 28 '                         shr     flagA, #31              ' set sign flag
337c(016b): 1f bc ff a0 '                         mov     expA, #31               ' set initial value for exponent
3380(016c): 01 be ff 2d ' :normalize              shl     manA, #1 wc             ' normalize the mantissa
3384(016d): 01 bc cf 84 '           if_nc         sub     expA, #1                ' adjust exponent
3388(016e): 6c 01 4c 5c '           if_nc         jmp     #:normalize
338c(016f): 01 be ff 30 '                         rcr     manA, #1                ' justify mantissa
3390(0170): 02 be ff 28 '                         shr     manA, #2
3394(0171): bc a9 ff 5c '                         call    #_Pack                  ' pack and exit
3398(0172): 65 00 7c 5c '                         jmp     #LMM_Loop
339c(0173): 00 b4 ff a0 ' int_flt                 mov     t1, #0                  ' set for no rounding
33a0(0174): 9e 77 ff 5c ' fix                     call    #_Unpack                ' unpack floating point value
33a4(0175): 65 00 70 5c '           if_c          jmp     #LMM_Loop               ' check for NaN
33a8(0176): 02 be ff 2c '                         shl     manA, #2                ' left justify mantissa
33ac(0177): 00 66 fc a0 '                         mov     r0, #0                  ' initialize result to zero
33b0(0178): de bd bf a4 '                         neg     expA, expA              ' adjust for exponent value
33b4(0179): 1e bc ff 82 '                         add     expA, #30 wz
33b8(017a): 20 bc 7f c1 '                         cmps    expA, #32 wc
33bc(017b): 65 00 6c 5c '           if_nc_or_z    jmp     #LMM_Loop
33c0(017c): de bf bf 28 '                         shr     manA, expA
33c4(017d): da bf bf 80 '                         add     manA, t1                ' round up 1/2 lsb
33c8(017e): 01 be ff 28 '                         shr     manA, #1
33cc(017f): 01 ba 7f 62 '                         test    flagA, #signFlag wz     ' check sign and exit
33d0(0180): df 67 bc 9c '                         sumnz   r0, manA
33d4(0181): 65 00 7c 5c '                         jmp     #LMM_Loop
33d8(0182): 33 b4 bf a0 ' flt_cmp                 mov     t1, r0               ' compare signs
33dc(0183): 34 b4 bf 6c '                         xor     t1, r1
33e0(0184): 4b b4 bf 62 '                         and     t1, Bit31 wz
33e4(0185): 8c 01 68 5c '           if_z          jmp     #:cmp1                  ' same, then compare magnitude
33e8(0186): 33 b4 bf a0 '                         mov     t1, r0               ' check for +0 or -0
33ec(0187): 34 b4 bf 68 '                         or      t1, r1
33f0(0188): 4b b4 bf 67 '                         andn    t1, Bit31 wz,wc
33f4(0189): 65 00 68 5c '           if_z          jmp     #LMM_Loop
33f8(018a): 4b 66 3c 61 '                         test    r0, Bit31 wc         ' compare signs
33fc(018b): 65 00 7c 5c '                         jmp     #LMM_Loop
3400(018c): 4b 66 3c 62 ' :cmp1                   test    r0, Bit31 wz         ' check signs
3404(018d): 90 01 54 5c '           if_nz         jmp     #:cmp2
3408(018e): 34 66 3c 87 '                         cmp     r0, r1 wz,wc
340c(018f): 65 00 7c 5c '                         jmp     #LMM_Loop
3410(0190): 33 68 3c 87 ' :cmp2                   cmp     r1, r0 wz,wc      ' reverse test if negative
3414(0191): 65 00 7c 5c '                         jmp     #LMM_Loop
3418(0192): 33 b4 bf a0 ' _Unpack2                mov     t1, r0               ' save A
341c(0193): 34 66 bc a0 '                         mov     r0, r1            ' unpack B to A
3420(0194): 9e 77 ff 5c '                         call    #_Unpack
3424(0195): 9d 01 70 5c '           if_c          jmp     #_Unpack2_ret           ' check for NaN
3428(0196): 33 68 bc a0 '                         mov     r1, r0            ' save B variables
342c(0197): dd c1 bf a0 '                         mov     flagB, flagA
3430(0198): de c3 bf a0 '                         mov     expB, expA
3434(0199): df c5 bf a0 '                         mov     manB, manA
3438(019a): da 67 bc a0 '                         mov     r0, t1               ' unpack A
343c(019b): 9e 77 ff 5c '                         call    #_Unpack
3440(019c): 00 c4 7f 86 '                         cmp     manB, #0 wz             ' set Z flag
3444(019d): 00 00 7c 5c ' _Unpack2_ret            ret
3448(019e): 33 ba bf a0 ' _Unpack                 mov     flagA, r0            ' get sign
344c(019f): 1f ba ff 28 '                         shr     flagA, #31
3450(01a0): 33 be bf a0 '                         mov     manA, r0             ' get mantissa
3454(01a1): d7 bf bf 60 '                         and     manA, Mask23
3458(01a2): 33 bc bf a0 '                         mov     expA, r0             ' get exponent
345c(01a3): 01 bc ff 2c '                         shl     expA, #1
3460(01a4): 18 bc ff 2a '                         shr     expA, #24 wz
3464(01a5): ab 01 68 5c '           if_z          jmp     #:zeroSubnormal         ' check for zero or subnormal
3468(01a6): ff bc 7f 86 '                         cmp     expA, #255 wz           ' check if finite
346c(01a7): b6 01 54 5c '           if_nz         jmp     #:finite
3470(01a8): d5 67 bc a0 '                         mov     r0, NaN              ' no, then return NaN
3474(01a9): 08 ba ff a0 '                         mov     flagA, #NaNFlag
3478(01aa): b9 01 7c 5c '                         jmp     #:exit2
347c(01ab): de bf 3f 6a ' :zeroSubnormal          or      manA, expA wz,nr        ' check for zero
3480(01ac): b0 01 54 5c '           if_nz         jmp     #:subnorm
3484(01ad): 02 ba ff 68 '                         or      flagA, #ZeroFlag        ' yes, then set zero flag
3488(01ae): 96 bc ff a4 '                         neg     expA, #150              ' set exponent and exit
348c(01af): b9 01 7c 5c '                         jmp     #:exit2
3490(01b0): 07 be ff 2c ' :subnorm                shl     manA, #7                ' fix justification for subnormals
3494(01b1): d8 bf 3f 62 ' :subnorm2               test    manA, Bit29 wz
3498(01b2): b8 01 54 5c '           if_nz         jmp     #:exit1
349c(01b3): 01 be ff 2c '                         shl     manA, #1
34a0(01b4): 01 bc ff 84 '                         sub     expA, #1
34a4(01b5): b1 01 7c 5c '                         jmp     #:subnorm2
34a8(01b6): 06 be ff 2c ' :finite                 shl     manA, #6                ' justify mantissa to bit 29
34ac(01b7): d8 bf bf 68 '                         or      manA, Bit29             ' add leading one bit
34b0(01b8): 7f bc ff 84 ' :exit1                  sub     expA, #127              ' remove bias from exponent
34b4(01b9): 08 ba 7f 61 ' :exit2                  test    flagA, #NaNFlag wc      ' set C flag
34b8(01ba): 00 be 7f 86 '                         cmp     manA, #0 wz             ' set Z flag
34bc(01bb): 00 00 7c 5c ' _Unpack_ret             ret
34c0(01bc): 00 be 7f 86 ' _Pack                   cmp     manA, #0 wz             ' check for zero
34c4(01bd): 00 bc eb a0 '           if_z          mov     expA, #0
34c8(01be): cf 01 68 5c '           if_z          jmp     #:exit1
34cc(01bf): 01 be ff 2d ' :normalize              shl     manA, #1 wc             ' normalize the mantissa
34d0(01c0): 01 bc cf 84 '           if_nc         sub     expA, #1                ' adjust exponent
34d4(01c1): bf 01 4c 5c '           if_nc         jmp     #:normalize
34d8(01c2): 02 bc ff 80 '                         add     expA, #2                ' adjust exponent
34dc(01c3): 00 bf ff 81 '                         add     manA, #$100 wc          ' round up by 1/2 lsb
34e0(01c4): 01 bc f3 80 '           if_c          add     expA, #1
34e4(01c5): 7f bc ff 80 '                         add     expA, #127              ' add bias to exponent
34e8(01c6): d6 bd bf 40 '                         mins    expA, Minus23
34ec(01c7): ff bc ff 44 '                         maxs    expA, #255
34f0(01c8): 01 bc 7f c1 '                         cmps    expA, #1 wc             ' check for subnormals
34f4(01c9): cf 01 4c 5c '           if_nc         jmp     #:exit1
34f8(01ca): 01 be ff 68 ' :subnormal              or      manA, #1                ' adjust mantissa
34fc(01cb): 01 be ff 20 '                         ror     manA, #1
3500(01cc): de bd bf a4 '                         neg     expA, expA
3504(01cd): de bf bf 28 '                         shr     manA, expA
3508(01ce): 00 bc ff a0 '                         mov     expA, #0                ' biased exponent = 0
350c(01cf): df 67 bc a0 ' :exit1                  mov     r0, manA             ' bits 22:0 mantissa
3510(01d0): 09 66 fc 28 '                         shr     r0, #9
3514(01d1): de 67 bc 58 '                         movi    r0, expA             ' bits 23:30 exponent
3518(01d2): 1f ba ff 2c '                         shl     flagA, #31
351c(01d3): dd 67 bc 68 '                         or      r0, flagA            ' bit 31 sign
3520(01d4): 00 00 7c 5c ' _Pack_ret               ret
3524(01d5): ff ff ff 7f ' NaN                     long    $7FFF_FFFF
3528(01d6): e9 ff ff ff ' Minus23                 long    -23
352c(01d7): ff ff 7f 00 ' Mask23                  long    $007F_FFFF
3530(01d8): 00 00 00 20 ' Bit29                   long    $2000_0000
3534(01d9): 00 02 00 00 ' dlsb                    long    1 << 9
3538(01da):             ' t1                      res     1                       ' temporary values
3538(01db):             ' t2                      res     1
3538(01dc):             ' t3                      res     1
3538(01dd):             ' flagA                   res     1
3538(01de):             ' expA                    res     1
3538(01df):             ' manA                    res     1
3538(01e0):             ' flagB                   res     1
3538(01e1):             ' expB                    res     1
3538(01e2):             ' manB                    res     1
3538(01e3):             ' ftemp                   res     1
3538(01e4):             ' ftmp2                   res     1
3538(01eb):             '               org       $1eb
3538(01eb): 00 00 00 00 ' DEBUG_VECTORS long      0,0,0,0,0
353c(01ec): 00 00 00 00 ' 
3540(01ed): 00 00 00 00 ' 
3544(01ee): 00 00 00 00 ' 
3548(01ef): 00 00 00 00 ' 
'========================= Method #1: PUB Entry_Addr ==========================
'PUB Entry_Addr : addr
'------------------------------------------------------------------------------
   addr := @entry ' Kernel Entry Address
'------------------------------------------------------------------------------
354c: c7 0c          PUSH#.L	OBJ+12
354e: 61             POP  	Locals+0
354f: 32             RETURN	
'============================ Method #2: PUB Run ==============================
'PUB Run (registry, request, Initial_BA, Initial_SP) : cog
'------------------------------------------------------------------------------
  long[request][2 * cogid + 1] := Initial_SP
'------------------------------------------------------------------------------
3550: 70             PUSH 	Locals+16
3551: 68             PUSH 	Locals+8
3552: 37 00          PUSH#kp	2 ($2)
3554: 3f 89          REGPUSH	$89?
3556: f4             MPY  	
3557: 36             PUSH#1	
3558: ec             ADD  	
3559: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[request][2 * cogid]     := Initial_BA
'------------------------------------------------------------------------------
355a: 6c             PUSH 	Locals+12
355b: 68             PUSH 	Locals+8
355c: 37 00          PUSH#kp	2 ($2)
355e: 3f 89          REGPUSH	$89?
3560: f4             MPY  	
3561: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  coginit(cogid, @entry, registry)
'------------------------------------------------------------------------------
3562: 3f 89          REGPUSH	$89?
3564: c7 0c          PUSH#.L	OBJ+12
3566: 64             PUSH 	Locals+4
3567: 2c             COGISUB	
3568: 32             RETURN	
3569: 00 00 00    

'******************************************************************************
'                         Catalina_HMI_Plugin_PC.spin                          
'******************************************************************************

'=================================== CONs =====================================
cols = 40
rows = 13
chrs = 520
sc_count = 281
nx = 0
ny = 1
buffer = 3
DATASIZE = 296
'=============================== Object Header ================================
356c: 38 04 03 03 ' 1080 bytes, 3-1 methods, 3 object pointers
3570: c4 03 00 00 ' ptr #1 to $3930: PUB ProxySetup (locals size: 0)
3574: cb 03 34 00 ' ptr #2 to $3937: PUB Start (locals size: 52)
3578: 38 04 0c 00 ' ptr #3 to $39a4: OBJ kbd : Catalina_PC_Keyboard.spin (VAR offset: 12)
357c: 30 05 0c 00 ' ptr #4 to $3a9c: OBJ screen : Catalina_PC_Text.spin (VAR offset: 12)
3580: f8 05 0c 00 ' ptr #5 to $3b64: OBJ common : Catalina_Common.spin (VAR offset: 12)
'================================ DAT Section =================================
3584(0000):             '         org     0
3584(0000):             ' HmiStart
3584(0000): 01 e0 fd 0c '         cogid   t1              ' calculate ...
3588(0001): 02 e0 fd 2c '         shl     t1,#2           ' ... my ...
358c(0002): f0 e1 bd 80 '         add     t1,par          ' ... request ...
3590(0003): f0 d6 bd 08 '         rdlong  rqstptr,t1      ' ... block ...
3594(0004): e2 d6 bd 60 '         and     rqstptr,low24   ' ... address
3598(0005): eb d8 bd a0 '         mov     rsltptr,rqstptr ' calculate ...
359c(0006): 04 d8 fd 80 '         add     rsltptr,#4      ' ... my result address
35a0(0007):             ' loop
35a0(0007): eb da bd 0a '         rdlong  rqst,rqstptr wz ' wait ...
35a4(0008): 07 00 68 5c '   if_z  jmp     #loop           ' ... for a request
35a8(0009): ed e0 bd a0 '         mov     t1,rqst
35ac(000a): 18 e0 fd 28 '         shr     t1,#24
35b0(000b): 20 e0 7d 87 '         cmp     t1,#32 wz,wc
35b4(000c): a1 00 44 5c '   if_a  jmp     #done_bad
35b8(000d): 02 e0 fd 20 '         ror     t1,#2           ' lookup code address
35bc(000e): 16 e0 fd 80 '         add     t1,#svctable
35c0(000f): f0 24 bc 50 '         movs    :table,t1
35c4(0010): 02 e0 fd 24 '         rol     t1,#2
35c8(0011): 03 e0 fd 2c '         shl     t1,#3
35cc(0012): 00 e2 bd a0 ' :table  mov     t2,0
35d0(0013): f0 e2 bd 28 '         shr     t2,t1
35d4(0014): ff e2 fd 60 '         and     t2,#$FF
35d8(0015): f1 00 3c 5c '         jmp     t2              ' jump to code routine
35dc(0016):             ' svctable
35dc(0016): 1f          '         byte    initialize      ' 0
35dd(----): 38          '         byte    k_present       ' 1 
35de(----): 3b          '         byte    k_get           ' 2
35df(----): 47          '         byte    k_wait          ' 3
35e0(0017): 43          '         byte    k_new           ' 4
35e1(----): 4a          '         byte    k_ready         ' 5
35e2(----): 4e          '         byte    k_clear         ' 6
35e3(----): 3a          '         byte    k_state         ' 7 
35e4(0018): a1          '         byte    done_bad        ' 8
35e5(----): a1          '         byte    done_bad        ' 9
35e6(----): a1          '         byte    done_bad        '10
35e7(----): a3          '         byte    done_ok         '11 m_present ignored
35e8(0019): a3          '         byte    done_ok         '12 m_button ignored  
35e9(----): a3          '         byte    done_ok         '13 m_buttons ignored 
35ea(----): a3          '         byte    done_ok         '14 m_abs_x ignored   
35eb(----): a3          '         byte    done_ok         '15 m_abs_y ignored   
35ec(001a): a3          '         byte    done_ok         '16 m_abs_z ignored   
35ed(----): a3          '         byte    done_ok         '17 m_delta_x ignored 
35ee(----): a3          '         byte    done_ok         '18 m_delta_y ignored 
35ef(----): a3          '         byte    done_ok         '19 m_delta_z ignored 
35f0(001b): a3          '         byte    done_ok         '20 m_reset ignored   
35f1(----): 52          '         byte    t_geometry      '21
35f2(----): 56          '         byte    t_char          '22
35f3(----): 5f          '         byte    t_string        '23
35f4(001c): 6a          '         byte    t_int           '24
35f5(----): 8b          '         byte    t_unsigned      '25
35f6(----): 8d          '         byte    t_hex           '26
35f7(----): 98          '         byte    t_bin           '27
35f8(001d): a3          '         byte    done_ok         '28 t_setpos ignored
35f9(----): a3          '         byte    done_ok         '29 t_getpos ignored
35fa(----): a3          '         byte    done_ok         '30 t_mode ignored
35fb(----): a3          '         byte    done_ok         '31 t_scroll ignored
35fc(001e): a3          '         byte    done_ok         '32 t_color ignored
35fd(----): 00 00 00    
3600(001f):             '         long                    ' align long
3600(001f):             ' initialize
3600(001f): ed f4 bd 08 '         rdlong  ppkbd,rqst      ' save pointer to keyboard parameters
3604(0020): 04 da fd 80 '         add     rqst,#4         ' save pointer to ...
3608(0021): ed f6 bd 08 '         rdlong  ppmouse,rqst    ' ... mouse params
360c(0022): 04 da fd 80 '         add     rqst,#4         ' save pointer to ...
3610(0023): ed f8 bd 08 '         rdlong  ppscrn,rqst     ' ... screen parameters
3614(0024): 04 da fd 80 '         add     rqst,#4         ' save pointer to ...
3618(0025): ed fa bd 08 '         rdlong  pptv,rqst       ' ... tv parameters
361c(0026): fc de bd a0 '         mov     t0,ppscrn       ' get ...
3620(0027): ef e0 bd 08 '         rdlong  t1,t0           ' ... screen ...
3624(0028): f0 fc bd a0 '         mov     scrcols,t1      ' ... cols
3628(0029): 04 de fd 80 '         add     t0,#4           ' get ...
362c(002a): ef e2 bd 08 '         rdlong  t2,t0           ' ... screen ...
3630(002b): f1 fe bd a0 '         mov     scrrows,t2      ' ... rows
3634(002c): cf a6 fd 5c '         call    #m32            ' multiply rows by cols
3638(002d): ef 00 be a0 '         mov     scrsize,t0      ' save as acreen size
363c(002e): fc 04 be a0 '         mov     scrclrs,ppscrn  ' calculate ...
3640(002f): 08 04 fe 80 '         add     scrclrs,#8      ' ... screen color address
3644(0030): fc 02 be a0 '         mov     scrbuff,ppscrn  ' calculate ...
3648(0031): 0c 02 fe 80 '         add     scrbuff,#12     ' ... screen buffer address
364c(0032): 01 07 be a0 '         mov     scrpall,scrbuff ' calculate ...
3650(0033): 00 07 be 80 '         add     scrpall,scrsize ' ... palette ...
3654(0034): 00 07 be 80 '         add     scrpall,scrsize ' ... address
3658(0035): 03 09 be a0 '         mov     scrcurs,scrpall ' calculate ...
365c(0036): 40 08 fe 80 '         add     scrcurs,#64     ' ... screen cursors address
3660(0037): a3 00 7c 5c '         jmp     #done_ok
3664(0038):             ' k_present
3664(0038): 01 dc fd a0 '         mov     rslt,#1         ' presume ...
3668(0039): a4 00 7c 5c '         jmp     #done           ' ... always present
366c(003a):             ' k_state
366c(003a): a3 00 7c 5c '         jmp     #done_ok        ' ignore        
3670(003b):             ' k_get
3670(003b): af 72 fd 5c '         call    #k_load         ' load key pointed to by par_tail
3674(003c): a3 00 68 5c '    if_z jmp     #done_ok        ' Z set if no key available
3678(003d):             ' k_consume
3678(003d): 01 e0 fd 80 '         add     t1,#1           ' increment ...
367c(003e): 0f e0 fd 60 '         and     t1,#$f          ' ...
3680(003f): fa de bd a0 '         mov     t0,ppkbd        ' ...
3684(0040): 04 de fd 80 '         add     t0,#4           ' ...
3688(0041): ef e0 3d 08 '         wrlong  t1,t0           ' ... par_tail
368c(0042): a4 00 7c 5c '         jmp     #done
3690(0043): a8 5c fd 5c ' k_new   call    #k_setup        ' setup common values
3694(0044): fa de bd a0 '         mov     t0,ppkbd        ' set par_tail ...
3698(0045): 04 de fd 80 '         add     t0,#4           ' ... to ...
369c(0046): ef e2 3d 08 '         wrlong  t2,t0           ' ... par_head
36a0(0047):             ' k_wait
36a0(0047): af 72 fd 5c '         call    #k_load         ' load key pointed to by par_tail
36a4(0048): 47 00 68 5c '  if_z   jmp     #k_wait         ' Z set if no key available
36a8(0049): 3d 00 7c 5c '         jmp     #k_consume      ' consume and return the key
36ac(004a):             ' k_ready
36ac(004a): a8 5c fd 5c '         call    #k_setup        ' setup common values
36b0(004b): a4 00 68 5c '   if_z  jmp     #done           ' rslt == 0 if no key ready
36b4(004c): 01 dc fd a4 '         neg     rslt,#1         ' rslt == -1 if a key is ready
36b8(004d): a4 00 7c 5c '         jmp     #done
36bc(004e):             ' k_clear
36bc(004e): a8 5c fd 5c '         call    #k_setup        ' setup common values
36c0(004f): fa de bd a0 '         mov     t0,ppkbd        ' set par_head ...
36c4(0050): ef e0 3d 08 '         wrlong  t1,t0           ' .... to par_tail
36c8(0051): a4 00 7c 5c '         jmp     #done
36cc(0052):             ' t_geometry
36cc(0052): fe dc bd a0 '         mov     rslt,scrcols    ' result is ...
36d0(0053): 08 dc fd 2c '         shl     rslt,#8         ' ... cols*256 ...
36d4(0054): ff dc bd 80 '         add     rslt,scrrows    ' ... plus rows
36d8(0055): a4 00 7c 5c '         jmp     #done
36dc(0056):             ' t_char
36dc(0056): ed e8 bd a0 '         mov     t5,rqst         ' get ...
36e0(0057): ff e8 fd 60 '         and     t5,#$ff         ' ... char to write
36e4(0058): 0a e8 7d 86 '         cmp     t5,#$0a wz      ' translate ...
36e8(0059): 5d 00 54 5c '   if_nz jmp     #:t_char_1      ' ... lf ...
36ec(005a): 0d e8 fd a0 '         mov     t5,#$0d         ' ... to ...
36f0(005b): c6 9c fd 5c '         call    #t_put5         ' ... cr ...
36f4(005c): 0a e8 fd a0 '         mov     t5,#$0a         ' ... lf
36f8(005d):             ' :t_char_1
36f8(005d): c6 9c fd 5c '         call    #t_put5         ' write char to screen at cursor
36fc(005e): a3 00 7c 5c '         jmp     #done_ok
3700(005f):             ' t_string 
3700(005f): e1 da bd 60 '         and     rqst,low23      ' source address is lower 23 bits of request
3704(0060):             ' :t_strloop
3704(0060): ed e8 bd 02 '         rdbyte  t5,rqst wz      ' get char to write
3708(0061): a3 00 68 5c '   if_z  jmp     #done_ok        ' finished if null byte
370c(0062): 0a e8 7d 86 '         cmp     t5,#$0a wz      ' translate ...
3710(0063): 67 00 54 5c '   if_nz jmp     #:t_str_1      ' ... lf ...
3714(0064): 0d e8 fd a0 '         mov     t5,#$0d         ' ... to ...
3718(0065): c6 9c fd 5c '         call    #t_put5         ' ... cr ...
371c(0066): 0a e8 fd a0 '         mov     t5,#$0a         ' ... lf
3720(0067):             ' :t_str_1
3720(0067): c6 9c fd 5c '         call    #t_put5         ' write char to screen
3724(0068): 01 da fd 80 '         add     rqst,#1         ' increment string pointer
3728(0069): 60 00 7c 5c '         jmp     #:t_strloop     ' put more chars
372c(006a):             ' t_int
372c(006a): c3 8a fd 5c '         call    #t_getnum       ' get number to print
3730(006b): 00 da 7d c3 '         cmps    rqst,#0 WC,WZ   ' positive?
3734(006c): 70 00 4c 5c '  if_ae  jmp     #t_uint         ' yes - no sign
3738(006d): 2d e8 fd a0 '         mov     t5,#$2d         ' no - prefix number with '-'
373c(006e): c6 9c fd 5c '         call    #t_put5         ' write char to screen at cursor
3740(006f): ed da bd ab '         abs     rqst,rqst WC,WZ ' make number positive
3744(0070):             ' t_uint
3744(0070): 87 00 68 5c '   if_z  jmp     #:t_int4        ' if zero, just print one digit
3748(0071): e3 e6 bd a0 '         mov     t4,maxdec       ' get largest possible decimal divisor
374c(0072):             ' :t_int2
374c(0072): f3 da 3d 87 '         cmp     rqst,t4 WC,WZ   ' is our number larger than that?
3750(0073): 79 00 4c 5c '  if_ae  jmp     #:t_int3        ' yes - start extracting decimal digits
3754(0074): f3 de bd a0 '         mov     t0,t4           ' no - divide divisor ...
3758(0075): 0a e0 fd a0 '         mov     t1,#10          ' ... by 10 ...
375c(0076): d4 be fd 5c '         call    #d32u           ' ... and ...
3760(0077): ef e6 bd a0 '         mov     t4,t0           ' ... try ...
3764(0078): 72 00 7c 5c '         jmp     #:t_int2        ' ... again
3768(0079):             ' :t_int3
3768(0079): 0a e6 7d 87 '         cmp     t4,#10 WC,WZ    ' is this the last digit?
376c(007a): 87 00 70 5c '  if_b   jmp     #:t_int4        ' yes - no need to divide any more
3770(007b): ed de bd a0 '         mov     t0,rqst         ' no - divide number ...
3774(007c): f3 e0 bd a0 '         mov     t1,t4           ' ... by  ...
3778(007d): d4 be fd 5c '         call    #d32u           ' ... divisor
377c(007e): ef e8 bd a0 '         mov     t5,t0           ' convert quotient ...
3780(007f): 30 e8 fd 80 '         add     t5,#$30         ' ... to digit char
3784(0080): f0 da bd a0 '         mov     rqst,t1         ' save remainder for next time
3788(0081): c6 9c fd 5c '         call    #t_put5         ' write char to screen at cursor
378c(0082): f3 de bd a0 '         mov     t0,t4           ' divide divisor ...
3790(0083): 0a e0 fd a0 '         mov     t1,#10          ' ... by 10 ...
3794(0084): d4 be fd 5c '         call    #d32u           ' ... and ...
3798(0085): ef e6 bd a0 '         mov     t4,t0           ' ... continue ...
379c(0086): 79 00 7c 5c '         jmp     #:t_int3        ' ... with next digit
37a0(0087):             ' :t_int4
37a0(0087): ed e8 bd a0 '         mov     t5,rqst           ' convert last decimal digit ...
37a4(0088): 30 e8 fd 80 '         add     t5,#$30         ' ... to digit char
37a8(0089): c6 9c fd 5c '         call    #t_put5         ' write char to screen
37ac(008a): a3 00 7c 5c '         jmp     #done_ok
37b0(008b):             ' t_unsigned
37b0(008b): c3 8a fd 5c '         call    #t_getnum       ' get number to print
37b4(008c): 70 00 7c 5c '         jmp     #t_uint         ' no sign, just print digits
37b8(008d):             ' t_hex
37b8(008d): c3 8a fd 5c '         call    #t_getnum       ' and get number to print
37bc(008e): 08 e6 fd a0 '         mov     t4,#8           ' print 8 digits
37c0(008f):             ' :t_hex1
37c0(008f): 04 da fd 24 '         rol     rqst,#4         ' convert 4 bits ...
37c4(0090): ed e8 bd a0 '         mov     t5,rqst         ' ... to '0' .. '9'
37c8(0091): 0f e8 fd 60 '         and     t5,#$f          ' ... or ...
37cc(0092): 0a e8 7d 87 '         cmp     t5,#10 wc,wz    ' ... 'A' .. 'F' ...
37d0(0093): 07 e8 cd 80 '  if_ae  add     t5,#($41-$30-10)' ... depending ...
37d4(0094): 30 e8 fd 80 '         add     t5,#$30         ' ... on the digit value
37d8(0095): c6 9c fd 5c '         call    #t_put5         ' write char to screen
37dc(0096): 8f e6 fd e4 '         djnz    t4,#:t_hex1     ' continue with next digit
37e0(0097): a3 00 7c 5c '         jmp     #done_ok
37e4(0098):             ' t_bin
37e4(0098): c3 8a fd 5c '         call    #t_getnum       ' get number to print
37e8(0099): 20 e6 fd a0 '         mov     t4,#32          ' print 32 digits
37ec(009a):             ' :t_bin1
37ec(009a): 01 da fd 24 '         rol     rqst,#1         ' convert bit ...
37f0(009b): ed e8 bd a0 '         mov     t5,rqst         ' ... to '0' ...
37f4(009c): 01 e8 fd 60 '         and     t5,#1           ' ... or ...
37f8(009d): 30 e8 fd 80 '         add     t5,#$30         ' ... '1'
37fc(009e): c6 9c fd 5c '         call    #t_put5         ' write char to screen
3800(009f): 9a e6 fd e4 '         djnz    t4,#:t_bin1     ' continue with next digit
3804(00a0): a3 00 7c 5c '         jmp     #done_ok
3808(00a1):             ' done_bad
3808(00a1): 01 dc fd a4 '         neg     rslt,#1         ' unknown code specified
380c(00a2): a4 00 7c 5c '         jmp     #done
3810(00a3):             ' done_ok
3810(00a3): 00 dc fd a0 '         mov      rslt,#0        ' return zero
3814(00a4):             ' done
3814(00a4): ec dc 3d 08 '         wrlong   rslt,rsltptr   ' save result
3818(00a5): 00 dc fd a0 '         mov      rslt,#0        ' indicate ...
381c(00a6): eb dc 3d 08 '         wrlong   rslt,rqstptr   ' ... request complete
3820(00a7): 07 00 7c 5c '         jmp      #loop          ' wait for next request
3824(00a8):             ' k_setup
3824(00a8): fa de bd a0 '         mov     t0,ppkbd        ' get ...
3828(00a9): ef e2 bd 08 '         rdlong  t2,t0           ' ... par_head
382c(00aa): 04 de fd 80 '         add     t0,#4           ' get ...
3830(00ab): ef e0 bd 08 '         rdlong  t1,t0           ' ... par_tail
3834(00ac): f0 dc bd a0 '         mov     rslt,t1         ' set Z flag ...
3838(00ad): f1 dc bd 86 '         sub     rslt,t2 wz      ' ... and rslt = 0 if par_tail == par_head
383c(00ae):             ' k_setup_ret
383c(00ae): 00 00 7c 5c '         ret
3840(00af):             ' k_load
3840(00af): a8 5c fd 5c '         call    #k_setup        ' setup common values
3844(00b0): b9 00 68 5c '  if_z   jmp     #k_load_ret     ' Z flag set if no key available
3848(00b1): 10 de fd 80 '         add     t0,#16          ' get ...
384c(00b2): ef de bd 08 '         rdlong  t0,t0           ' ... bufaddr
3850(00b3): ef dc bd a0 '         mov     rslt,t0         ' load key ...
3854(00b4): f0 dc bd 80 '         add     rslt,t1         ' ... indicated ...
3858(00b5): ee dc bd 00 '         rdbyte  rslt,rslt       ' ... by par_tail
385c(00b6): 04 dc 7d 86 '         cmp     rslt,#$04 wz    ' EOT?
3860(00b7): 01 dc e9 a4 '  if_z   neg     rslt,#1         ' if so, return -1 (EOF)
3864(00b8): 01 de fd a2 '         mov     t0,#1 wz        ' ensure Z flag not set!
3868(00b9):             ' k_load_ret
3868(00b9): 00 00 7c 5c '         ret
386c(00ba):             ' t_setup
386c(00ba): fd de bd a0 '         mov     t0,pptv         ' get ...
3870(00bb): ef e2 bd 08 '         rdlong  t2,t0           ' ... tx_head
3874(00bc): 04 de fd 80 '         add     t0,#4           ' get ...
3878(00bd): ef e0 bd 08 '         rdlong  t1,t0           ' ... tx_tail
387c(00be): f1 e4 bd a0 '         mov     t3,t2           ' set Z flag ...
3880(00bf): 01 e4 fd 80 '         add     t3,#1           ' ... if ...
3884(00c0): ff e5 fd 60 '         and     t3,#$1ff        ' ... tx_tail 
3888(00c1): f2 e0 3d 86 '         cmp     t1,t3 wz        ' ... == (tx_head + 1) & $1ff
388c(00c2):             ' t_setup_ret
388c(00c2): 00 00 7c 5c '         ret
3890(00c3):             ' t_getnum
3890(00c3): e1 da bd 60 '         and     rqst,low23      ' source address is lower 23 bits of request
3894(00c4): ed da bd 0a '         rdlong  rqst,rqst wz    ' get the actual number in the rquest
3898(00c5):             ' t_getnum_ret                                
3898(00c5): 00 00 7c 5c '         ret
389c(00c6):             ' t_put5
389c(00c6): ba 84 fd 5c '         call    #t_setup        ' setup common values
38a0(00c7): c6 00 68 5c '  if_z   jmp     #t_put5         ' repeat until (tx_tail <> (tx_head + 1) & $1FF)
38a4(00c8): 0c de fd 80 '         add     t0,#12          ' txbuffer...
38a8(00c9): ef de bd 08 '         rdlong  t0,t0           ' ...
38ac(00ca): f1 de bd 80 '         add     t0,t2           ' ... [tx_head] ...
38b0(00cb): ef e8 3d 00 '         wrbyte  t5,t0           ' ... := t5
38b4(00cc): fd de bd a0 '         mov     t0,pptv         ' tx_head ...
38b8(00cd): ef e4 3d 08 '         wrlong  t3,t0           ' ... := (tx_head + 1) & $1FF
38bc(00ce):             ' t_put5_ret
38bc(00ce): 00 00 7c 5c '         ret
38c0(00cf):             ' m32
38c0(00cf): 00 de fd a0 '         mov t0,#0
38c4(00d0): d3 e2 7d ec '         tjz t2,#m32_ret
38c8(00d1):             ' :m32_loop
38c8(00d1): f0 de bd 80 '         add t0,t1
38cc(00d2): d1 e2 fd e4 '         djnz t2,#:m32_loop
38d0(00d3):             ' m32_ret
38d0(00d3): 00 00 7c 5c '         ret
38d4(00d4):             ' d32u
38d4(00d4): 20 f0 fd a0 '         mov d1,#32
38d8(00d5): 00 f2 fd a0 '         mov d2, #0
38dc(00d6):             ' :d32up
38dc(00d6): 01 de fd 2d '         shl t0,#1    WC
38e0(00d7): 01 f2 fd 35 '         rcl d2,#1    WC
38e4(00d8): f9 e0 3d 87 '         cmp t1,d2    WC,WZ
38e8(00d9): dc 00 44 5c '  if_a   jmp #:d32down
38ec(00da): f0 f2 bd 84 '         sub d2,t1
38f0(00db): 01 de fd 80 '         add t0,#1
38f4(00dc):             ' :d32down
38f4(00dc): 01 f0 fd 86 '         sub d1, #1   WZ
38f8(00dd): d6 00 54 5c '  if_ne  jmp #:d32up
38fc(00de): f9 e0 bd a0 '         mov t1,d2
3900(00df):             ' d32u_ret
3900(00df): 00 00 7c 5c '         ret
3904(00e0): 00 00 80 00 ' curs_1  long     $00800000
3908(00e1): ff ff 7f 00 ' low23   long     $007FFFFF
390c(00e2): ff ff ff 00 ' low24   long     $00ffffff
3910(00e3): 00 ca 9a 3b ' maxdec  long     1000000000     ' maximum decimal divisor for 32 bit values
3914(00e4): 00 02 00 00 ' ctrl    long     $00000200      ' mask to detect control keys
3918(00e5): 00 fd ff ff ' noctrl  long     $fffffd00      ' mask to correct control keys
391c(00e6): 20 02 00 00 ' space   long     $00000220      ' space used when filling
3920(00e7): 00 00 00 00 ' lastcur long     $0
3924(00e8): 00 00 00 00 ' kstat   long     $0
3928(00e9): 00 02 00 00 ' hex200  long     $200
392c(00ea): 32 03 00 00 ' c_snail long     $332           ' control snail should return NUL 
3930(00eb):             ' rqstptr res      1      ' address of my request block
3930(00ec):             ' rsltptr res      1      ' address to put results
3930(00ed):             ' rqst    res      1      ' request being processed
3930(00ee):             ' rslt    res      1      ' result to return
3930(00ef):             ' t0      res      1
3930(00f0):             ' t1      res      1
3930(00f1):             ' t2      res      1
3930(00f2):             ' t3      res      1
3930(00f3):             ' t4      res      1
3930(00f4):             ' t5      res      1
3930(00f5):             ' t6      res      1
3930(00f6):             ' t7      res      1
3930(00f7):             ' t8      res      1
3930(00f8):             ' d1      res      1      ' used when dividing
3930(00f9):             ' d2      res      1      ' used when dividing
3930(00fa):             ' ppkbd   res      1
3930(00fb):             ' ppmouse res      1
3930(00fc):             ' ppscrn  res      1
3930(00fd):             ' pptv    res      1
3930(00fe):             ' scrcols res      1      ' screen cols
3930(00ff):             ' scrrows res      1      ' screen rows
3930(0100):             ' scrsize res      1      ' screen size
3930(0101):             ' scrbuff res      1      ' pointer to screen buffer
3930(0102):             ' scrclrs res      1      ' current color data
3930(0103):             ' scrpall res      1      ' pointer to screen palette
3930(0104):             ' scrcurs res      1      ' pointer to screen cursors
'========================= Method #1: PUB ProxySetup ==========================
'PUB ProxySetup(io_block, proxy_lock, server_cpu)
'------------------------------------------------------------------------------
  v_io_block     := io_block
'------------------------------------------------------------------------------
3930: 64             PUSH 	Locals+4
3931: 41             POP  	VAR+0
'------------------------------------------------------------------------------
  v_proxy_lock   := proxy_lock
'------------------------------------------------------------------------------
3932: 68             PUSH 	Locals+8
3933: 45             POP  	VAR+4
'------------------------------------------------------------------------------
  v_Server_cpu   := server_cpu
'------------------------------------------------------------------------------
3934: 6c             PUSH 	Locals+12
3935: 49             POP  	VAR+8
3936: 32             RETURN	
'=========================== Method #2: PUB Start =============================
'PUB Start (registry, data, start_kbd, start_mouse, start_screen) : ok | prqst, pkbd, pmouse, pscreen, ptv, px_pkbd, px_pmouse, px_pscreen, px_ptv, px_ioblk, px_lock, px_cpu, cog
'------------------------------------------------------------------------------
  pkbd    := data
'------------------------------------------------------------------------------
3937: 68             PUSH 	Locals+8
3938: 7d             POP  	Locals+28
'------------------------------------------------------------------------------
  pmouse  := 0  
'------------------------------------------------------------------------------
3939: 35             PUSH#0	
393a: cd 20          POP.L	Locals+32
'------------------------------------------------------------------------------
  pscreen := pkbd    + 4 * kbd#kb_count  
'------------------------------------------------------------------------------
393c: 7c             PUSH 	Locals+28
393d: 37 01          PUSH#kp	4 ($4)
393f: 38 0a          PUSH#k1	10
3941: f4             MPY  	
3942: ec             ADD  	
3943: cd 24          POP.L	Locals+36
'------------------------------------------------------------------------------
  ptv     := pscreen + 4 * sc_count 
'------------------------------------------------------------------------------
3945: cc 24          PUSH.L	Locals+36
3947: 37 01          PUSH#kp	4 ($4)
3949: 39 01 19       PUSH#k2	281
394c: f4             MPY  	
394d: ec             ADD  	
394e: cd 28          POP.L	Locals+40
'------------------------------------------------------------------------------
  long[pscreen][nx] := cols
'------------------------------------------------------------------------------
3950: 38 28          PUSH#k1	40
3952: cc 24          PUSH.L	Locals+36
3954: 35             PUSH#0	
3955: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[pscreen][ny] := rows
'------------------------------------------------------------------------------
3956: 38 0d          PUSH#k1	13
3958: cc 24          PUSH.L	Locals+36
395a: 36             PUSH#1	
395b: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  if start_kbd
'------------------------------------------------------------------------------
395c: 6c             PUSH 	Locals+12
395d: 0a 07          JPF  	.+7 (dest:$3966)
'------------------------------------------------------------------------------
    kbd.start(pkbd, common#SI_PIN)
'------------------------------------------------------------------------------
395f: 01             FRAME	Call without return value	
3960: 7c             PUSH 	Locals+28
3961: 37 24          PUSH#kp	31 ($1f)
3963: 06 03 01       CALLOBJ	3:1
'------------------------------------------------------------------------------
  px_pkbd := 0
'------------------------------------------------------------------------------
3966: 35             PUSH#0	
3967: cd 2c          POP.L	Locals+44
'------------------------------------------------------------------------------
  if start_screen
'------------------------------------------------------------------------------
3969: 74             PUSH 	Locals+20
396a: 0a 0d          JPF  	.+13 (dest:$3979)
'------------------------------------------------------------------------------
    screen.start(ptv, common#SO_PIN, @long[pscreen][buffer])
'------------------------------------------------------------------------------
396c: 01             FRAME	Call without return value	
396d: cc 28          PUSH.L	Locals+40
396f: 38 1e          PUSH#k1	30
3971: cc 24          PUSH.L	Locals+36
3973: 37 21          PUSH#kp	3 ($3)
3975: d3             PUSH#.L	Mem[][]
3976: 06 04 01       CALLOBJ	4:1
'------------------------------------------------------------------------------
  px_pscreen := 0
'------------------------------------------------------------------------------
3979: 35             PUSH#0	
397a: cd 34          POP.L	Locals+52
'------------------------------------------------------------------------------
  cog := cognew(@HmiStart, registry)
'------------------------------------------------------------------------------
397c: 34             PUSH#-1	
397d: c7 18          PUSH#.L	OBJ+24
397f: 64             PUSH 	Locals+4
3980: 28             COGIFUN	
3981: cd 48          POP.L	Locals+72
'------------------------------------------------------------------------------
  ok := (cog => 0)
'------------------------------------------------------------------------------
3983: cc 48          PUSH.L	Locals+72
3985: 35             PUSH#0	
3986: fe             GE   	
3987: 61             POP  	Locals+0
'------------------------------------------------------------------------------
  if ok
'------------------------------------------------------------------------------
3988: 60             PUSH 	Locals+0
3989: 0a 15          JPF  	.+21 (dest:$39a0)
'------------------------------------------------------------------------------
    common.SendInitializationData(cog, @pkbd, 0)
'------------------------------------------------------------------------------
398b: 01             FRAME	Call without return value	
398c: cc 48          PUSH.L	Locals+72
398e: 7f             PUSH#	Locals+28
398f: 35             PUSH#0	
3990: 06 05 04       CALLOBJ	5:4
'------------------------------------------------------------------------------
    common.WaitForRequest(cog)
'------------------------------------------------------------------------------
3993: 01             FRAME	Call without return value	
3994: cc 48          PUSH.L	Locals+72
3996: 06 05 05       CALLOBJ	5:5
'------------------------------------------------------------------------------
    common.Register(cog, common#LMM_HMI)
'------------------------------------------------------------------------------
3999: 01             FRAME	Call without return value	
399a: cc 48          PUSH.L	Locals+72
399c: 36             PUSH#1	
399d: 06 05 02       CALLOBJ	5:2
39a0: 32             RETURN	
39a1: 00 00 00    

'******************************************************************************
'                          Catalina_PC_Keyboard.spin                           
'******************************************************************************

'=================================== CONs =====================================
BAUDRATE = 115200
RXINVERSE = 0
kb_count = 10
rx_pin = 2
rx_mode = 3
rx_ticks = 4
rx_bufptr = 5
rx_buffer = 6
'=============================== Object Header ================================
39a4: f8 00 02 01 ' 248 bytes, 2-1 methods, 1 object pointers
39a8: c4 00 00 00 ' ptr #1 to $3a68: PUB start (locals size: 0)
39ac: c0 01 00 00 ' ptr #2 to $3b64: OBJ Common : Catalina_Common.spin (VAR offset: 0)
'================================ DAT Section =================================
39b0(0000):             '                         org     0
39b0(0000): f0 5d bc a0 ' entry                   mov     t1,par                'get structure address
39b4(0001): 08 5c fc 80 '                         add     t1,#2 << 2            'skip past heads and tails
39b8(0002): 2e 5e bc 08 '                         rdlong  t2,t1                 'get rx_pin
39bc(0003): 01 64 fc a0 '                         mov     rxmask,#1
39c0(0004): 2f 64 bc 2c '                         shl     rxmask,t2
39c4(0005): 04 5c fc 80 '                         add     t1,#4                 'get rx_mode
39c8(0006): 2e 60 bc 08 '                         rdlong  rxmode,t1
39cc(0007): 04 5c fc 80 '                         add     t1,#4                 'get bit_ticks
39d0(0008): 2e 62 bc 08 '                         rdlong  bitticks,t1
39d4(0009): 04 5c fc 80 '                         add     t1,#4                 'get buffer_ptr
39d8(000a): 2e 66 bc 08 '                         rdlong  rxbuff,t1
39dc(000b): 01 60 7c 62 ' receive                 test    rxmode,#%001    wz    'wait for start bit on rx pin
39e0(000c): f2 65 3c 61 '                         test    rxmask,ina      wc
39e4(000d): 0b 00 64 5c '         if_z_eq_c       jmp     #receive
39e8(000e): 09 6a fc a0 '                         mov     rxbits,#9             'ready to receive byte
39ec(000f): 31 6c bc a0 '                         mov     rxcnt,bitticks
39f0(0010): 01 6c fc 28 '                         shr     rxcnt,#1
39f4(0011): f1 6d bc 80 '                         add     rxcnt,cnt                          
39f8(0012): 31 6c bc 80 ' :bit                    add     rxcnt,bitticks        'ready next bit period
39fc(0013): 36 5c bc a0 ' :wait                   mov     t1,rxcnt              'check if bit receive period done
3a00(0014): f1 5d bc 84 '                         sub     t1,cnt
3a04(0015): 00 5c 7c c1 '                         cmps    t1,#0           wc
3a08(0016): 13 00 4c 5c '         if_nc           jmp     #:wait
3a0c(0017): f2 65 3c 61 '                         test    rxmask,ina      wc    'receive bit on rx pin
3a10(0018): 01 68 fc 30 '                         rcr     rxdata,#1
3a14(0019): 12 6a fc e4 '                         djnz    rxbits,#:bit
3a18(001a): 17 68 fc 28 '                         shr     rxdata,#32-9          'justify and trim received byte
3a1c(001b): ff 68 fc 60 '                         and     rxdata,#$FF
3a20(001c): 01 60 7c 62 '                         test    rxmode,#%001    wz    'if rx inverted, invert byte
3a24(001d): ff 68 d4 6c '         if_nz           xor     rxdata,#$FF
3a28(001e): 00 5a 7c 86 '                         cmp     mscnt,#0        wz     'mouse receiving?
3a2c(001f): 23 00 54 5c '         if_nz           jmp     #getMsPar
3a30(0020): 05 68 7c 86 '                         cmp     rxdata,#5      wz     'new mouse Event?
3a34(0021): 25 00 54 5c '         if_nz           jmp     #toRxBuff             'no: write in buffer
3a38(0022): 04 5a fc a0 '                         mov     mscnt,#4              '4 bytes to ignore
3a3c(0023): 01 5a fc 84 ' getMsPar                sub     mscnt,#1              'ignore byte
3a40(0024): 0b 00 7c 5c '                         jmp     #receive
3a44(0025): f0 5f bc 08 ' toRxBuff                rdlong  t2,par                'save received byte and inc head
3a48(0026): 33 5e bc 80 '                         add     t2,rxbuff
3a4c(0027): 2f 68 3c 00 '                         wrbyte  rxdata,t2
3a50(0028): 33 5e bc 84 '                         sub     t2,rxbuff
3a54(0029): 01 5e fc 80 '                         add     t2,#1
3a58(002a): 0f 5e fc 60 '                         and     t2,#$0F
3a5c(002b): f0 5f 3c 08 '                         wrlong  t2,par
3a60(002c): 0b 00 7c 5c '                         jmp     #receive
3a64(002d): 00 00 00 00 ' mscnt                   long    0
3a68(002e):             ' t1                      res     1
3a68(002f):             ' t2                      res     1
3a68(0030):             ' rxmode                  res     1
3a68(0031):             ' bitticks                res     1
3a68(0032):             ' rxmask                  res     1
3a68(0033):             ' rxbuff                  res     1
3a68(0034):             ' rxdata                  res     1
3a68(0035):             ' rxbits                  res     1
3a68(0036):             ' rxcnt                   res     1
3a68(0037):             ' rxcode                  res     1
'=========================== Method #1: PUB start =============================
'PUB start(kb_block, basepin) : okay
'------------------------------------------------------------------------------
  longfill(kb_block, 0, kb_count)
'------------------------------------------------------------------------------
3a68: 64             PUSH 	Locals+4
3a69: 35             PUSH#0	
3a6a: 38 0a          PUSH#k1	10
3a6c: 1a             LONGFIL	
'------------------------------------------------------------------------------
  long[kb_block][rx_pin]    := basepin
'------------------------------------------------------------------------------
3a6d: 68             PUSH 	Locals+8
3a6e: 64             PUSH 	Locals+4
3a6f: 37 00          PUSH#kp	2 ($2)
3a71: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[kb_block][rx_mode]   := RXINVERSE
'------------------------------------------------------------------------------
3a72: 35             PUSH#0	
3a73: 64             PUSH 	Locals+4
3a74: 37 21          PUSH#kp	3 ($3)
3a76: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[kb_block][rx_ticks]  := Common#CLOCKFREQ / BAUDRATE
'------------------------------------------------------------------------------
3a77: 3b 04 c4 b4 00 PUSH#k4	80000000
3a7c: 3a 01 c2 00    PUSH#k3	115200
3a80: f6             DIV  	
3a81: 64             PUSH 	Locals+4
3a82: 37 01          PUSH#kp	4 ($4)
3a84: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[kb_block][rx_bufptr] := kb_block + rx_buffer*4 
'------------------------------------------------------------------------------
3a85: 64             PUSH 	Locals+4
3a86: 38 06          PUSH#k1	6
3a88: 37 01          PUSH#kp	4 ($4)
3a8a: f4             MPY  	
3a8b: ec             ADD  	
3a8c: 64             PUSH 	Locals+4
3a8d: 38 05          PUSH#k1	5
3a8f: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  okay := cognew(@entry, kb_block) + 1
'------------------------------------------------------------------------------
3a90: 34             PUSH#-1	
3a91: c7 0c          PUSH#.L	OBJ+12
3a93: 64             PUSH 	Locals+4
3a94: 28             COGIFUN	
3a95: 36             PUSH#1	
3a96: ec             ADD  	
3a97: 61             POP  	Locals+0
3a98: 32             RETURN	
3a99: 00 00 00    

'******************************************************************************
'                            Catalina_PC_Text.spin                             
'******************************************************************************

'=================================== CONs =====================================
BAUDRATE = 115200
cols = 40
rows = 13
tv_count = 5
tx_pin = 2
tx_ticks = 3
tx_buffer = 4
'=============================== Object Header ================================
3a9c: c8 00 02 01 ' 200 bytes, 2-1 methods, 1 object pointers
3aa0: a0 00 00 00 ' ptr #1 to $3b3c: PUB start (locals size: 0)
3aa4: c8 00 00 00 ' ptr #2 to $3b64: OBJ Common : Catalina_Common.spin (VAR offset: 0)
'================================ DAT Section =================================
3aa8(0000):             '                         org     0
3aa8(0000): f0 4b bc a0 ' entry                   mov     t1,par                'get structure address
3aac(0001): 08 4a fc 80 '                         add     t1,#2 << 2            'skip past heads and tails
3ab0(0002): 25 4c bc 08 '                         rdlong  t2,t1                 'get tx_pin
3ab4(0003): 01 54 fc a0 '                         mov     txmask,#1
3ab8(0004): 26 54 bc 2c '                         shl     txmask,t2 
3abc(0005): 2a e8 bf 68 '                         or      outa,txmask           'idle = 1  
3ac0(0006): 2a ec bf 68 '                         or      dira,txmask           'Pin30 = output
3ac4(0007): 04 4a fc 80 '                         add     t1,#4                 'get bit_ticks
3ac8(0008): 25 52 bc 08 '                         rdlong  bittime,t1
3acc(0009): 04 4a fc 80 '                         add     t1,#4                 'get buffer_ptr
3ad0(000a): 25 5a bc 08 '                         rdlong  txbuff,t1
3ad4(000b): f0 4b bc a0 ' transmit                mov     t1,par                'check for head <> tail
3ad8(000c): 25 4c bc 08 '                         rdlong  t2,t1
3adc(000d): 04 4a fc 80 '                         add     t1,#1 << 2
3ae0(000e): 25 4e bc 08 '                         rdlong  t3,t1
3ae4(000f): 27 4c 3c 86 '                         cmp     t2,t3           wz
3ae8(0010): 0b 00 68 5c '         if_z            jmp     #transmit
3aec(0011): 2d 4e bc 80 ' sendloop                add     t3,txbuff             'get byte and inc tail
3af0(0012): 27 56 bc 00 '                         rdbyte  txdata,t3
3af4(0013): 2d 4e bc 84 '                         sub     t3,txbuff
3af8(0014): 01 4e fc 80 '                         add     t3,#1
3afc(0015): ff 4f fc 60 '                         and     t3,#$1FF
3b00(0016): 25 4e 3c 08 '                         wrlong  t3,t1
3b04(0017): 0a 58 fc a0 '                         mov     txcnt,#10
3b08(0018): 00 57 fc 68 '                         or      txdata,#$100          'add stoppbit
3b0c(0019): 01 56 fc 2c '                         shl     txdata,#1             'add startbit
3b10(001a): f1 51 bc a0 '                         mov     dtime,cnt
3b14(001b): 29 50 bc 80 '                         add     dtime,bittime
3b18(001c): 01 56 fc 29 ' sendbit                 shr     txdata,#1    wc       'test LSB
3b1c(001d): f4 4d bc a0 '                         mov     t2,outa
3b20(001e): 2a 4c 8c 64 '               if_nc     andn    t2,txmask             'bit=0  or
3b24(001f): 2a 4c b0 68 '               if_c      or      t2,txmask             'bit=1
3b28(0020): 26 e8 bf a0 '                         mov     outa,t2
3b2c(0021): 29 50 bc f8 '                         waitcnt dtime,bittime         'wait 1 bit
3b30(0022): 1c 58 fc e4 '                         djnz    txcnt,#sendbit        '10 times
3b34(0023): 29 50 bc f8 '                         waitcnt dtime,bittime         '2 stopbits
3b38(0024): 0b 00 7c 5c '                         jmp     #transmit             'done,wait for next
3b3c(0025):             ' t1                      res     1
3b3c(0026):             ' t2                      res     1
3b3c(0027):             ' t3                      res     1
3b3c(0028):             ' dtime                   res     1
3b3c(0029):             ' bittime                 res     1
3b3c(002a):             ' txmask                  res     1
3b3c(002b):             ' txdata                  res     1
3b3c(002c):             ' txcnt                   res     1
3b3c(002d):             ' txbuff                  res     1
'=========================== Method #1: PUB start =============================
'PUB start(tv_block, basepin, buffer) : okay
'------------------------------------------------------------------------------
  longfill(tv_block, 0, tv_count)
'------------------------------------------------------------------------------
3b3c: 64             PUSH 	Locals+4
3b3d: 35             PUSH#0	
3b3e: 38 05          PUSH#k1	5
3b40: 1a             LONGFIL	
'------------------------------------------------------------------------------
  long[tv_block][tx_pin] := basepin
'------------------------------------------------------------------------------
3b41: 68             PUSH 	Locals+8
3b42: 64             PUSH 	Locals+4
3b43: 37 00          PUSH#kp	2 ($2)
3b45: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[tv_block][tx_ticks]:= Common#CLOCKFREQ / BAUDRATE
'------------------------------------------------------------------------------
3b46: 3b 04 c4 b4 00 PUSH#k4	80000000
3b4b: 3a 01 c2 00    PUSH#k3	115200
3b4f: f6             DIV  	
3b50: 64             PUSH 	Locals+4
3b51: 37 21          PUSH#kp	3 ($3)
3b53: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[tv_block][tx_buffer] := buffer
'------------------------------------------------------------------------------
3b54: 6c             PUSH 	Locals+12
3b55: 64             PUSH 	Locals+4
3b56: 37 01          PUSH#kp	4 ($4)
3b58: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  okay := cognew(@entry, tv_block) + 1 
'------------------------------------------------------------------------------
3b59: 34             PUSH#-1	
3b5a: c7 0c          PUSH#.L	OBJ+12
3b5c: 64             PUSH 	Locals+4
3b5d: 28             COGIFUN	
3b5e: 36             PUSH#1	
3b5f: ec             ADD  	
3b60: 61             POP  	Locals+0
3b61: 32             RETURN	
3b62: 00 00       

'******************************************************************************
'                            Catalina_Common.spin                              
'******************************************************************************

'=================================== CONs =====================================
SI_PIN = 31
SO_PIN = 30
CLOCKMODE = 1032
XTALFREQ = 5000000
CLOCKFREQ = 80000000
STACKSIZE = 50
LMM_HMI = 1
COGSTORE = 32508
REGISTRY_END = 32508
REGISTRY = 32476
REQUESTS = 32412
ARGC_ADDR = 32560
ARGV_ADDR = 32562
ARGV_0 = 32564
ARGV_MAX = 32
'=============================== Object Header ================================
3b64: 88 00 06 00 ' 136 bytes, 6-1 methods, 0 object pointers
3b68: 18 00 04 00 ' ptr #1 to $3b7c: PUB InitializeRegistry (locals size: 4)
3b6c: 42 00 00 00 ' ptr #2 to $3ba6: PUB Register (locals size: 0)
3b70: 55 00 00 00 ' ptr #3 to $3bb9: PUB UnRegister (locals size: 0)
3b74: 63 00 00 00 ' ptr #4 to $3bc7: PUB SendInitializationData (locals size: 0)
3b78: 78 00 00 00 ' ptr #5 to $3bdc: PUB WaitForRequest (locals size: 0)
'===================== Method #1: PUB InitializeRegistry ======================
'PUB InitializeRegistry | i
'------------------------------------------------------------------------------
  repeat i from 0 to 7
'------------------------------------------------------------------------------
3b7c: 35             PUSH#0	
3b7d: 65             POP  	Locals+4
'------------------------------------------------------------------------------
    long[REGISTRY][i] := REQUESTS + (8*i)
'------------------------------------------------------------------------------
3b7e: 39 7e 9c       PUSH#k2	32412
3b81: 37 02          PUSH#kp	8 ($8)
3b83: 64             PUSH 	Locals+4
3b84: f4             MPY  	
3b85: ec             ADD  	
3b86: 39 7e dc       PUSH#k2	32476
3b89: 64             PUSH 	Locals+4
3b8a: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
    long[REQUESTS][2 * i] := 0
'------------------------------------------------------------------------------
3b8b: 35             PUSH#0	
3b8c: 39 7e 9c       PUSH#k2	32412
3b8f: 37 00          PUSH#kp	2 ($2)
3b91: 64             PUSH 	Locals+4
3b92: f4             MPY  	
3b93: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
    long[REQUESTS][2 * i + 1] := 0
'------------------------------------------------------------------------------
3b94: 35             PUSH#0	
3b95: 39 7e 9c       PUSH#k2	32412
3b98: 37 00          PUSH#kp	2 ($2)
3b9a: 64             PUSH 	Locals+4
3b9b: f4             MPY  	
3b9c: 36             PUSH#1	
3b9d: ec             ADD  	
3b9e: d1             POP.L	Mem[][]
3b9f: 35             PUSH#0	
3ba0: 37 22          PUSH#kp	7 ($7)
3ba2: 66 02 59       USING	Locals+4, RPTINCJ .-39 (dest:$3b7e)
3ba5: 32             RETURN	
'========================== Method #2: PUB Register ===========================
'PUB Register (my_cog, my_plugin_type)
'------------------------------------------------------------------------------
  long[REGISTRY][my_cog] := (my_plugin_type<<24) + (long[REGISTRY][my_cog] & $00FFFFFF)
'------------------------------------------------------------------------------
3ba6: 68             PUSH 	Locals+8
3ba7: 38 18          PUSH#k1	24
3ba9: e3             SHL  	
3baa: 39 7e dc       PUSH#k2	32476
3bad: 64             PUSH 	Locals+4
3bae: d0             PUSH.L	Mem[][]
3baf: 37 37          PUSH#kp	16777215 ($ffffff)
3bb1: e8             BIT_AND	
3bb2: ec             ADD  	
3bb3: 39 7e dc       PUSH#k2	32476
3bb6: 64             PUSH 	Locals+4
3bb7: d1             POP.L	Mem[][]
3bb8: 32             RETURN	
'========================= Method #3: PUB UnRegister ==========================
'PUB UnRegister (my_cog)
'------------------------------------------------------------------------------
  long[REGISTRY][my_cog] := (long[REGISTRY][my_cog] & $00FFFFFF)
'------------------------------------------------------------------------------
3bb9: 39 7e dc       PUSH#k2	32476
3bbc: 64             PUSH 	Locals+4
3bbd: d0             PUSH.L	Mem[][]
3bbe: 37 37          PUSH#kp	16777215 ($ffffff)
3bc0: e8             BIT_AND	
3bc1: 39 7e dc       PUSH#k2	32476
3bc4: 64             PUSH 	Locals+4
3bc5: d1             POP.L	Mem[][]
3bc6: 32             RETURN	
'=================== Method #4: PUB SendInitializationData ====================
'PUB SendInitializationData(to_cog, data_1, data_2)
'------------------------------------------------------------------------------
  long[REQUESTS][2 * to_cog + 1] := data_2
'------------------------------------------------------------------------------
3bc7: 6c             PUSH 	Locals+12
3bc8: 39 7e 9c       PUSH#k2	32412
3bcb: 37 00          PUSH#kp	2 ($2)
3bcd: 64             PUSH 	Locals+4
3bce: f4             MPY  	
3bcf: 36             PUSH#1	
3bd0: ec             ADD  	
3bd1: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[REQUESTS][2 * to_cog]     := data_1
'------------------------------------------------------------------------------
3bd2: 68             PUSH 	Locals+8
3bd3: 39 7e 9c       PUSH#k2	32412
3bd6: 37 00          PUSH#kp	2 ($2)
3bd8: 64             PUSH 	Locals+4
3bd9: f4             MPY  	
3bda: d1             POP.L	Mem[][]
3bdb: 32             RETURN	
'======================= Method #5: PUB WaitForRequest ========================
'PUB WaitForRequest(to_cog)
'------------------------------------------------------------------------------
  repeat while long[REQUESTS][2 * to_cog] <> 0
'------------------------------------------------------------------------------
3bdc: 39 7e 9c       PUSH#k2	32412
3bdf: 37 00          PUSH#kp	2 ($2)
3be1: 64             PUSH 	Locals+4
3be2: f4             MPY  	
3be3: d0             PUSH.L	Mem[][]
3be4: 35             PUSH#0	
3be5: fb             NE   	
3be6: 0a 02          JPF  	.+2 (dest:$3bea)
3be8: 04 72          GOTO 	.-14 (dest:$3bdc)
3bea: 32             RETURN	
3beb: 00          
3bec: 00 00 00 00             ' LONG HMI.v_io_block
3bf0: 00 00 00 00             ' LONG HMI.v_proxy_lock
3bf4: 00 00 00 00             ' LONG HMI.v_server_cpu
3bf8: ff ff f9 ff ff ff f9 ff 

