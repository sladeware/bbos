0000: 00 b4 c4 04 ' Frequency: 80000000 Hz
0004: 6f          ' XTAL mode
0005: 5c          ' Checksum
0006: 10 00       ' Base of program
0008: 30 38       ' Base of variables
000a: 44 38       ' Base of stack
000c: 2c 00       ' Initial program counter
000e: 64 38       ' Initial stack pointer

'******************************************************************************
'                              lmm_default.spin                                
'******************************************************************************

'=================================== CONs =====================================
_clkmode = 1032
_xinfreq = 5000000
_stack = 50
START_SCREEN = -1
START_KBD = -1
START_MOUSE = -1
'=============================== Object Header ================================
0010: 6c 00 02 05 ' 108 bytes, 2-1 methods, 5 object pointers
0014: 1c 00 1c 00 ' ptr #1 to $002c: PUB Start (locals size: 28)
0018: 6c 00 00 00 ' ptr #2 to $007c: OBJ Catalina : Catalina.spin (VAR offset: 0)
001c: 98 37 00 00 ' ptr #3 to $37a8: OBJ Common : Catalina_Common.spin (VAR offset: 0)
0020: 4c 26 00 00 ' ptr #4 to $265c: OBJ Cogstore : Catalina_Cogstore.spin (VAR offset: 0)
0024: f8 29 00 00 ' ptr #5 to $2a08: OBJ Kernel : Catalina_LMM.spin (VAR offset: 0)
0028: a0 31 00 00 ' ptr #6 to $31b0: OBJ HMI : Catalina_HMI_Plugin_PC.spin (VAR offset: 0)
'=========================== Method #1: PUB Start =============================
'PUB Start : ok | cog, ALLOC, HMI_DATA, IO_BLOCK, Proxy_Lock, Server_CPU, s
'------------------------------------------------------------------------------
  Common.InitializeRegistry
'------------------------------------------------------------------------------
002c: 01             FRAME	Call without return value	
002d: 06 03 01       CALLOBJ	3:1
'------------------------------------------------------------------------------
  ALLOC := Common#REQUESTS
'------------------------------------------------------------------------------
0030: 39 7e 9c       PUSH#k2	32412
0033: 69             POP  	Locals+8
'------------------------------------------------------------------------------
  ok         := TRUE
'------------------------------------------------------------------------------
0034: 34             PUSH#-1	
0035: 61             POP  	Locals+0
'------------------------------------------------------------------------------
  Proxy_Lock := -1
'------------------------------------------------------------------------------
0036: 34             PUSH#-1	
0037: 75             POP  	Locals+20
'------------------------------------------------------------------------------
  s := CogStore.Size
'------------------------------------------------------------------------------
0038: 00             FRAME	Call with return value	
0039: 06 04 06       CALLOBJ	4:6
003c: 7d             POP  	Locals+28
'------------------------------------------------------------------------------
  if (s => 0)
'------------------------------------------------------------------------------
003d: 7c             PUSH 	Locals+28
003e: 35             PUSH#0	
003f: fe             GE   	
0040: 0a 07          JPF  	.+7 (dest:$0049)
'------------------------------------------------------------------------------
    ALLOC := ALLOC - s*4
'------------------------------------------------------------------------------
0042: 68             PUSH 	Locals+8
0043: 7c             PUSH 	Locals+28
0044: 37 01          PUSH#kp	4 ($4)
0046: f4             MPY  	
0047: ed             SUB  	
0048: 69             POP  	Locals+8
'------------------------------------------------------------------------------
  CogStore.Setup(ALLOC)
'------------------------------------------------------------------------------
0049: 01             FRAME	Call without return value	
004a: 68             PUSH 	Locals+8
004b: 06 04 07       CALLOBJ	4:7
'------------------------------------------------------------------------------
  CogStore.Stop
'------------------------------------------------------------------------------
004e: 01             FRAME	Call without return value	
004f: 06 04 03       CALLOBJ	4:3
'------------------------------------------------------------------------------
  HMI_DATA := ALLOC - 4 * HMI#DATASIZE
'------------------------------------------------------------------------------
0052: 68             PUSH 	Locals+8
0053: 37 01          PUSH#kp	4 ($4)
0055: 39 01 28       PUSH#k2	296
0058: f4             MPY  	
0059: ed             SUB  	
005a: 6d             POP  	Locals+12
'------------------------------------------------------------------------------
  ALLOC    := HMI_DATA
'------------------------------------------------------------------------------
005b: 6c             PUSH 	Locals+12
005c: 69             POP  	Locals+8
'------------------------------------------------------------------------------
  if ok
'------------------------------------------------------------------------------
005d: 60             PUSH 	Locals+0
005e: 0a 0c          JPF  	.+12 (dest:$006c)
'------------------------------------------------------------------------------
    ok := HMI.Start(Common#REGISTRY, HMI_DATA, START_KBD, START_MOUSE, START_SCREEN)
'------------------------------------------------------------------------------
0060: 00             FRAME	Call with return value	
0061: 39 7e dc       PUSH#k2	32476
0064: 6c             PUSH 	Locals+12
0065: 34             PUSH#-1	
0066: 34             PUSH#-1	
0067: 34             PUSH#-1	
0068: 06 06 02       CALLOBJ	6:2
006b: 61             POP  	Locals+0
'------------------------------------------------------------------------------
  Kernel.Run (Common#REGISTRY, Common#REQUESTS, Catalina.Base, ALLOC)
'------------------------------------------------------------------------------
006c: 01             FRAME	Call without return value	
006d: 39 7e dc       PUSH#k2	32476
0070: 39 7e 9c       PUSH#k2	32412
0073: 00             FRAME	Call with return value	
0074: 06 02 01       CALLOBJ	2:1
0077: 68             PUSH 	Locals+8
0078: 06 05 02       CALLOBJ	5:2
007b: 32             RETURN	

'******************************************************************************
'                                Catalina.spin                                 
'******************************************************************************

'=================================== CONs =====================================
SEGMENT_LAYOUT = 0
'=============================== Object Header ================================
007c: e0 25 02 00 ' 9696 bytes, 2-1 methods, 0 object pointers
0080: d8 25 00 00 ' ptr #1 to $2654: PUB Base (locals size: 0)
'================================ DAT Section =================================
0084(0000):             '         org  0
0084(0000): 00 00 00 00 '         long 0          '$00
0088(0001): 00 00 00 00 '         long 0          '$01
008c(0002): 00 00 3c 5c ' INIT    jmp  0          '$02
0090(0003): 00 00 3c 5c ' LODL    jmp  0          '$03
0094(0004): 00 00 3c 5c ' LODA    jmp  0          '$04
0098(0005): 00 00 3c 5c ' LODF    jmp  0          '$05
009c(0006): 00 00 3c 5c ' PSHL    jmp  0          '$06
00a0(0007): 00 00 3c 5c ' PSHB    jmp  0          '$07
00a4(0008): 00 00 3c 5c ' CPYB    jmp  0          '$08
00a8(0009): 00 00 3c 5c ' NEWF    jmp  0          '$09
00ac(000a): 00 00 3c 5c ' RETF    jmp  0          '$0a
00b0(000b): 00 00 3c 5c ' CALA    jmp  0          '$0b
00b4(000c): 00 00 3c 5c ' RETN    jmp  0          '$0c
00b8(000d): 00 00 3c 5c ' CALI    jmp  0          '$0d
00bc(000e): 00 00 3c 5c ' JMPA    jmp  0          '$0e
00c0(000f): 00 00 3c 5c ' JMPI    jmp  0          '$0f
00c4(0010): 00 00 3c 5c ' DIVS    jmp  0          '$10
00c8(0011): 00 00 3c 5c ' DIVU    jmp  0          '$11
00cc(0012): 00 00 3c 5c ' MULT    jmp  0          '$12
00d0(0013): 00 00 3c 5c ' BR_Z    jmp  0          '$13
00d4(0014): 00 00 3c 5c ' BRNZ    jmp  0          '$14
00d8(0015): 00 00 3c 5c ' BRAE    jmp  0          '$15
00dc(0016): 00 00 3c 5c ' BR_A    jmp  0          '$16
00e0(0017): 00 00 3c 5c ' BRBE    jmp  0          '$17
00e4(0018): 00 00 3c 5c ' BR_B    jmp  0          '$18
00e8(0019): 00 00 3c 5c ' SYSP    jmp  0          '$19
00ec(001a): 00 00 3c 5c ' PSHA    jmp  0          '$1a
00f0(001b): 00 00 3c 5c ' FADD    jmp  0          '$1b
00f4(001c): 00 00 3c 5c ' FSUB    jmp  0          '$1c
00f8(001d): 00 00 3c 5c ' FMUL    jmp  0          '$1d
00fc(001e): 00 00 3c 5c ' FDIV    jmp  0          '$1e
0100(001f): 00 00 3c 5c ' FCMP    jmp  0          '$1f
0104(0020): 00 00 3c 5c ' FLIN    jmp  0          '$20
0108(0021): 00 00 3c 5c ' INFL    jmp  0          '$21
010c(0022): 00 00 3c 5c ' PSHM    jmp  0          '$22
0110(0023): 00 00 3c 5c ' POPM    jmp  0          '$23
0114(0024): 00 00 3c 5c ' PSHF    jmp  0          '$24
0118(0025): 00 00 3c 5c ' RLNG    jmp  0          '$25
011c(0026): 00 00 3c 5c ' RWRD    jmp  0          '$26
0120(0027): 00 00 3c 5c ' RBYT    jmp  0          '$27
0124(0028): 00 00 3c 5c ' WLNG    jmp  0          '$28
0128(0029): 00 00 3c 5c ' WWRD    jmp  0          '$29
012c(002a): 00 00 3c 5c ' WBYT    jmp  0          '$2a
0130(002b): 00 00 00 00 ' PC      long 0          '$2b
0134(002c): 00 00 00 00 ' SP      long 0          '$2c
0138(002d): 00 00 00 00 ' FP      long 0          '$2d
013c(002e): 00 00 00 00 ' RI      long 0          '$2e
0140(002f): 00 00 00 00 ' BC      long 0          '$2f
0144(0030): 00 00 00 00 ' BA      long 0          '$30
0148(0031): 00 00 00 00 ' BZ      long 0          '$31
014c(0032): 00 00 00 00 ' CS      long 0          '$32
0150(0033): 00 00 00 00 ' r0      long 0          '$33
0154(0034): 00 00 00 00 ' r1      long 0          '$34
0158(0035): 00 00 00 00 ' r2      long 0          '$35
015c(0036): 00 00 00 00 ' r3      long 0          '$36
0160(0037): 00 00 00 00 ' r4      long 0          '$37
0164(0038): 00 00 00 00 ' r5      long 0          '$38
0168(0039): 00 00 00 00 ' r6      long 0          '$39
016c(003a): 00 00 00 00 ' r7      long 0          '$3a
0170(003b): 00 00 00 00 ' r8      long 0          '$3b
0174(003c): 00 00 00 00 ' r9      long 0          '$3c
0178(003d): 00 00 00 00 ' r10     long 0          '$3d
017c(003e): 00 00 00 00 ' r11     long 0          '$3e
0180(003f): 00 00 00 00 ' r12     long 0          '$3f
0184(0040): 00 00 00 00 ' r13     long 0          '$40
0188(0041): 00 00 00 00 ' r14     long 0          '$41
018c(0042): 00 00 00 00 ' r15     long 0          '$42
0190(0043): 00 00 00 00 ' r16     long 0          '$43
0194(0044): 00 00 00 00 ' r17     long 0          '$44
0198(0045): 00 00 00 00 ' r18     long 0          '$45
019c(0046): 00 00 00 00 ' r19     long 0          '$46
01a0(0047): 00 00 00 00 ' r20     long 0          '$47
01a4(0048): 00 00 00 00 ' r21     long 0          '$48
01a8(0049): 00 00 00 00 ' r22     long 0          '$49
01ac(004a): 00 00 00 00 ' r23     long 0          '$4a
01b0(004b): 00 00 00 80 ' Bit31   long  $80000000 '$4b
01b4(004c): ff ff ff ff ' all_1s  long  $ffffffff '$4c
01b8(004d): ff 00 00 00 ' cviu_m1 long  $000000ff '$4d
01bc(004e): ff ff 00 00 ' cviu_m2 long  $0000ffff '$4e
01c0(004f): 00 00 00 ff ' top8    long  $ff000000 '$4f   ' top 8 bits bitmask
01c4(0050): ff ff ff 00 ' low24   long  $00ffffff '$50   ' low 24 bits bitmask
01c8(0051): d4 25 00 00 ' init_BZ long  @sbrkinit '$51   ' end of code / start of heap
01cc(0052): f8 01 00 00 ' init_PC long  @C_main   '$52   ' the initial PC
01d0(0053):             ' seglayout
01d0(0053): 00 00 00 00 '         long  SEGMENT_LAYOUT
01d4(0054):             ' segtable
01d4(0054): 6c 01 00 00 '         long  @Catalina_Code
01d8(0055): 88 24 00 00 '         long  @Catalina_Cnst
01dc(0056): 30 25 00 00 '         long  @Catalina_Init
01e0(0057): d0 25 00 00 '         long  @Catalina_Data
01e4(0058): d8 25 00 00 '         long  @Catalina_Ends
01e8(0059):             '  long ' align long
01e8(0059):             ' Catalina_Code
01e8(0059):             '  long ' align long
01e8(0059):             '  long ' align long
01e8(0059):             ' C__exit
01e8(0059): 80 66 fc a0 '  mov r0,#$80
01ec(005a): 00 66 7c 0c '  clkset r0
01f0(005b):             ' C__sys_plugin
01f0(005b): 19 00 7c 5c '  jmp #SYSP
01f4(005c): 0c 00 7c 5c '  jmp #RETN
01f8(005d):             ' C_arg_setup
01f8(005d): 04 00 7c 5c '  jmp #LODA                 ' point to argv address
01fc(005e): 98 01 00 00 '  long @C_argv_locn
0200(005f): 2e 5e bc 08 '  rdlong BC,RI
0204(0060): 2f 6c bc 04 '  rdword r3,BC              ' load argc
0208(0061): 02 5e fc 80 '  add BC,#2
020c(0062): 2f 6a bc 04 '  rdword r2,BC              ' load argv
0210(0063): 0c 00 7c 5c '  jmp #RETN                 ' done
0214(0064):             ' C_argv_locn
0214(0064): 30 7f 00 00 '  long $7F30                ' must match value in Catalina_Common_Input.spin
0218(0065):             ' C_debug_init
0218(0065): 0c 00 7c 5c '  jmp #RETN                 ' done
021c(0066):             '  long ' align long
021c(0066):             ' C_bbos_time_init ' <symbol:bbos_time_init>
021c(0066): 22 00 7c 5c '  jmp #PSHM
0220(0067): 00 0c 00 00 '  long $c00 ' save registers
0224(0068): 00 5e fc a0 '  mov BC, #0 ' arg size
0228(0069): 0b 00 7c 5c '  jmp #CALA
022c(006a): ec 0b 00 00 '  long @C__clockfreq ' CALL addrg
0230(006b): 04 00 7c 5c '  jmp #LODA
0234(006c): a4 24 00 00 '  long @C_bbos_time_init_L000002
0238(006d): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
023c(006e): 33 7c bc a0 '  mov r11, r0 ' ADDI/P
0240(006f): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (3)
0244(0070): 04 00 7c 5c '  jmp #LODA
0248(0071): a0 24 00 00 '  long @C_bbos_time_init_L000005
024c(0072): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
0250(0073): 3e 66 bc a0 '  mov r0, r11 ' setup r0/r1 (2)
0254(0074): 3d 68 bc a0 '  mov r1, r10 ' setup r0/r1 (2)
0258(0075): 10 00 7c 5c '  jmp #DIVS ' DIVI
025c(0076): 04 00 7c 5c '  jmp #LODA
0260(0077): d0 25 00 00 '  long @C_usec_delay
0264(0078): 2e 66 3c 08 '  wrlong r0, RI ' ASGNI4 addrg
0268(0079): 23 00 7c 5c '  jmp #POPM
026c(007a): 00 0c 00 00 '  long $c00 ' restore registers
0270(007b): 0c 00 7c 5c '  jmp #RETN
0274(007c):             '  long ' align long
0274(007c):             ' C_main ' <symbol:main>
0274(007c): 0b 00 7c 5c '  jmp #CALA
0278(007d): 7c 01 00 00 '  long @C_arg_setup
027c(007e): 04 00 7c 5c '  jmp #LODA
0280(007f): ec 0b 00 00 '  long @C__clockfreq
0284(0080): 2e 6a bc a0 '  mov r2, RI ' reg ARG ADDRG
0288(0081): 04 00 7c 5c '  jmp #LODA
028c(0082): 88 24 00 00 '  long @C_main_10_L000011
0290(0083): 2e 6c bc a0 '  mov r3, RI ' reg ARG ADDRG
0294(0084): 08 5e fc a0 '  mov BC, #8 ' arg size
0298(0085): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
029c(0086): 0b 00 7c 5c '  jmp #CALA
02a0(0087): 44 23 00 00 '  long @C_printf
02a4(0088): 08 58 fc 80 '  add SP, #8 ' CALL addrg
02a8(0089): 00 5e fc a0 '  mov BC, #0 ' arg size
02ac(008a): 0b 00 7c 5c '  jmp #CALA
02b0(008b): a0 01 00 00 '  long @C_bbos_time_init ' CALL addrg
02b4(008c): 0e 00 7c 5c '  jmp #JMPA
02b8(008d): a8 02 00 00 '  long @C_main_13 ' JUMPV addrg
02bc(008e):             ' C_main_12
02bc(008e): 00 5e fc a0 '  mov BC, #0 ' arg size
02c0(008f): 0b 00 7c 5c '  jmp #CALA
02c4(0090): a0 05 00 00 '  long @C_ds18b20_request_data ' CALL addrg
02c8(0091): 00 5e fc a0 '  mov BC, #0 ' arg size
02cc(0092): 0b 00 7c 5c '  jmp #CALA
02d0(0093): d8 04 00 00 '  long @C_ds18b20_read_data ' CALL addrg
02d4(0094): 00 5e fc a0 '  mov BC, #0 ' arg size
02d8(0095): 0b 00 7c 5c '  jmp #CALA
02dc(0096): f4 0b 00 00 '  long @C__cnt ' CALL addrg
02e0(0097): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
02e4(0098): 00 5e fc a0 '  mov BC, #0 ' arg size
02e8(0099): 0b 00 7c 5c '  jmp #CALA
02ec(009a): ec 0b 00 00 '  long @C__clockfreq ' CALL addrg
02f0(009b): 33 7a bc a0 '  mov r10, r0 ' CVI, CVU or LOAD
02f4(009c): 03 78 fc a0 '  mov r9, #3 ' reg <- coni
02f8(009d): 3d 66 bc a0 '  mov r0, r10 ' setup r0/r1 (2)
02fc(009e): 3c 68 bc a0 '  mov r1, r9 ' setup r0/r1 (2)
0300(009f): 11 00 7c 5c '  jmp #DIVU ' DIVU
0304(00a0): 33 7a bc a0 '  mov r10, r0 ' CVI, CVU or LOAD
0308(00a1): 3e 6a bc a0 '  mov r2, r11 ' ADDU
030c(00a2): 3d 6a bc 80 '  add r2, r10 ' ADDU (3)
0310(00a3): 04 5e fc a0 '  mov BC, #4 ' arg size
0314(00a4): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
0318(00a5): 0b 00 7c 5c '  jmp #CALA
031c(00a6): 80 24 00 00 '  long @C__waitcnt
0320(00a7): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0324(00a8):             ' C_main_13
0324(00a8): 0e 00 7c 5c '  jmp #JMPA
0328(00a9): 40 02 00 00 '  long @C_main_12 ' JUMPV addrg
032c(00aa): 0e 00 7c 5c '  jmp #JMPA
0330(00ab): 6c 01 00 00 '  long @C__exit
0334(00ac):             '  long ' align long
0334(00ac):             ' C_ds18b20_meas_to_cel ' <symbol:ds18b20_meas_to_cel>
0334(00ac): 22 00 7c 5c '  jmp #PSHM
0338(00ad): 00 ec 03 00 '  long $3ec00 ' save registers
033c(00ae): 35 88 bc a0 '  mov r17, r2 ' reg var <- reg arg
0340(00af): 44 7c bc 00 '  rdbyte r11, r17 ' reg <- INDIRU1 reg
0344(00b0): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
0348(00b1): 3e 80 bc a0 '  mov r13, r11 ' CVI, CVU or LOAD
034c(00b2): 44 7c bc a0 '  mov r11, r17
0350(00b3): 01 7c fc d0 '  adds r11, #1 ' ADDP4 coni
0354(00b4): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
0358(00b5): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
035c(00b6): 08 7c fc 2c '  shl r11, #8 ' LSHU4 coni
0360(00b7): 3e 80 bc 68 '  or r13, r11 ' BORI/U (1)
0364(00b8): 40 7c bc a0 '  mov r11, r13
0368(00b9): 04 7c fc 28 '  shr r11, #4 ' RSHU4 coni
036c(00ba): 3e 82 bc a0 '  mov r14, r11 ' CVI, CVU or LOAD
0370(00bb): 41 6a bc a0 '  mov r2, r14 ' CVUI
0374(00bc): 4d 6a bc 60 '  and r2, cviu_m1 ' zero extend
0378(00bd): 04 00 7c 5c '  jmp #LODA
037c(00be): a8 24 00 00 '  long @C_ds18b20_meas_to_cel_3_L000004
0380(00bf): 2e 6c bc a0 '  mov r3, RI ' reg ARG ADDRG
0384(00c0): 08 5e fc a0 '  mov BC, #8 ' arg size
0388(00c1): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
038c(00c2): 0b 00 7c 5c '  jmp #CALA
0390(00c3): 44 23 00 00 '  long @C_printf
0394(00c4): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0398(00c5): 41 7c bc a0 '  mov r11, r14 ' CVUI
039c(00c6): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
03a0(00c7): 1b 7c fc d4 '  subs r11, #27 ' SUBI4 coni
03a4(00c8): 3e 84 bc a0 '  mov r15, r11 ' CVI, CVU or LOAD
03a8(00c9): 00 86 fc a0 '  mov r16, #0 ' reg <- coni
03ac(00ca): 0e 00 7c 5c '  jmp #JMPA
03b0(00cb): 24 04 00 00 '  long @C_ds18b20_meas_to_cel_8 ' JUMPV addrg
03b4(00cc):             ' C_ds18b20_meas_to_cel_5
03b4(00cc): 43 7c bc a0 '  mov r11, r16 ' CVUI
03b8(00cd): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
03bc(00ce): 42 7c 3c 87 '  cmp r11, r15 wz,wc 
03c0(00cf): 16 00 7c 5c '  jmp #BR_A
03c4(00d0): b4 03 00 00 '  long @C_ds18b20_meas_to_cel_9 ' GTU4
03c8(00d1): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
03cc(00d2): 43 7a bc a0 '  mov r10, r16 ' CVUI
03d0(00d3): 4d 7a bc 60 '  and r10, cviu_m1 ' zero extend
03d4(00d4): 10 7a fc d0 '  adds r10, #16 ' ADDI4 coni
03d8(00d5): 3d 7c bc 2c '  shl r11, r10 ' LSHI/U (1)
03dc(00d6): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
03e0(00d7): 3e 6c bc a0 '  mov r3, r11 ' CVI, CVU or LOAD
03e4(00d8): 08 5e fc a0 '  mov BC, #8 ' arg size
03e8(00d9): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
03ec(00da): 0b 00 7c 5c '  jmp #CALA
03f0(00db): 34 23 00 00 '  long @C__outa
03f4(00dc): 08 58 fc 80 '  add SP, #8 ' CALL addrg
03f8(00dd): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
03fc(00de): 43 7a bc a0 '  mov r10, r16 ' CVUI
0400(00df): 4d 7a bc 60 '  and r10, cviu_m1 ' zero extend
0404(00e0): 10 7a fc d0 '  adds r10, #16 ' ADDI4 coni
0408(00e1): 3d 7c bc 2c '  shl r11, r10 ' LSHI/U (1)
040c(00e2): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
0410(00e3): 3e 6c bc a0 '  mov r3, r11 ' CVI, CVU or LOAD
0414(00e4): 08 5e fc a0 '  mov BC, #8 ' arg size
0418(00e5): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
041c(00e6): 0b 00 7c 5c '  jmp #CALA
0420(00e7): fc 0b 00 00 '  long @C__dira
0424(00e8): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0428(00e9): 0e 00 7c 5c '  jmp #JMPA
042c(00ea): 14 04 00 00 '  long @C_ds18b20_meas_to_cel_10 ' JUMPV addrg
0430(00eb):             ' C_ds18b20_meas_to_cel_9
0430(00eb): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
0434(00ec): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
0438(00ed): 43 7a bc a0 '  mov r10, r16 ' CVUI
043c(00ee): 4d 7a bc 60 '  and r10, cviu_m1 ' zero extend
0440(00ef): 10 7a fc d0 '  adds r10, #16 ' ADDI4 coni
0444(00f0): 3e 6c bc a0 '  mov r3, r11 ' LSHI/U
0448(00f1): 3d 6c bc 2c '  shl r3, r10 ' LSHI/U (3)
044c(00f2): 08 5e fc a0 '  mov BC, #8 ' arg size
0450(00f3): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0454(00f4): 0b 00 7c 5c '  jmp #CALA
0458(00f5): 34 23 00 00 '  long @C__outa
045c(00f6): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0460(00f7): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
0464(00f8): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
0468(00f9): 43 7a bc a0 '  mov r10, r16 ' CVUI
046c(00fa): 4d 7a bc 60 '  and r10, cviu_m1 ' zero extend
0470(00fb): 10 7a fc d0 '  adds r10, #16 ' ADDI4 coni
0474(00fc): 3e 6c bc a0 '  mov r3, r11 ' LSHI/U
0478(00fd): 3d 6c bc 2c '  shl r3, r10 ' LSHI/U (3)
047c(00fe): 08 5e fc a0 '  mov BC, #8 ' arg size
0480(00ff): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0484(0100): 0b 00 7c 5c '  jmp #CALA
0488(0101): fc 0b 00 00 '  long @C__dira
048c(0102): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0490(0103):             ' C_ds18b20_meas_to_cel_10
0490(0103): 43 7c bc a0 '  mov r11, r16 ' CVUI
0494(0104): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
0498(0105): 01 7c fc d0 '  adds r11, #1 ' ADDI4 coni
049c(0106): 3e 86 bc a0 '  mov r16, r11 ' CVI, CVU or LOAD
04a0(0107):             ' C_ds18b20_meas_to_cel_8
04a0(0107): 43 7c bc a0 '  mov r11, r16 ' CVUI
04a4(0108): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
04a8(0109): 08 7c 7c c3 '  cmps r11,  #8 wz,wc
04ac(010a): 18 00 7c 5c '  jmp #BR_B
04b0(010b): 38 03 00 00 '  long @C_ds18b20_meas_to_cel_5 ' LTI4
04b4(010c): 41 7c bc a0 '  mov r11, r14 ' CVUI
04b8(010d): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
04bc(010e): 1e 7c 7c c2 '  cmps r11,  #30 wz
04c0(010f): 14 00 7c 5c '  jmp #BRNZ
04c4(0110): 94 04 00 00 '  long @C_ds18b20_meas_to_cel_11 ' NEI4
04c8(0111): 80 7c fc a0 '  mov r11, #128 ' reg <- coni
04cc(0112): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
04d0(0113): 3e 6c bc a0 '  mov r3, r11 ' CVI, CVU or LOAD
04d4(0114): 08 5e fc a0 '  mov BC, #8 ' arg size
04d8(0115): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
04dc(0116): 0b 00 7c 5c '  jmp #CALA
04e0(0117): 34 23 00 00 '  long @C__outa
04e4(0118): 08 58 fc 80 '  add SP, #8 ' CALL addrg
04e8(0119): 80 7c fc a0 '  mov r11, #128 ' reg <- coni
04ec(011a): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
04f0(011b): 3e 6c bc a0 '  mov r3, r11 ' CVI, CVU or LOAD
04f4(011c): 08 5e fc a0 '  mov BC, #8 ' arg size
04f8(011d): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
04fc(011e): 0b 00 7c 5c '  jmp #CALA
0500(011f): fc 0b 00 00 '  long @C__dira
0504(0120): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0508(0121): 0e 00 7c 5c '  jmp #JMPA
050c(0122): cc 04 00 00 '  long @C_ds18b20_meas_to_cel_12 ' JUMPV addrg
0510(0123):             ' C_ds18b20_meas_to_cel_11
0510(0123): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
0514(0124): 80 6c fc a0 '  mov r3, #128 ' reg ARG coni
0518(0125): 08 5e fc a0 '  mov BC, #8 ' arg size
051c(0126): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0520(0127): 0b 00 7c 5c '  jmp #CALA
0524(0128): 34 23 00 00 '  long @C__outa
0528(0129): 08 58 fc 80 '  add SP, #8 ' CALL addrg
052c(012a): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
0530(012b): 80 6c fc a0 '  mov r3, #128 ' reg ARG coni
0534(012c): 08 5e fc a0 '  mov BC, #8 ' arg size
0538(012d): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
053c(012e): 0b 00 7c 5c '  jmp #CALA
0540(012f): fc 0b 00 00 '  long @C__dira
0544(0130): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0548(0131):             ' C_ds18b20_meas_to_cel_12
0548(0131): 23 00 7c 5c '  jmp #POPM
054c(0132): 00 ec 03 00 '  long $3ec00 ' restore registers
0550(0133): 0c 00 7c 5c '  jmp #RETN
0554(0134):             '  long ' align long
0554(0134):             ' C_ds18b20_read_data ' <symbol:ds18b20_read_data>
0554(0134): 09 00 7c 5c '  jmp #NEWF
0558(0135): 0c 58 fc 84 '  sub SP, #12
055c(0136): 22 00 7c 5c '  jmp #PSHM
0560(0137): 00 0e 02 00 '  long $20e00 ' save registers
0564(0138): 00 5e fc a0 '  mov BC, #0 ' arg size
0568(0139): 0b 00 7c 5c '  jmp #CALA
056c(013a): 3c 06 00 00 '  long @C_ow_reset ' CALL addrg
0570(013b): be 6a fc a0 '  mov r2, #190 ' reg ARG coni
0574(013c): 04 5e fc a0 '  mov BC, #4 ' arg size
0578(013d): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
057c(013e): 0b 00 7c 5c '  jmp #CALA
0580(013f): 3c 09 00 00 '  long @C_ow_command
0584(0140): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0588(0141): 00 88 fc a0 '  mov r17, #0 ' reg <- coni
058c(0142): 0e 00 7c 5c '  jmp #JMPA
0590(0143): 5c 05 00 00 '  long @C_ds18b20_read_data_17 ' JUMPV addrg
0594(0144):             ' C_ds18b20_read_data_14
0594(0144): ff 6a fc a0 '  mov r2, #255 ' reg ARG coni
0598(0145): 04 5e fc a0 '  mov BC, #4 ' arg size
059c(0146): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
05a0(0147): 0b 00 7c 5c '  jmp #CALA
05a4(0148): 94 08 00 00 '  long @C_ow_io_byte
05a8(0149): 04 58 fc 80 '  add SP, #4 ' CALL addrg
05ac(014a): 44 7a bc a0 '  mov r10, r17 ' CVUI
05b0(014b): 4d 7a bc 60 '  and r10, cviu_m1 ' zero extend
05b4(014c): 2d 78 bc a0 '  mov r9, FP
05b8(014d): 0c 78 fc 84 '  sub r9, #-(-12) ' reg <- addrli
05bc(014e): 3c 7a bc d0 '  adds r10, r9 ' ADDI/P (1)
05c0(014f): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
05c4(0150): 3d 7c 3c 00 '  wrbyte r11, r10 ' ASGNU1 reg
05c8(0151): 44 7c bc a0 '  mov r11, r17 ' CVUI
05cc(0152): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
05d0(0153): 01 7c fc d0 '  adds r11, #1 ' ADDI4 coni
05d4(0154): 3e 88 bc a0 '  mov r17, r11 ' CVI, CVU or LOAD
05d8(0155):             ' C_ds18b20_read_data_17
05d8(0155): 44 7c bc a0 '  mov r11, r17 ' CVUI
05dc(0156): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
05e0(0157): 09 7c 7c c3 '  cmps r11,  #9 wz,wc
05e4(0158): 18 00 7c 5c '  jmp #BR_B
05e8(0159): 18 05 00 00 '  long @C_ds18b20_read_data_14 ' LTI4
05ec(015a): 2d 6a bc a0 '  mov r2, FP
05f0(015b): 0c 6a fc 84 '  sub r2, #-(-12) ' reg ARG ADDRLi
05f4(015c): 04 5e fc a0 '  mov BC, #4 ' arg size
05f8(015d): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
05fc(015e): 0b 00 7c 5c '  jmp #CALA
0600(015f): b8 02 00 00 '  long @C_ds18b20_meas_to_cel
0604(0160): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0608(0161): 00 66 fc a0 '  mov r0, #0 ' RET coni
060c(0162): 23 00 7c 5c '  jmp #POPM
0610(0163): 00 0e 02 00 '  long $20e00 ' restore registers
0614(0164): 0c 58 fc 80 '  add SP, #12 ' framesize
0618(0165): 0a 00 7c 5c '  jmp #RETF
061c(0166):             '  long ' align long
061c(0166):             ' C_ds18b20_request_data ' <symbol:ds18b20_request_data>
061c(0166): 22 00 7c 5c '  jmp #PSHM
0620(0167): 00 08 00 00 '  long $800 ' save registers
0624(0168): 00 5e fc a0 '  mov BC, #0 ' arg size
0628(0169): 0b 00 7c 5c '  jmp #CALA
062c(016a): 3c 06 00 00 '  long @C_ow_reset ' CALL addrg
0630(016b): 00 5e fc a0 '  mov BC, #0 ' arg size
0634(016c): 0b 00 7c 5c '  jmp #CALA
0638(016d): 00 06 00 00 '  long @C_ow_input_pin_state ' CALL addrg
063c(016e): 00 66 7c c2 '  cmps r0,  #0 wz
0640(016f): 13 00 7c 5c '  jmp #BR_Z
0644(0170): f0 05 00 00 '  long @C_ds18b20_request_data_19 ' EQI4
0648(0171): 44 6a fc a0 '  mov r2, #68 ' reg ARG coni
064c(0172): 04 5e fc a0 '  mov BC, #4 ' arg size
0650(0173): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
0654(0174): 0b 00 7c 5c '  jmp #CALA
0658(0175): 3c 09 00 00 '  long @C_ow_command
065c(0176): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0660(0177): 00 66 fc a0 '  mov r0, #0 ' RET coni
0664(0178): 0e 00 7c 5c '  jmp #JMPA
0668(0179): f4 05 00 00 '  long @C_ds18b20_request_data_18 ' JUMPV addrg
066c(017a):             ' C_ds18b20_request_data_19
066c(017a): ff 66 fc a0 '  mov r0, #255 ' RET coni
0670(017b):             ' C_ds18b20_request_data_18
0670(017b): 23 00 7c 5c '  jmp #POPM
0674(017c): 00 08 00 00 '  long $800 ' restore registers
0678(017d): 0c 00 7c 5c '  jmp #RETN
067c(017e):             '  long ' align long
067c(017e):             ' C_ow_input_pin_state ' <symbol:ow_input_pin_state>
067c(017e): 22 00 7c 5c '  jmp #PSHM
0680(017f): 00 0c 00 00 '  long $c00 ' save registers
0684(0180): 00 5e fc a0 '  mov BC, #0 ' arg size
0688(0181): 0b 00 7c 5c '  jmp #CALA
068c(0182): 2c 23 00 00 '  long @C__ina ' CALL addrg
0690(0183): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
0694(0184): 04 00 7c 5c '  jmp #LODA
0698(0185): 34 25 00 00 '  long @C_tmpfilenc16i7_4d1284f5_ow_dpin_L000002
069c(0186): 2e 7a bc 08 '  rdlong r10, RI ' reg <- INDIRU4 addrg
06a0(0187): 3d 7c bc 60 '  and r11, r10 ' BANDI/U (1)
06a4(0188): 3e 66 bc a0 '  mov r0, r11 ' CVUI
06a8(0189): 4d 66 bc 60 '  and r0, cviu_m1 ' zero extend
06ac(018a): 23 00 7c 5c '  jmp #POPM
06b0(018b): 00 0c 00 00 '  long $c00 ' restore registers
06b4(018c): 0c 00 7c 5c '  jmp #RETN
06b8(018d):             '  long ' align long
06b8(018d):             ' C_ow_reset ' <symbol:ow_reset>
06b8(018d): 09 00 7c 5c '  jmp #NEWF
06bc(018e): 04 58 fc 84 '  sub SP, #4
06c0(018f): 22 00 7c 5c '  jmp #PSHM
06c4(0190): 00 0c 00 00 '  long $c00 ' save registers
06c8(0191): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
06cc(0192): 04 00 7c 5c '  jmp #LODA
06d0(0193): 34 25 00 00 '  long @C_tmpfilenc16i7_4d1284f5_ow_dpin_L000002
06d4(0194): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRG
06d8(0195): 08 5e fc a0 '  mov BC, #8 ' arg size
06dc(0196): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
06e0(0197): 0b 00 7c 5c '  jmp #CALA
06e4(0198): 34 23 00 00 '  long @C__outa
06e8(0199): 08 58 fc 80 '  add SP, #8 ' CALL addrg
06ec(019a): 04 00 7c 5c '  jmp #LODA
06f0(019b): 34 25 00 00 '  long @C_tmpfilenc16i7_4d1284f5_ow_dpin_L000002
06f4(019c): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRU4 addrg
06f8(019d): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
06fc(019e): 3e 6c bc a0 '  mov r3, r11 ' CVI, CVU or LOAD
0700(019f): 08 5e fc a0 '  mov BC, #8 ' arg size
0704(01a0): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0708(01a1): 0b 00 7c 5c '  jmp #CALA
070c(01a2): fc 0b 00 00 '  long @C__dira
0710(01a3): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0714(01a4): e0 6b fc a0 '  mov r2, #480 ' reg ARG coni
0718(01a5): 04 5e fc a0 '  mov BC, #4 ' arg size
071c(01a6): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
0720(01a7): 0b 00 7c 5c '  jmp #CALA
0724(01a8): 94 09 00 00 '  long @C_ow_delay_usec
0728(01a9): 04 58 fc 80 '  add SP, #4 ' CALL addrg
072c(01aa): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
0730(01ab): 04 00 7c 5c '  jmp #LODA
0734(01ac): 34 25 00 00 '  long @C_tmpfilenc16i7_4d1284f5_ow_dpin_L000002
0738(01ad): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRG
073c(01ae): 08 5e fc a0 '  mov BC, #8 ' arg size
0740(01af): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0744(01b0): 0b 00 7c 5c '  jmp #CALA
0748(01b1): fc 0b 00 00 '  long @C__dira
074c(01b2): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0750(01b3): 48 6a fc a0 '  mov r2, #72 ' reg ARG coni
0754(01b4): 04 5e fc a0 '  mov BC, #4 ' arg size
0758(01b5): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
075c(01b6): 0b 00 7c 5c '  jmp #CALA
0760(01b7): 94 09 00 00 '  long @C_ow_delay_usec
0764(01b8): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0768(01b9): 00 5e fc a0 '  mov BC, #0 ' arg size
076c(01ba): 0b 00 7c 5c '  jmp #CALA
0770(01bb): 2c 23 00 00 '  long @C__ina ' CALL addrg
0774(01bc): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
0778(01bd): 04 00 7c 5c '  jmp #LODA
077c(01be): 34 25 00 00 '  long @C_tmpfilenc16i7_4d1284f5_ow_dpin_L000002
0780(01bf): 2e 7a bc 08 '  rdlong r10, RI ' reg <- INDIRU4 addrg
0784(01c0): 3d 7c bc 60 '  and r11, r10 ' BANDI/U (1)
0788(01c1): 05 00 7c 5c '  jmp #LODF
078c(01c2): fc ff ff ff '  long -4
0790(01c3): 2e 7c 3c 00 '  wrbyte r11, RI ' ASGNU1 addrl
0794(01c4): ac 6b fc a0 '  mov r2, #428 ' reg ARG coni
0798(01c5): 04 5e fc a0 '  mov BC, #4 ' arg size
079c(01c6): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
07a0(01c7): 0b 00 7c 5c '  jmp #CALA
07a4(01c8): 94 09 00 00 '  long @C_ow_delay_usec
07a8(01c9): 04 58 fc 80 '  add SP, #4 ' CALL addrg
07ac(01ca): 00 5e fc a0 '  mov BC, #0 ' arg size
07b0(01cb): 0b 00 7c 5c '  jmp #CALA
07b4(01cc): 2c 23 00 00 '  long @C__ina ' CALL addrg
07b8(01cd): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
07bc(01ce): 04 00 7c 5c '  jmp #LODA
07c0(01cf): 34 25 00 00 '  long @C_tmpfilenc16i7_4d1284f5_ow_dpin_L000002
07c4(01d0): 2e 7a bc 08 '  rdlong r10, RI ' reg <- INDIRU4 addrg
07c8(01d1): 3d 7c bc 60 '  and r11, r10 ' BANDI/U (1)
07cc(01d2): 00 7c 7c 86 '  cmp r11,  #0 wz
07d0(01d3): 14 00 7c 5c '  jmp #BRNZ
07d4(01d4): 6c 07 00 00 '  long @C_ow_reset_5 ' NEU4
07d8(01d5): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
07dc(01d6): 05 00 7c 5c '  jmp #LODF
07e0(01d7): fc ff ff ff '  long -4
07e4(01d8): 2e 7c 3c 00 '  wrbyte r11, RI ' ASGNU1 addrl
07e8(01d9):             ' C_ow_reset_5
07e8(01d9): 2d 7c bc a0 '  mov r11, FP
07ec(01da): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
07f0(01db): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
07f4(01dc): 3e 66 bc a0 '  mov r0, r11 ' CVUI
07f8(01dd): 4d 66 bc 60 '  and r0, cviu_m1 ' zero extend
07fc(01de): 23 00 7c 5c '  jmp #POPM
0800(01df): 00 0c 00 00 '  long $c00 ' restore registers
0804(01e0): 04 58 fc 80 '  add SP, #4 ' framesize
0808(01e1): 0a 00 7c 5c '  jmp #RETF
080c(01e2):             '  long ' align long
080c(01e2):             ' C_ow_io_bit ' <symbol:ow_io_bit>
080c(01e2): 22 00 7c 5c '  jmp #PSHM
0810(01e3): 00 0c 02 00 '  long $20c00 ' save registers
0814(01e4): 35 88 bc a0 '  mov r17, r2 ' reg var <- reg arg
0818(01e5): 04 00 7c 5c '  jmp #LODA
081c(01e6): 34 25 00 00 '  long @C_tmpfilenc16i7_4d1284f5_ow_dpin_L000002
0820(01e7): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRU4 addrg
0824(01e8): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
0828(01e9): 3e 6c bc a0 '  mov r3, r11 ' CVI, CVU or LOAD
082c(01ea): 08 5e fc a0 '  mov BC, #8 ' arg size
0830(01eb): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0834(01ec): 0b 00 7c 5c '  jmp #CALA
0838(01ed): fc 0b 00 00 '  long @C__dira
083c(01ee): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0840(01ef): 02 6a fc a0 '  mov r2, #2 ' reg ARG coni
0844(01f0): 04 5e fc a0 '  mov BC, #4 ' arg size
0848(01f1): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
084c(01f2): 0b 00 7c 5c '  jmp #CALA
0850(01f3): 94 09 00 00 '  long @C_ow_delay_usec
0854(01f4): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0858(01f5): 44 7c bc a0 '  mov r11, r17 ' CVUI
085c(01f6): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
0860(01f7): 00 7c 7c c2 '  cmps r11,  #0 wz
0864(01f8): 13 00 7c 5c '  jmp #BR_Z
0868(01f9): 14 08 00 00 '  long @C_ow_io_bit_8 ' EQI4
086c(01fa): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
0870(01fb): 04 00 7c 5c '  jmp #LODA
0874(01fc): 34 25 00 00 '  long @C_tmpfilenc16i7_4d1284f5_ow_dpin_L000002
0878(01fd): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRG
087c(01fe): 08 5e fc a0 '  mov BC, #8 ' arg size
0880(01ff): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0884(0200): 0b 00 7c 5c '  jmp #CALA
0888(0201): fc 0b 00 00 '  long @C__dira
088c(0202): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0890(0203):             ' C_ow_io_bit_8
0890(0203): 00 5e fc a0 '  mov BC, #0 ' arg size
0894(0204): 0b 00 7c 5c '  jmp #CALA
0898(0205): 2c 23 00 00 '  long @C__ina ' CALL addrg
089c(0206): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
08a0(0207): 04 00 7c 5c '  jmp #LODA
08a4(0208): 34 25 00 00 '  long @C_tmpfilenc16i7_4d1284f5_ow_dpin_L000002
08a8(0209): 2e 7a bc 08 '  rdlong r10, RI ' reg <- INDIRU4 addrg
08ac(020a): 3d 7c bc 60 '  and r11, r10 ' BANDI/U (1)
08b0(020b): 00 7c 7c 86 '  cmp r11,  #0 wz
08b4(020c): 14 00 7c 5c '  jmp #BRNZ
08b8(020d): 44 08 00 00 '  long @C_ow_io_bit_10 ' NEU4
08bc(020e): 00 88 fc a0 '  mov r17, #0 ' reg <- coni
08c0(020f):             ' C_ow_io_bit_10
08c0(020f): 2d 6a fc a0 '  mov r2, #45 ' reg ARG coni
08c4(0210): 04 5e fc a0 '  mov BC, #4 ' arg size
08c8(0211): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
08cc(0212): 0b 00 7c 5c '  jmp #CALA
08d0(0213): 94 09 00 00 '  long @C_ow_delay_usec
08d4(0214): 04 58 fc 80 '  add SP, #4 ' CALL addrg
08d8(0215): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
08dc(0216): 04 00 7c 5c '  jmp #LODA
08e0(0217): 34 25 00 00 '  long @C_tmpfilenc16i7_4d1284f5_ow_dpin_L000002
08e4(0218): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRG
08e8(0219): 08 5e fc a0 '  mov BC, #8 ' arg size
08ec(021a): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
08f0(021b): 0b 00 7c 5c '  jmp #CALA
08f4(021c): fc 0b 00 00 '  long @C__dira
08f8(021d): 08 58 fc 80 '  add SP, #8 ' CALL addrg
08fc(021e): 44 66 bc a0 '  mov r0, r17 ' CVUI
0900(021f): 4d 66 bc 60 '  and r0, cviu_m1 ' zero extend
0904(0220): 23 00 7c 5c '  jmp #POPM
0908(0221): 00 0c 02 00 '  long $20c00 ' restore registers
090c(0222): 0c 00 7c 5c '  jmp #RETN
0910(0223):             '  long ' align long
0910(0223):             ' C_ow_io_byte ' <symbol:ow_io_byte>
0910(0223): 22 00 7c 5c '  jmp #PSHM
0914(0224): 00 88 03 00 '  long $38800 ' save registers
0918(0225): 35 88 bc a0 '  mov r17, r2 ' reg var <- reg arg
091c(0226): 08 84 fc a0 '  mov r15, #8 ' reg <- coni
0920(0227):             ' C_ow_io_byte_13
0920(0227): 44 7c bc a0 '  mov r11, r17 ' CVUI
0924(0228): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
0928(0229): 01 7c fc 60 '  and r11, #1 ' BANDI4 coni
092c(022a): 3e 6a bc a0 '  mov r2, r11 ' CVUI
0930(022b): 4d 6a bc 60 '  and r2, cviu_m1 ' zero extend
0934(022c): 04 5e fc a0 '  mov BC, #4 ' arg size
0938(022d): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
093c(022e): 0b 00 7c 5c '  jmp #CALA
0940(022f): 90 07 00 00 '  long @C_ow_io_bit
0944(0230): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0948(0231): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
094c(0232): 3e 86 bc a0 '  mov r16, r11 ' CVI, CVU or LOAD
0950(0233): 44 7c bc a0 '  mov r11, r17 ' CVUI
0954(0234): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
0958(0235): 01 7c fc 38 '  sar r11, #1 ' RSHI4 coni
095c(0236): 3e 88 bc a0 '  mov r17, r11 ' CVI, CVU or LOAD
0960(0237): 43 7c bc a0 '  mov r11, r16 ' CVUI
0964(0238): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
0968(0239): 00 7c 7c c2 '  cmps r11,  #0 wz
096c(023a): 13 00 7c 5c '  jmp #BR_Z
0970(023b): 08 09 00 00 '  long @C_ow_io_byte_16 ' EQI4
0974(023c): 44 7c bc a0 '  mov r11, r17 ' CVUI
0978(023d): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
097c(023e): 80 7c fc 68 '  or r11, #128 ' BORI4 coni
0980(023f): 3e 88 bc a0 '  mov r17, r11 ' CVI, CVU or LOAD
0984(0240):             ' C_ow_io_byte_16
0984(0240): 42 7c bc a0 '  mov r11, r15 ' CVUI
0988(0241): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
098c(0242): 01 7c fc d4 '  subs r11, #1 ' SUBI4 coni
0990(0243): 3e 84 bc a0 '  mov r15, r11 ' CVI, CVU or LOAD
0994(0244): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
0998(0245): 00 7c 7c c2 '  cmps r11,  #0 wz
099c(0246): 14 00 7c 5c '  jmp #BRNZ
09a0(0247): a4 08 00 00 '  long @C_ow_io_byte_13 ' NEI4
09a4(0248): 44 66 bc a0 '  mov r0, r17 ' CVUI
09a8(0249): 4d 66 bc 60 '  and r0, cviu_m1 ' zero extend
09ac(024a): 23 00 7c 5c '  jmp #POPM
09b0(024b): 00 88 03 00 '  long $38800 ' restore registers
09b4(024c): 0c 00 7c 5c '  jmp #RETN
09b8(024d):             '  long ' align long
09b8(024d):             ' C_ow_command ' <symbol:ow_command>
09b8(024d): 22 00 7c 5c '  jmp #PSHM
09bc(024e): 00 00 02 00 '  long $20000 ' save registers
09c0(024f): 35 88 bc a0 '  mov r17, r2 ' reg var <- reg arg
09c4(0250): 00 5e fc a0 '  mov BC, #0 ' arg size
09c8(0251): 0b 00 7c 5c '  jmp #CALA
09cc(0252): 3c 06 00 00 '  long @C_ow_reset ' CALL addrg
09d0(0253): cc 6a fc a0 '  mov r2, #204 ' reg ARG coni
09d4(0254): 04 5e fc a0 '  mov BC, #4 ' arg size
09d8(0255): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
09dc(0256): 0b 00 7c 5c '  jmp #CALA
09e0(0257): 94 08 00 00 '  long @C_ow_io_byte
09e4(0258): 04 58 fc 80 '  add SP, #4 ' CALL addrg
09e8(0259): 44 6a bc a0 '  mov r2, r17 ' CVUI
09ec(025a): 4d 6a bc 60 '  and r2, cviu_m1 ' zero extend
09f0(025b): 04 5e fc a0 '  mov BC, #4 ' arg size
09f4(025c): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
09f8(025d): 0b 00 7c 5c '  jmp #CALA
09fc(025e): 94 08 00 00 '  long @C_ow_io_byte
0a00(025f): 04 58 fc 80 '  add SP, #4 ' CALL addrg
0a04(0260): 23 00 7c 5c '  jmp #POPM
0a08(0261): 00 00 02 00 '  long $20000 ' restore registers
0a0c(0262): 0c 00 7c 5c '  jmp #RETN
0a10(0263):             '  long ' align long
0a10(0263):             ' C_ow_delay_usec
0a10(0263): 04 00 7c 5c '                                 jmp #LODA
0a14(0264): d0 25 00 00 '                                 long @C_usec_delay
0a18(0265): 2e 7e bc 08 '                                 rdlong r12, RI ' usec delay ' r2 - t1, r3 - t2, r12 - 4us
0a1c(0266): 02 7e fc 2c '                                 shl r12, #2 ' compute (usec * 4)
0a20(0267): 02 6a fc 2a '                                 shr r2, #2 wz
0a24(0268): 01 6a e8 a0 '         if_z    mov r2, #1
0a28(0269): 3f 6c bc a0 '                                 mov r3, r12
0a2c(026a): f1 6d bc 80 '                                 add r3, cnt
0a30(026b): 29 6c fc 84 '                                 sub r3, #41
0a34(026c):             '         C_wait
0a34(026c): 3f 6c bc f8 '                                 waitcnt r3, r12
0a38(026d): 01 6a fc 84 '                                 sub r2, #1 ' decrement
0a3c(026e): 35 6a 3c 62 '                                 test r2, r2 wz
0a40(026f): 14 00 7c 5c '                                 jmp #BRNZ
0a44(0270): b8 09 00 00 '                                 long @C_wait
0a48(0271): 0c 00 7c 5c '                                 jmp #RETN
0a4c(0272):             '  long ' align long
0a4c(0272):             ' C_t_char ' <symbol:t_char>
0a4c(0272): 22 00 7c 5c '  jmp #PSHM
0a50(0273): 00 08 03 00 '  long $30800 ' save registers
0a54(0274): 36 88 bc a0 '  mov r17, r3 ' reg var <- reg arg
0a58(0275): 35 86 bc a0 '  mov r16, r2 ' reg var <- reg arg
0a5c(0276): 44 7c bc a0 '  mov r11, r17
0a60(0277): 01 7c fc 60 '  and r11, #1 ' BANDU4 coni
0a64(0278): 17 7c fc 2c '  shl r11, #23 ' LSHU4 coni
0a68(0279): 43 7c bc 80 '  add r11, r16 ' ADDU (1)
0a6c(027a): 3e 6a bc a0 '  mov r2, r11 ' CVI, CVU or LOAD
0a70(027b): 16 6c fc a0 '  mov r3, #22 ' reg ARG coni
0a74(027c): 01 6e fc a0 '  mov r4, #1 ' reg ARG coni
0a78(027d): 0c 5e fc a0 '  mov BC, #12 ' arg size
0a7c(027e): 0c 58 fc 84 '  sub SP, #12 ' stack space for reg ARGs
0a80(027f): 0b 00 7c 5c '  jmp #CALA
0a84(0280): 20 0a 00 00 '  long @C__short_plugin_request
0a88(0281): 0c 58 fc 80 '  add SP, #12 ' CALL addrg
0a8c(0282): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
0a90(0283): 23 00 7c 5c '  jmp #POPM
0a94(0284): 00 08 03 00 '  long $30800 ' restore registers
0a98(0285): 0c 00 7c 5c '  jmp #RETN
0a9c(0286):             '  long ' align long
0a9c(0286):             ' C__short_plugin_request ' <symbol:_short_plugin_request>
0a9c(0286): 22 00 7c 5c '  jmp #PSHM
0aa0(0287): 00 88 03 00 '  long $38800 ' save registers
0aa4(0288): 37 88 bc a0 '  mov r17, r4 ' reg var <- reg arg
0aa8(0289): 36 86 bc a0 '  mov r16, r3 ' reg var <- reg arg
0aac(028a): 35 84 bc a0 '  mov r15, r2 ' reg var <- reg arg
0ab0(028b): 43 7c bc a0 '  mov r11, r16
0ab4(028c): 18 7c fc 2c '  shl r11, #24 ' LSHI4 coni
0ab8(028d): 3e 6a bc a0 '  mov r2, r11 ' ADDI/P
0abc(028e): 42 6a bc d0 '  adds r2, r15 ' ADDI/P (3)
0ac0(028f): 44 6c bc a0 '  mov r3, r17 ' CVI, CVU or LOAD
0ac4(0290): 08 5e fc a0 '  mov BC, #8 ' arg size
0ac8(0291): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0acc(0292): 0b 00 7c 5c '  jmp #CALA
0ad0(0293): 74 01 00 00 '  long @C__sys_plugin
0ad4(0294): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0ad8(0295): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
0adc(0296): 23 00 7c 5c '  jmp #POPM
0ae0(0297): 00 88 03 00 '  long $38800 ' restore registers
0ae4(0298): 0c 00 7c 5c '  jmp #RETN
0ae8(0299):             '  long ' align long
0ae8(0299):             ' C__long_plugin_request ' <symbol:_long_plugin_request>
0ae8(0299): 09 00 7c 5c '  jmp #NEWF
0aec(029a): 04 58 fc 84 '  sub SP, #4
0af0(029b): 22 00 7c 5c '  jmp #PSHM
0af4(029c): 00 8c 03 00 '  long $38c00 ' save registers
0af8(029d): 37 88 bc a0 '  mov r17, r4 ' reg var <- reg arg
0afc(029e): 36 86 bc a0 '  mov r16, r3 ' reg var <- reg arg
0b00(029f): 35 84 bc a0 '  mov r15, r2 ' reg var <- reg arg
0b04(02a0): 05 00 7c 5c '  jmp #LODF
0b08(02a1): fc ff ff ff '  long -4
0b0c(02a2): 2e 84 3c 08 '  wrlong r15, RI ' ASGNI4 addrl
0b10(02a3): 43 7c bc a0 '  mov r11, r16
0b14(02a4): 18 7c fc 2c '  shl r11, #24 ' LSHI4 coni
0b18(02a5): 2d 7a bc a0 '  mov r10, FP
0b1c(02a6): 04 7a fc 84 '  sub r10, #-(-4) ' reg <- addrli
0b20(02a7): 3e 6a bc a0 '  mov r2, r11 ' ADDI/P
0b24(02a8): 3d 6a bc d0 '  adds r2, r10 ' ADDI/P (3)
0b28(02a9): 44 6c bc a0 '  mov r3, r17 ' CVI, CVU or LOAD
0b2c(02aa): 08 5e fc a0 '  mov BC, #8 ' arg size
0b30(02ab): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0b34(02ac): 0b 00 7c 5c '  jmp #CALA
0b38(02ad): 74 01 00 00 '  long @C__sys_plugin
0b3c(02ae): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0b40(02af): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
0b44(02b0): 23 00 7c 5c '  jmp #POPM
0b48(02b1): 00 8c 03 00 '  long $38c00 ' restore registers
0b4c(02b2): 04 58 fc 80 '  add SP, #4 ' framesize
0b50(02b3): 0a 00 7c 5c '  jmp #RETF
0b54(02b4):             '  long ' align long
0b54(02b4):             ' C__long_plugin_request_2 ' <symbol:_long_plugin_request_2>
0b54(02b4): 09 00 7c 5c '  jmp #NEWF
0b58(02b5): 08 58 fc 84 '  sub SP, #8
0b5c(02b6): 22 00 7c 5c '  jmp #PSHM
0b60(02b7): 00 cc 03 00 '  long $3cc00 ' save registers
0b64(02b8): 38 88 bc a0 '  mov r17, r5 ' reg var <- reg arg
0b68(02b9): 37 86 bc a0 '  mov r16, r4 ' reg var <- reg arg
0b6c(02ba): 36 84 bc a0 '  mov r15, r3 ' reg var <- reg arg
0b70(02bb): 35 82 bc a0 '  mov r14, r2 ' reg var <- reg arg
0b74(02bc): 05 00 7c 5c '  jmp #LODF
0b78(02bd): f8 ff ff ff '  long -8
0b7c(02be): 2e 84 3c 08 '  wrlong r15, RI ' ASGNI4 addrl
0b80(02bf): 05 00 7c 5c '  jmp #LODF
0b84(02c0): fc ff ff ff '  long -4
0b88(02c1): 2e 82 3c 08 '  wrlong r14, RI ' ASGNI4 addrl
0b8c(02c2): 43 7c bc a0 '  mov r11, r16
0b90(02c3): 18 7c fc 2c '  shl r11, #24 ' LSHI4 coni
0b94(02c4): 2d 7a bc a0 '  mov r10, FP
0b98(02c5): 08 7a fc 84 '  sub r10, #-(-8) ' reg <- addrli
0b9c(02c6): 3e 6a bc a0 '  mov r2, r11 ' ADDI/P
0ba0(02c7): 3d 6a bc d0 '  adds r2, r10 ' ADDI/P (3)
0ba4(02c8): 44 6c bc a0 '  mov r3, r17 ' CVI, CVU or LOAD
0ba8(02c9): 08 5e fc a0 '  mov BC, #8 ' arg size
0bac(02ca): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0bb0(02cb): 0b 00 7c 5c '  jmp #CALA
0bb4(02cc): 74 01 00 00 '  long @C__sys_plugin
0bb8(02cd): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0bbc(02ce): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
0bc0(02cf): 23 00 7c 5c '  jmp #POPM
0bc4(02d0): 00 cc 03 00 '  long $3cc00 ' restore registers
0bc8(02d1): 08 58 fc 80 '  add SP, #8 ' framesize
0bcc(02d2): 0a 00 7c 5c '  jmp #RETF
0bd0(02d3):             '  long ' align long
0bd0(02d3):             ' C_catalina_putc ' <symbol:catalina_putc>
0bd0(02d3): 22 00 7c 5c '  jmp #PSHM
0bd4(02d4): 00 0c 03 00 '  long $30c00 ' save registers
0bd8(02d5): 36 88 bc a0 '  mov r17, r3 ' reg var <- reg arg
0bdc(02d6): 35 86 bc a0 '  mov r16, r2 ' reg var <- reg arg
0be0(02d7): 43 7c bc a0 '  mov r11, r16 ' CVI, CVU or LOAD
0be4(02d8): 04 00 7c 5c '  jmp #LODA
0be8(02d9): 50 25 00 00 '  long @C___stdout
0bec(02da): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
0bf0(02db): 3d 7c 3c 86 '  cmp r11, r10 wz
0bf4(02dc): 14 00 7c 5c '  jmp #BRNZ
0bf8(02dd): a4 0b 00 00 '  long @C_catalina_putc_2 ' NEU4
0bfc(02de): 44 6a bc a0 '  mov r2, r17 ' CVI, CVU or LOAD
0c00(02df): 01 6c fc a0 '  mov r3, #1 ' reg ARG coni
0c04(02e0): 08 5e fc a0 '  mov BC, #8 ' arg size
0c08(02e1): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0c0c(02e2): 0b 00 7c 5c '  jmp #CALA
0c10(02e3): d0 09 00 00 '  long @C_t_char
0c14(02e4): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0c18(02e5): 0e 00 7c 5c '  jmp #JMPA
0c1c(02e6): dc 0b 00 00 '  long @C_catalina_putc_3 ' JUMPV addrg
0c20(02e7):             ' C_catalina_putc_2
0c20(02e7): 43 7c bc a0 '  mov r11, r16 ' CVI, CVU or LOAD
0c24(02e8): 04 00 7c 5c '  jmp #LODA
0c28(02e9): 68 25 00 00 '  long @C___stderr
0c2c(02ea): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
0c30(02eb): 3d 7c 3c 86 '  cmp r11, r10 wz
0c34(02ec): 14 00 7c 5c '  jmp #BRNZ
0c38(02ed): dc 0b 00 00 '  long @C_catalina_putc_4 ' NEU4
0c3c(02ee): 44 6a bc a0 '  mov r2, r17 ' CVI, CVU or LOAD
0c40(02ef): 01 6c fc a0 '  mov r3, #1 ' reg ARG coni
0c44(02f0): 08 5e fc a0 '  mov BC, #8 ' arg size
0c48(02f1): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
0c4c(02f2): 0b 00 7c 5c '  jmp #CALA
0c50(02f3): d0 09 00 00 '  long @C_t_char
0c54(02f4): 08 58 fc 80 '  add SP, #8 ' CALL addrg
0c58(02f5):             ' C_catalina_putc_4
0c58(02f5):             ' C_catalina_putc_3
0c58(02f5): 44 66 bc a0 '  mov r0, r17 ' CVI, CVU or LOAD
0c5c(02f6): 23 00 7c 5c '  jmp #POPM
0c60(02f7): 00 0c 03 00 '  long $30c00 ' restore registers
0c64(02f8): 0c 00 7c 5c '  jmp #RETN
0c68(02f9):             '  long ' align long
0c68(02f9):             ' C__clockfreq
0c68(02f9): 00 66 fc 08 '  rdlong r0,#0
0c6c(02fa): 0c 00 7c 5c '  jmp #RETN
0c70(02fb):             '  long ' align long
0c70(02fb):             ' C__cnt
0c70(02fb): f1 67 bc a0 '  mov r0, CNT
0c74(02fc): 0c 00 7c 5c '  jmp #RETN
0c78(02fd):             '  long ' align long
0c78(02fd):             ' C__dira
0c78(02fd): f6 67 bc a0 '  mov r0, DIRA
0c7c(02fe): 36 ec bf 64 '  andn DIRA, r3
0c80(02ff): 35 ec bf 68 '  or DIRA, r2
0c84(0300): 0c 00 7c 5c '  jmp #RETN
0c88(0301):             '  long ' align long
0c88(0301):             ' C_tmpfilexMRBQL_4c2c6c11_gnum_L000001 ' <symbol:gnum>
0c88(0301): 22 00 7c 5c '  jmp #PSHM
0c8c(0302): 00 ec 03 00 '  long $3ec00 ' save registers
0c90(0303): 37 88 bc a0 '  mov r17, r4 ' reg var <- reg arg
0c94(0304): 36 86 bc a0 '  mov r16, r3 ' reg var <- reg arg
0c98(0305): 35 84 bc a0 '  mov r15, r2 ' reg var <- reg arg
0c9c(0306): 44 7c bc 00 '  rdbyte r11, r17 ' reg <- INDIRU1 reg
0ca0(0307): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
0ca4(0308): 2a 7c 7c c2 '  cmps r11,  #42 wz
0ca8(0309): 14 00 7c 5c '  jmp #BRNZ
0cac(030a): 64 0c 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_3 ' NEI4
0cb0(030b): 42 7c bc 08 '  rdlong r11, r15 ' reg <- INDIRP4 reg
0cb4(030c): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
0cb8(030d): 42 7c 3c 08 '  wrlong r11, r15 ' ASGNP4 reg
0cbc(030e): 04 00 7c 5c '  jmp #LODA
0cc0(030f): 2c 25 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
0cc4(0310): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
0cc8(0311): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
0ccc(0312): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
0cd0(0313): 43 7c 3c 08 '  wrlong r11, r16 ' ASGNI4 reg
0cd4(0314): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
0cd8(0315): 0e 00 7c 5c '  jmp #JMPA
0cdc(0316): b8 0c 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_4 ' JUMPV addrg
0ce0(0317):             ' C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_3
0ce0(0317): 00 82 fc a0 '  mov r14, #0 ' reg <- coni
0ce4(0318): 0e 00 7c 5c '  jmp #JMPA
0ce8(0319): 8c 0c 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_9 ' JUMPV addrg
0cec(031a):             ' C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_8
0cec(031a): 0a 7c fc a0 '  mov r11, #10 ' reg <- coni
0cf0(031b): 3e 66 bc a0 '  mov r0, r11 ' setup r0/r1 (2)
0cf4(031c): 41 68 bc a0 '  mov r1, r14 ' setup r0/r1 (2)
0cf8(031d): 12 00 7c 5c '  jmp #MULT ' MULT(I/U)
0cfc(031e): 33 82 bc a0 '  mov r14, r0 ' ADDI/P
0d00(031f): 40 82 bc d0 '  adds r14, r13 ' ADDI/P (3)
0d04(0320): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
0d08(0321):             ' C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_9
0d08(0321): 44 7c bc 00 '  rdbyte r11, r17 ' reg <- INDIRU1 reg
0d0c(0322): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
0d10(0323): 30 7c fc d4 '  subs r11, #48 ' SUBI4 coni
0d14(0324): 3e 80 bc a0 '  mov r13, r11 ' CVI, CVU or LOAD
0d18(0325): 00 7c 7c c3 '  cmps r11,  #0 wz,wc
0d1c(0326): 18 00 7c 5c '  jmp #BR_B
0d20(0327): b4 0c 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_11 ' LTI4
0d24(0328): 09 80 7c c3 '  cmps r13,  #9 wz,wc
0d28(0329): 17 00 7c 5c '  jmp #BRBE
0d2c(032a): 70 0c 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_8 ' LEI4
0d30(032b):             ' C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_11
0d30(032b): 43 82 3c 08 '  wrlong r14, r16 ' ASGNI4 reg
0d34(032c):             ' C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_4
0d34(032c): 44 66 bc a0 '  mov r0, r17 ' CVI, CVU or LOAD
0d38(032d): 23 00 7c 5c '  jmp #POPM
0d3c(032e): 00 ec 03 00 '  long $3ec00 ' restore registers
0d40(032f): 0c 00 7c 5c '  jmp #RETN
0d44(0330):             '  long ' align long
0d44(0330):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012 ' <symbol:o_print>
0d44(0330): 09 00 7c 5c '  jmp #NEWF
0d48(0331): 10 58 fc 84 '  sub SP, #16
0d4c(0332): 22 00 7c 5c '  jmp #PSHM
0d50(0333): 00 fc 03 00 '  long $3fc00 ' save registers
0d54(0334): 38 88 bc a0 '  mov r17, r5 ' reg var <- reg arg
0d58(0335): 37 86 bc a0 '  mov r16, r4 ' reg var <- reg arg
0d5c(0336): 36 84 bc a0 '  mov r15, r3 ' reg var <- reg arg
0d60(0337): 35 82 bc a0 '  mov r14, r2 ' reg var <- reg arg
0d64(0338): 44 80 bc a0 '  mov r13, r17 ' CVI, CVU or LOAD
0d68(0339): 2d 7c bc a0 '  mov r11, FP
0d6c(033a): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
0d70(033b): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
0d74(033c): 3e 7e bc a0 '  mov r12, r11
0d78(033d): 60 7e fc 60 '  and r12, #96 ' BANDI4 coni
0d7c(033e): 20 7c fc a0 '  mov r11, #32 ' reg <- coni
0d80(033f): 3e 7e 3c c2 '  cmps r12, r11 wz
0d84(0340): 13 00 7c 5c '  jmp #BR_Z
0d88(0341): 30 0d 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_17 ' EQI4
0d8c(0342): 3e 7e 3c c3 '  cmps r12, r11 wz,wc
0d90(0343): 18 00 7c 5c '  jmp #BR_B
0d94(0344): 54 0e 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_14 ' LTI4
0d98(0345): 40 7e 7c c2 '  cmps r12,  #64 wz
0d9c(0346): 13 00 7c 5c '  jmp #BR_Z
0da0(0347): c8 0d 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_20 ' EQI4
0da4(0348): 0e 00 7c 5c '  jmp #JMPA
0da8(0349): 54 0e 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_14 ' JUMPV addrg
0dac(034a):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_17
0dac(034a): 00 82 7c c2 '  cmps r14,  #0 wz
0db0(034b): 13 00 7c 5c '  jmp #BR_Z
0db4(034c): 84 0d 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_18 ' EQI4
0db8(034d): 2d 7c bc a0 '  mov r11, FP
0dbc(034e): 08 7c fc 80 '  add r11, #8 ' reg <- addrfi
0dc0(034f): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
0dc4(0350): 3e 7a bc 08 '  rdlong r10, r11 ' reg <- INDIRP4 reg
0dc8(0351): 04 7a fc d0 '  adds r10, #4 ' ADDP4 coni
0dcc(0352): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
0dd0(0353): 04 00 7c 5c '  jmp #LODA
0dd4(0354): 2c 25 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
0dd8(0355): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
0ddc(0356): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (2)
0de0(0357): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
0de4(0358): 10 7c fc 2c '  shl r11, #16
0de8(0359): 10 7c fc 38 '  sar r11, #16 ' sign extend
0dec(035a): 05 00 7c 5c '  jmp #LODF
0df0(035b): f8 ff ff ff '  long -8
0df4(035c): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
0df8(035d): 0e 00 7c 5c '  jmp #JMPA
0dfc(035e): d8 0e 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_15 ' JUMPV addrg
0e00(035f):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_18
0e00(035f): 2d 7c bc a0 '  mov r11, FP
0e04(0360): 08 7c fc 80 '  add r11, #8 ' reg <- addrfi
0e08(0361): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
0e0c(0362): 3e 7a bc 08 '  rdlong r10, r11 ' reg <- INDIRP4 reg
0e10(0363): 04 7a fc d0 '  adds r10, #4 ' ADDP4 coni
0e14(0364): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
0e18(0365): 04 00 7c 5c '  jmp #LODA
0e1c(0366): 2c 25 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
0e20(0367): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
0e24(0368): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (2)
0e28(0369): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRU4 reg
0e2c(036a): 4e 7c bc 60 '  and r11, cviu_m2 ' zero extend
0e30(036b): 05 00 7c 5c '  jmp #LODF
0e34(036c): fc ff ff ff '  long -4
0e38(036d): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNU4 addrl
0e3c(036e): 0e 00 7c 5c '  jmp #JMPA
0e40(036f): d8 0e 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_15 ' JUMPV addrg
0e44(0370):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_20
0e44(0370): 00 82 7c c2 '  cmps r14,  #0 wz
0e48(0371): 13 00 7c 5c '  jmp #BR_Z
0e4c(0372): 14 0e 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_21 ' EQI4
0e50(0373): 2d 7c bc a0 '  mov r11, FP
0e54(0374): 08 7c fc 80 '  add r11, #8 ' reg <- addrfi
0e58(0375): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
0e5c(0376): 3e 7a bc 08 '  rdlong r10, r11 ' reg <- INDIRP4 reg
0e60(0377): 04 7a fc d0 '  adds r10, #4 ' ADDP4 coni
0e64(0378): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
0e68(0379): 04 00 7c 5c '  jmp #LODA
0e6c(037a): 2c 25 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
0e70(037b): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
0e74(037c): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (2)
0e78(037d): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
0e7c(037e): 05 00 7c 5c '  jmp #LODF
0e80(037f): f8 ff ff ff '  long -8
0e84(0380): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
0e88(0381): 0e 00 7c 5c '  jmp #JMPA
0e8c(0382): d8 0e 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_15 ' JUMPV addrg
0e90(0383):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_21
0e90(0383): 2d 7c bc a0 '  mov r11, FP
0e94(0384): 08 7c fc 80 '  add r11, #8 ' reg <- addrfi
0e98(0385): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
0e9c(0386): 3e 7a bc 08 '  rdlong r10, r11 ' reg <- INDIRP4 reg
0ea0(0387): 04 7a fc d0 '  adds r10, #4 ' ADDP4 coni
0ea4(0388): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
0ea8(0389): 04 00 7c 5c '  jmp #LODA
0eac(038a): 2c 25 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
0eb0(038b): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
0eb4(038c): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (2)
0eb8(038d): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRU4 reg
0ebc(038e): 05 00 7c 5c '  jmp #LODF
0ec0(038f): fc ff ff ff '  long -4
0ec4(0390): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNU4 addrl
0ec8(0391): 0e 00 7c 5c '  jmp #JMPA
0ecc(0392): d8 0e 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_15 ' JUMPV addrg
0ed0(0393):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_14
0ed0(0393): 00 82 7c c2 '  cmps r14,  #0 wz
0ed4(0394): 13 00 7c 5c '  jmp #BR_Z
0ed8(0395): a0 0e 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_23 ' EQI4
0edc(0396): 2d 7c bc a0 '  mov r11, FP
0ee0(0397): 08 7c fc 80 '  add r11, #8 ' reg <- addrfi
0ee4(0398): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
0ee8(0399): 3e 7a bc 08 '  rdlong r10, r11 ' reg <- INDIRP4 reg
0eec(039a): 04 7a fc d0 '  adds r10, #4 ' ADDP4 coni
0ef0(039b): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
0ef4(039c): 04 00 7c 5c '  jmp #LODA
0ef8(039d): 2c 25 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
0efc(039e): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
0f00(039f): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (2)
0f04(03a0): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
0f08(03a1): 05 00 7c 5c '  jmp #LODF
0f0c(03a2): f8 ff ff ff '  long -8
0f10(03a3): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
0f14(03a4): 0e 00 7c 5c '  jmp #JMPA
0f18(03a5): d8 0e 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_15 ' JUMPV addrg
0f1c(03a6):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_23
0f1c(03a6): 2d 7c bc a0 '  mov r11, FP
0f20(03a7): 08 7c fc 80 '  add r11, #8 ' reg <- addrfi
0f24(03a8): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
0f28(03a9): 3e 7a bc 08 '  rdlong r10, r11 ' reg <- INDIRP4 reg
0f2c(03aa): 04 7a fc d0 '  adds r10, #4 ' ADDP4 coni
0f30(03ab): 3e 7a 3c 08 '  wrlong r10, r11 ' ASGNP4 reg
0f34(03ac): 04 00 7c 5c '  jmp #LODA
0f38(03ad): 2c 25 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
0f3c(03ae): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
0f40(03af): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (2)
0f44(03b0): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRU4 reg
0f48(03b1): 05 00 7c 5c '  jmp #LODF
0f4c(03b2): fc ff ff ff '  long -4
0f50(03b3): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNU4 addrl
0f54(03b4):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_15
0f54(03b4): 00 82 7c c2 '  cmps r14,  #0 wz
0f58(03b5): 13 00 7c 5c '  jmp #BR_Z
0f5c(03b6): b4 0f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_26 ' EQI4
0f60(03b7): 2d 7c bc a0 '  mov r11, FP
0f64(03b8): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
0f68(03b9): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
0f6c(03ba): 00 7c 7c c3 '  cmps r11,  #0 wz,wc
0f70(03bb): 15 00 7c 5c '  jmp #BRAE
0f74(03bc): 34 0f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_28 ' GEI4
0f78(03bd): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
0f7c(03be): 3e 88 bc a0 '  mov r17, r11
0f80(03bf): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
0f84(03c0): 2d 7a fc a0 '  mov r10, #45 ' reg <- coni
0f88(03c1): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
0f8c(03c2): 2d 7c bc a0 '  mov r11, FP
0f90(03c3): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
0f94(03c4): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
0f98(03c5): 3e 7c bc a4 '  neg r11, r11 ' NEGI4
0f9c(03c6): 05 00 7c 5c '  jmp #LODF
0fa0(03c7): f8 ff ff ff '  long -8
0fa4(03c8): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
0fa8(03c9): 0e 00 7c 5c '  jmp #JMPA
0fac(03ca): 9c 0f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_29 ' JUMPV addrg
0fb0(03cb):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_28
0fb0(03cb): 2d 7c bc a0 '  mov r11, FP
0fb4(03cc): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
0fb8(03cd): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
0fbc(03ce): 02 7c fc 60 '  and r11, #2 ' BANDI4 coni
0fc0(03cf): 00 7c 7c c2 '  cmps r11,  #0 wz
0fc4(03d0): 13 00 7c 5c '  jmp #BR_Z
0fc8(03d1): 6c 0f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_30 ' EQI4
0fcc(03d2): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
0fd0(03d3): 3e 88 bc a0 '  mov r17, r11
0fd4(03d4): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
0fd8(03d5): 2b 7a fc a0 '  mov r10, #43 ' reg <- coni
0fdc(03d6): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
0fe0(03d7): 0e 00 7c 5c '  jmp #JMPA
0fe4(03d8): 9c 0f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_31 ' JUMPV addrg
0fe8(03d9):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_30
0fe8(03d9): 2d 7c bc a0 '  mov r11, FP
0fec(03da): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
0ff0(03db): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
0ff4(03dc): 04 7c fc 60 '  and r11, #4 ' BANDI4 coni
0ff8(03dd): 00 7c 7c c2 '  cmps r11,  #0 wz
0ffc(03de): 13 00 7c 5c '  jmp #BR_Z
1000(03df): 9c 0f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_32 ' EQI4
1004(03e0): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
1008(03e1): 3e 88 bc a0 '  mov r17, r11
100c(03e2): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1010(03e3): 20 7a fc a0 '  mov r10, #32 ' reg <- coni
1014(03e4): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
1018(03e5):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_32
1018(03e5):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_31
1018(03e5):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_29
1018(03e5): 2d 7c bc a0 '  mov r11, FP
101c(03e6): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
1020(03e7): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1024(03e8): 05 00 7c 5c '  jmp #LODF
1028(03e9): fc ff ff ff '  long -4
102c(03ea): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNU4 addrl
1030(03eb):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_26
1030(03eb): 2d 7c bc a0 '  mov r11, FP
1034(03ec): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
1038(03ed): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
103c(03ee): 08 7c fc 60 '  and r11, #8 ' BANDI4 coni
1040(03ef): 00 7c 7c c2 '  cmps r11,  #0 wz
1044(03f0): 13 00 7c 5c '  jmp #BR_Z
1048(03f1): f8 0f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_34 ' EQI4
104c(03f2): 43 7c bc a0 '  mov r11, r16 ' CVUI
1050(03f3): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
1054(03f4): 6f 7c 7c c2 '  cmps r11,  #111 wz
1058(03f5): 14 00 7c 5c '  jmp #BRNZ
105c(03f6): f8 0f 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_34 ' NEI4
1060(03f7): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
1064(03f8): 3e 88 bc a0 '  mov r17, r11
1068(03f9): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
106c(03fa): 30 7a fc a0 '  mov r10, #48 ' reg <- coni
1070(03fb): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
1074(03fc):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_34
1074(03fc): 2d 7c bc a0 '  mov r11, FP
1078(03fd): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
107c(03fe): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRU4 reg
1080(03ff): 00 7c 7c 86 '  cmp r11,  #0 wz
1084(0400): 14 00 7c 5c '  jmp #BRNZ
1088(0401): 28 10 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_36 ' NEU4
108c(0402): 00 84 7c c2 '  cmps r15,  #0 wz
1090(0403): 14 00 7c 5c '  jmp #BRNZ
1094(0404): e4 10 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_37 ' NEI4
1098(0405): 44 66 bc a0 '  mov r0, r17 ' CVI, CVU or LOAD
109c(0406): 0e 00 7c 5c '  jmp #JMPA
10a0(0407): c4 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_13 ' JUMPV addrg
10a4(0408):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_36
10a4(0408): 2d 7c bc a0 '  mov r11, FP
10a8(0409): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
10ac(040a): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
10b0(040b): 08 7c fc 60 '  and r11, #8 ' BANDI4 coni
10b4(040c): 00 7c 7c c2 '  cmps r11,  #0 wz
10b8(040d): 13 00 7c 5c '  jmp #BR_Z
10bc(040e): 64 10 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_43 ' EQI4
10c0(040f): 43 7c bc a0 '  mov r11, r16 ' CVUI
10c4(0410): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
10c8(0411): 78 7c 7c c2 '  cmps r11,  #120 wz
10cc(0412): 13 00 7c 5c '  jmp #BR_Z
10d0(0413): 78 10 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_42 ' EQI4
10d4(0414): 58 7c 7c c2 '  cmps r11,  #88 wz
10d8(0415): 13 00 7c 5c '  jmp #BR_Z
10dc(0416): 78 10 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_42 ' EQI4
10e0(0417):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_43
10e0(0417): 43 7c bc a0 '  mov r11, r16 ' CVUI
10e4(0418): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
10e8(0419): 70 7c 7c c2 '  cmps r11,  #112 wz
10ec(041a): 14 00 7c 5c '  jmp #BRNZ
10f0(041b): e4 10 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_40 ' NEI4
10f4(041c):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_42
10f4(041c): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
10f8(041d): 3e 88 bc a0 '  mov r17, r11
10fc(041e): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1100(041f): 30 7a fc a0 '  mov r10, #48 ' reg <- coni
1104(0420): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
1108(0421): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
110c(0422): 3e 88 bc a0 '  mov r17, r11
1110(0423): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1114(0424): 43 7a bc a0 '  mov r10, r16 ' CVUI
1118(0425): 4d 7a bc 60 '  and r10, cviu_m1 ' zero extend
111c(0426): 58 7a 7c c2 '  cmps r10,  #88 wz
1120(0427): 14 00 7c 5c '  jmp #BRNZ
1124(0428): c4 10 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_45 ' NEI4
1128(0429): 58 7a fc a0 '  mov r10, #88 ' reg <- coni
112c(042a): 05 00 7c 5c '  jmp #LODF
1130(042b): f0 ff ff ff '  long -16
1134(042c): 2e 7a 3c 08 '  wrlong r10, RI ' ASGNI4 addrl
1138(042d): 0e 00 7c 5c '  jmp #JMPA
113c(042e): d4 10 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_46 ' JUMPV addrg
1140(042f):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_45
1140(042f): 78 7a fc a0 '  mov r10, #120 ' reg <- coni
1144(0430): 05 00 7c 5c '  jmp #LODF
1148(0431): f0 ff ff ff '  long -16
114c(0432): 2e 7a 3c 08 '  wrlong r10, RI ' ASGNI4 addrl
1150(0433):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_46
1150(0433): 2d 7a bc a0 '  mov r10, FP
1154(0434): 10 7a fc 84 '  sub r10, #-(-16) ' reg <- addrli
1158(0435): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRI4 reg
115c(0436): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
1160(0437):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_40
1160(0437):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_37
1160(0437): 43 7c bc a0 '  mov r11, r16 ' CVUI
1164(0438): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
1168(0439): 05 00 7c 5c '  jmp #LODF
116c(043a): f0 ff ff ff '  long -16
1170(043b): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1174(043c): 2d 7c bc a0 '  mov r11, FP
1178(043d): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
117c(043e): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1180(043f): 69 7a fc a0 '  mov r10, #105 ' reg <- coni
1184(0440): 3d 7c 3c c2 '  cmps r11, r10 wz
1188(0441): 13 00 7c 5c '  jmp #BR_Z
118c(0442): 04 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_52 ' EQI4
1190(0443): 3d 7c 3c c3 '  cmps r11, r10 wz,wc
1194(0444): 16 00 7c 5c '  jmp #BR_A
1198(0445): 74 11 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_55 ' GTI4
119c(0446): 2d 7c bc a0 '  mov r11, FP
11a0(0447): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
11a4(0448): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
11a8(0449): 58 7a fc a0 '  mov r10, #88 ' reg <- coni
11ac(044a): 3d 7c 3c c2 '  cmps r11, r10 wz
11b0(044b): 13 00 7c 5c '  jmp #BR_Z
11b4(044c): 1c 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_53 ' EQI4
11b8(044d): 3d 7c 3c c3 '  cmps r11, r10 wz,wc
11bc(044e): 18 00 7c 5c '  jmp #BR_B
11c0(044f): 2c 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_47 ' LTI4
11c4(0450): 2d 7c bc a0 '  mov r11, FP
11c8(0451): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
11cc(0452): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
11d0(0453): 62 7c 7c c2 '  cmps r11,  #98 wz
11d4(0454): 13 00 7c 5c '  jmp #BR_Z
11d8(0455): d4 11 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_50 ' EQI4
11dc(0456): 64 7c 7c c2 '  cmps r11,  #100 wz
11e0(0457): 13 00 7c 5c '  jmp #BR_Z
11e4(0458): 04 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_52 ' EQI4
11e8(0459): 0e 00 7c 5c '  jmp #JMPA
11ec(045a): 2c 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_47 ' JUMPV addrg
11f0(045b):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_55
11f0(045b): 2d 7c bc a0 '  mov r11, FP
11f4(045c): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
11f8(045d): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
11fc(045e): 6f 7a fc a0 '  mov r10, #111 ' reg <- coni
1200(045f): 3d 7c 3c c2 '  cmps r11, r10 wz
1204(0460): 13 00 7c 5c '  jmp #BR_Z
1208(0461): ec 11 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_51 ' EQI4
120c(0462): 70 7c 7c c2 '  cmps r11,  #112 wz
1210(0463): 13 00 7c 5c '  jmp #BR_Z
1214(0464): 1c 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_53 ' EQI4
1218(0465): 3d 7c 3c c3 '  cmps r11, r10 wz,wc
121c(0466): 18 00 7c 5c '  jmp #BR_B
1220(0467): 2c 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_47 ' LTI4
1224(0468): 2d 7c bc a0 '  mov r11, FP
1228(0469): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
122c(046a): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1230(046b): 75 7c 7c c2 '  cmps r11,  #117 wz
1234(046c): 13 00 7c 5c '  jmp #BR_Z
1238(046d): 04 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_52 ' EQI4
123c(046e): 78 7c 7c c2 '  cmps r11,  #120 wz
1240(046f): 13 00 7c 5c '  jmp #BR_Z
1244(0470): 1c 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_53 ' EQI4
1248(0471): 0e 00 7c 5c '  jmp #JMPA
124c(0472): 2c 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_47 ' JUMPV addrg
1250(0473):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_50
1250(0473): 02 7c fc a0 '  mov r11, #2 ' reg <- coni
1254(0474): 05 00 7c 5c '  jmp #LODF
1258(0475): f4 ff ff ff '  long -12
125c(0476): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1260(0477): 0e 00 7c 5c '  jmp #JMPA
1264(0478): 2c 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_48 ' JUMPV addrg
1268(0479):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_51
1268(0479): 08 7c fc a0 '  mov r11, #8 ' reg <- coni
126c(047a): 05 00 7c 5c '  jmp #LODF
1270(047b): f4 ff ff ff '  long -12
1274(047c): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1278(047d): 0e 00 7c 5c '  jmp #JMPA
127c(047e): 2c 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_48 ' JUMPV addrg
1280(047f):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_52
1280(047f): 0a 7c fc a0 '  mov r11, #10 ' reg <- coni
1284(0480): 05 00 7c 5c '  jmp #LODF
1288(0481): f4 ff ff ff '  long -12
128c(0482): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1290(0483): 0e 00 7c 5c '  jmp #JMPA
1294(0484): 2c 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_48 ' JUMPV addrg
1298(0485):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_53
1298(0485): 10 7c fc a0 '  mov r11, #16 ' reg <- coni
129c(0486): 05 00 7c 5c '  jmp #LODF
12a0(0487): f4 ff ff ff '  long -12
12a4(0488): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
12a8(0489):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_47
12a8(0489):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_48
12a8(0489): 42 6a bc a0 '  mov r2, r15 ' CVI, CVU or LOAD
12ac(048a): 44 6c bc a0 '  mov r3, r17 ' CVI, CVU or LOAD
12b0(048b): 2d 5c bc a0 '  mov RI, FP
12b4(048c): 0c 5c fc 84 '  sub RI, #-(-12)
12b8(048d): 2e 6e bc 08 '  rdlong r4, RI ' reg ARG INDIR ADDRLi
12bc(048e): 2d 5c bc a0 '  mov RI, FP
12c0(048f): 04 5c fc 84 '  sub RI, #-(-4)
12c4(0490): 2e 70 bc 08 '  rdlong r5, RI ' reg ARG INDIR ADDRLi
12c8(0491): 10 5e fc a0 '  mov BC, #16 ' arg size
12cc(0492): 10 58 fc 84 '  sub SP, #16 ' stack space for reg ARGs
12d0(0493): 0b 00 7c 5c '  jmp #CALA
12d4(0494): 60 22 00 00 '  long @C__i_compute
12d8(0495): 10 58 fc 80 '  add SP, #16 ' CALL addrg
12dc(0496): 33 88 bc a0 '  mov r17, r0 ' CVI, CVU or LOAD
12e0(0497): 43 7c bc a0 '  mov r11, r16 ' CVUI
12e4(0498): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
12e8(0499): 58 7c 7c c2 '  cmps r11,  #88 wz
12ec(049a): 14 00 7c 5c '  jmp #BRNZ
12f0(049b): c0 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_58 ' NEI4
12f4(049c): 0e 00 7c 5c '  jmp #JMPA
12f8(049d): ac 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_61 ' JUMPV addrg
12fc(049e):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_60
12fc(049e): 40 7c bc 00 '  rdbyte r11, r13 ' reg <- INDIRU1 reg
1300(049f): 3e 6a bc a0 '  mov r2, r11 ' CVUI
1304(04a0): 4d 6a bc 60 '  and r2, cviu_m1 ' zero extend
1308(04a1): 04 5e fc a0 '  mov BC, #4 ' arg size
130c(04a2): 04 58 fc 84 '  sub SP, #4 ' stack space for reg ARGs
1310(04a3): 0b 00 7c 5c '  jmp #CALA
1314(04a4): 38 24 00 00 '  long @C_toupper
1318(04a5): 04 58 fc 80 '  add SP, #4 ' CALL addrg
131c(04a6): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
1320(04a7): 40 7c 3c 00 '  wrbyte r11, r13 ' ASGNU1 reg
1324(04a8): 01 80 fc d0 '  adds r13, #1 ' ADDP4 coni
1328(04a9):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_61
1328(04a9): 40 7c bc a0 '  mov r11, r13 ' CVI, CVU or LOAD
132c(04aa): 44 7a bc a0 '  mov r10, r17 ' CVI, CVU or LOAD
1330(04ab): 3d 7c 3c 86 '  cmp r11, r10 wz
1334(04ac): 14 00 7c 5c '  jmp #BRNZ
1338(04ad): 80 12 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_60 ' NEU4
133c(04ae):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_58
133c(04ae): 44 66 bc a0 '  mov r0, r17 ' CVI, CVU or LOAD
1340(04af):             ' C_tmpfilehCn8zT_4c2c6c11_o_print_L000012_13
1340(04af): 23 00 7c 5c '  jmp #POPM
1344(04b0): 00 fc 03 00 '  long $3fc00 ' restore registers
1348(04b1): 10 58 fc 80 '  add SP, #16 ' framesize
134c(04b2): 0a 00 7c 5c '  jmp #RETF
1350(04b3):             '  long ' align long
1350(04b3):             ' C__doprnt ' <symbol:_doprnt>
1350(04b3): 09 00 7c 5c '  jmp #NEWF
1354(04b4): 03 00 7c 5c '  jmp #LODL
1358(04b5): 30 04 00 00 '  long 1072
135c(04b6): 2e 58 bc 84 '  sub SP, RI
1360(04b7): 22 00 7c 5c '  jmp #PSHM
1364(04b8): 00 fe 03 00 '  long $3fe00 ' save registers
1368(04b9): 37 88 bc a0 '  mov r17, r4 ' reg var <- reg arg
136c(04ba): 2d 5c bc a0 '  mov RI, FP
1370(04bb): 0c 5c fc 80 '  add RI, #12
1374(04bc): 2e 6c 3c 08 '  wrlong r3, RI ' spill reg
1378(04bd): 35 86 bc a0 '  mov r16, r2 ' reg var <- reg arg
137c(04be): 00 7e fc a0 '  mov r12, #0 ' reg <- coni
1380(04bf): 0e 00 7c 5c '  jmp #JMPA
1384(04c0): 18 22 00 00 '  long @C__doprnt_65 ' JUMPV addrg
1388(04c1):             ' C__doprnt_64
1388(04c1): 2d 7c bc a0 '  mov r11, FP
138c(04c2): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
1390(04c3): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1394(04c4): 25 7c 7c c2 '  cmps r11,  #37 wz
1398(04c5): 13 00 7c 5c '  jmp #BR_Z
139c(04c6): bc 13 00 00 '  long @C__doprnt_67 ' EQI4
13a0(04c7): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
13a4(04c8): 2d 5c bc a0 '  mov RI, FP
13a8(04c9): 10 5c fc 84 '  sub RI, #-(-16)
13ac(04ca): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRLi
13b0(04cb): 08 5e fc a0 '  mov BC, #8 ' arg size
13b4(04cc): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
13b8(04cd): 0b 00 7c 5c '  jmp #CALA
13bc(04ce): 00 24 00 00 '  long @C_putc
13c0(04cf): 08 58 fc 80 '  add SP, #8 ' CALL addrg
13c4(04d0): 04 00 7c 5c '  jmp #LODA
13c8(04d1): 28 25 00 00 '  long @C__doprnt_L000071
13cc(04d2): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
13d0(04d3): 3d 66 3c c2 '  cmps r0, r10 wz
13d4(04d4): 14 00 7c 5c '  jmp #BRNZ
13d8(04d5): b0 13 00 00 '  long @C__doprnt_69 ' NEI4
13dc(04d6): 00 7e 7c c2 '  cmps r12,  #0 wz
13e0(04d7): 13 00 7c 5c '  jmp #BR_Z
13e4(04d8): 84 13 00 00 '  long @C__doprnt_75 ' EQI4
13e8(04d9): 3f 7c bc a4 '  neg r11, r12 ' NEGI4
13ec(04da): 05 00 7c 5c '  jmp #LODF
13f0(04db): d8 fb ff ff '  long -1064
13f4(04dc): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
13f8(04dd): 0e 00 7c 5c '  jmp #JMPA
13fc(04de): 9c 13 00 00 '  long @C__doprnt_76 ' JUMPV addrg
1400(04df):             ' C__doprnt_75
1400(04df): 04 00 7c 5c '  jmp #LODA
1404(04e0): 28 25 00 00 '  long @C__doprnt_L000071
1408(04e1): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
140c(04e2): 05 00 7c 5c '  jmp #LODF
1410(04e3): d8 fb ff ff '  long -1064
1414(04e4): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1418(04e5):             ' C__doprnt_76
1418(04e5): 05 00 7c 5c '  jmp #LODF
141c(04e6): d8 fb ff ff '  long -1064
1420(04e7): 2e 66 bc 08 '  rdlong r0, RI ' reg <- INDIRI4 addrl
1424(04e8): 0e 00 7c 5c '  jmp #JMPA
1428(04e9): 48 22 00 00 '  long @C__doprnt_63 ' JUMPV addrg
142c(04ea):             ' C__doprnt_69
142c(04ea): 01 7e fc d0 '  adds r12, #1 ' ADDI4 coni
1430(04eb): 0e 00 7c 5c '  jmp #JMPA
1434(04ec): 18 22 00 00 '  long @C__doprnt_65 ' JUMPV addrg
1438(04ed):             ' C__doprnt_67
1438(04ed): 00 80 fc a0 '  mov r13, #0 ' reg <- coni
143c(04ee):             ' C__doprnt_77
143c(04ee): 44 7c bc 00 '  rdbyte r11, r17 ' reg <- INDIRU1 reg
1440(04ef): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
1444(04f0): 05 00 7c 5c '  jmp #LODF
1448(04f1): d8 fb ff ff '  long -1064
144c(04f2): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1450(04f3): 05 00 7c 5c '  jmp #LODF
1454(04f4): d8 fb ff ff '  long -1064
1458(04f5): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
145c(04f6): 20 7a fc a0 '  mov r10, #32 ' reg <- coni
1460(04f7): 3d 7c 3c c2 '  cmps r11, r10 wz
1464(04f8): 13 00 7c 5c '  jmp #BR_Z
1468(04f9): 58 14 00 00 '  long @C__doprnt_85 ' EQI4
146c(04fa): 23 7c 7c c2 '  cmps r11,  #35 wz
1470(04fb): 13 00 7c 5c '  jmp #BR_Z
1474(04fc): 64 14 00 00 '  long @C__doprnt_86 ' EQI4
1478(04fd): 3d 7c 3c c3 '  cmps r11, r10 wz,wc
147c(04fe): 18 00 7c 5c '  jmp #BR_B
1480(04ff): 7c 14 00 00 '  long @C__doprnt_80 ' LTI4
1484(0500): 05 00 7c 5c '  jmp #LODF
1488(0501): d8 fb ff ff '  long -1064
148c(0502): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
1490(0503): 2b 7c 7c c2 '  cmps r11,  #43 wz
1494(0504): 13 00 7c 5c '  jmp #BR_Z
1498(0505): 4c 14 00 00 '  long @C__doprnt_84 ' EQI4
149c(0506): 2d 7c 7c c2 '  cmps r11,  #45 wz
14a0(0507): 13 00 7c 5c '  jmp #BR_Z
14a4(0508): 40 14 00 00 '  long @C__doprnt_83 ' EQI4
14a8(0509): 30 7c 7c c2 '  cmps r11,  #48 wz
14ac(050a): 13 00 7c 5c '  jmp #BR_Z
14b0(050b): 70 14 00 00 '  long @C__doprnt_87 ' EQI4
14b4(050c): 0e 00 7c 5c '  jmp #JMPA
14b8(050d): 7c 14 00 00 '  long @C__doprnt_80 ' JUMPV addrg
14bc(050e):             ' C__doprnt_83
14bc(050e): 01 80 fc 68 '  or r13, #1 ' BORI4 coni
14c0(050f): 0e 00 7c 5c '  jmp #JMPA
14c4(0510): 94 14 00 00 '  long @C__doprnt_81 ' JUMPV addrg
14c8(0511):             ' C__doprnt_84
14c8(0511): 02 80 fc 68 '  or r13, #2 ' BORI4 coni
14cc(0512): 0e 00 7c 5c '  jmp #JMPA
14d0(0513): 94 14 00 00 '  long @C__doprnt_81 ' JUMPV addrg
14d4(0514):             ' C__doprnt_85
14d4(0514): 04 80 fc 68 '  or r13, #4 ' BORI4 coni
14d8(0515): 0e 00 7c 5c '  jmp #JMPA
14dc(0516): 94 14 00 00 '  long @C__doprnt_81 ' JUMPV addrg
14e0(0517):             ' C__doprnt_86
14e0(0517): 08 80 fc 68 '  or r13, #8 ' BORI4 coni
14e4(0518): 0e 00 7c 5c '  jmp #JMPA
14e8(0519): 94 14 00 00 '  long @C__doprnt_81 ' JUMPV addrg
14ec(051a):             ' C__doprnt_87
14ec(051a): 10 80 fc 68 '  or r13, #16 ' BORI4 coni
14f0(051b): 0e 00 7c 5c '  jmp #JMPA
14f4(051c): 94 14 00 00 '  long @C__doprnt_81 ' JUMPV addrg
14f8(051d):             ' C__doprnt_80
14f8(051d): 04 00 7c 5c '  jmp #LODA
14fc(051e): 24 25 00 00 '  long @C__doprnt_L000088
1500(051f): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1504(0520): 3e 80 bc 68 '  or r13, r11 ' BORI/U (1)
1508(0521): 0e 00 7c 5c '  jmp #JMPA
150c(0522): 98 14 00 00 '  long @C__doprnt_78 ' JUMPV addrg
1510(0523):             ' C__doprnt_81
1510(0523): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1514(0524):             ' C__doprnt_78
1514(0524): 04 00 7c 5c '  jmp #LODA
1518(0525): 24 25 00 00 '  long @C__doprnt_L000088
151c(0526): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1520(0527): 40 7c bc 60 '  and r11, r13 ' BANDI/U (2)
1524(0528): 00 7c 7c c2 '  cmps r11,  #0 wz
1528(0529): 13 00 7c 5c '  jmp #BR_Z
152c(052a): c0 13 00 00 '  long @C__doprnt_77 ' EQI4
1530(052b): 05 00 7c 5c '  jmp #LODF
1534(052c): e4 ff ff ff '  long -28
1538(052d): 2e 88 3c 08 '  wrlong r17, RI ' ASGNP4 addrl
153c(052e): 2d 6a bc a0 '  mov r2, FP
1540(052f): 0c 6a fc 80 '  add r2, #12 ' reg ARG ADDRFi
1544(0530): 2d 6c bc a0 '  mov r3, FP
1548(0531): 14 6c fc 84 '  sub r3, #-(-20) ' reg ARG ADDRLi
154c(0532): 44 6e bc a0 '  mov r4, r17 ' CVI, CVU or LOAD
1550(0533): 0c 5e fc a0 '  mov BC, #12 ' arg size
1554(0534): 0c 58 fc 84 '  sub SP, #12 ' stack space for reg ARGs
1558(0535): 0b 00 7c 5c '  jmp #CALA
155c(0536): 0c 0c 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001
1560(0537): 0c 58 fc 80 '  add SP, #12 ' CALL addrg
1564(0538): 33 88 bc a0 '  mov r17, r0 ' CVI, CVU or LOAD
1568(0539): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
156c(053a): 2d 7a bc a0 '  mov r10, FP
1570(053b): 1c 7a fc 84 '  sub r10, #-(-28) ' reg <- addrli
1574(053c): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRP4 reg
1578(053d): 3d 7c 3c 86 '  cmp r11, r10 wz
157c(053e): 13 00 7c 5c '  jmp #BR_Z
1580(053f): 0c 15 00 00 '  long @C__doprnt_92 ' EQU4
1584(0540): 00 81 fc 68 '  or r13, #256 ' BORI4 coni
1588(0541):             ' C__doprnt_92
1588(0541): 44 7c bc 00 '  rdbyte r11, r17 ' reg <- INDIRU1 reg
158c(0542): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
1590(0543): 2e 7c 7c c2 '  cmps r11,  #46 wz
1594(0544): 14 00 7c 5c '  jmp #BRNZ
1598(0545): 84 15 00 00 '  long @C__doprnt_94 ' NEI4
159c(0546): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
15a0(0547): 05 00 7c 5c '  jmp #LODF
15a4(0548): e4 ff ff ff '  long -28
15a8(0549): 2e 88 3c 08 '  wrlong r17, RI ' ASGNP4 addrl
15ac(054a): 2d 6a bc a0 '  mov r2, FP
15b0(054b): 0c 6a fc 80 '  add r2, #12 ' reg ARG ADDRFi
15b4(054c): 2d 6c bc a0 '  mov r3, FP
15b8(054d): 18 6c fc 84 '  sub r3, #-(-24) ' reg ARG ADDRLi
15bc(054e): 44 6e bc a0 '  mov r4, r17 ' CVI, CVU or LOAD
15c0(054f): 0c 5e fc a0 '  mov BC, #12 ' arg size
15c4(0550): 0c 58 fc 84 '  sub SP, #12 ' stack space for reg ARGs
15c8(0551): 0b 00 7c 5c '  jmp #CALA
15cc(0552): 0c 0c 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001
15d0(0553): 0c 58 fc 80 '  add SP, #12 ' CALL addrg
15d4(0554): 33 88 bc a0 '  mov r17, r0 ' CVI, CVU or LOAD
15d8(0555): 2d 7c bc a0 '  mov r11, FP
15dc(0556): 18 7c fc 84 '  sub r11, #-(-24) ' reg <- addrli
15e0(0557): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
15e4(0558): 00 7c 7c c3 '  cmps r11,  #0 wz,wc
15e8(0559): 18 00 7c 5c '  jmp #BR_B
15ec(055a): 84 15 00 00 '  long @C__doprnt_96 ' LTI4
15f0(055b): 04 00 7c 5c '  jmp #LODA
15f4(055c): 20 25 00 00 '  long @C__doprnt_L000098
15f8(055d): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
15fc(055e): 3e 80 bc 68 '  or r13, r11 ' BORI/U (1)
1600(055f):             ' C__doprnt_96
1600(055f):             ' C__doprnt_94
1600(055f): 00 7c fc a0 '  mov r11, #0 ' reg <- coni
1604(0560): 40 7a bc a0 '  mov r10, r13
1608(0561): 00 7b fc 60 '  and r10, #256 ' BANDI4 coni
160c(0562): 3e 7a 3c c2 '  cmps r10, r11 wz
1610(0563): 13 00 7c 5c '  jmp #BR_Z
1614(0564): d4 15 00 00 '  long @C__doprnt_101 ' EQI4
1618(0565): 2d 7a bc a0 '  mov r10, FP
161c(0566): 14 7a fc 84 '  sub r10, #-(-20) ' reg <- addrli
1620(0567): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRI4 reg
1624(0568): 3e 7a 3c c3 '  cmps r10, r11 wz,wc
1628(0569): 15 00 7c 5c '  jmp #BRAE
162c(056a): d4 15 00 00 '  long @C__doprnt_101 ' GEI4
1630(056b): 2d 7c bc a0 '  mov r11, FP
1634(056c): 14 7c fc 84 '  sub r11, #-(-20) ' reg <- addrli
1638(056d): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
163c(056e): 3e 7c bc a4 '  neg r11, r11 ' NEGI4
1640(056f): 05 00 7c 5c '  jmp #LODF
1644(0570): ec ff ff ff '  long -20
1648(0571): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
164c(0572): 01 80 fc 68 '  or r13, #1 ' BORI4 coni
1650(0573):             ' C__doprnt_101
1650(0573): 40 7c bc a0 '  mov r11, r13
1654(0574): 00 7d fc 60 '  and r11, #256 ' BANDI4 coni
1658(0575): 00 7c 7c c2 '  cmps r11,  #0 wz
165c(0576): 14 00 7c 5c '  jmp #BRNZ
1660(0577): f8 15 00 00 '  long @C__doprnt_103 ' NEI4
1664(0578): 00 7c fc a0 '  mov r11, #0 ' reg <- coni
1668(0579): 05 00 7c 5c '  jmp #LODF
166c(057a): ec ff ff ff '  long -20
1670(057b): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1674(057c):             ' C__doprnt_103
1674(057c): 40 7c bc a0 '  mov r11, r13
1678(057d): 02 7c fc 60 '  and r11, #2 ' BANDI4 coni
167c(057e): 00 7c 7c c2 '  cmps r11,  #0 wz
1680(057f): 13 00 7c 5c '  jmp #BR_Z
1684(0580): 1c 16 00 00 '  long @C__doprnt_105 ' EQI4
1688(0581): 04 00 7c 5c '  jmp #LODA
168c(0582): 1c 25 00 00 '  long @C__doprnt_L000107
1690(0583): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1694(0584): 3e 80 bc 60 '  and r13, r11 ' BANDI/U (1)
1698(0585):             ' C__doprnt_105
1698(0585): 40 7c bc a0 '  mov r11, r13
169c(0586): 01 7c fc 60 '  and r11, #1 ' BANDI4 coni
16a0(0587): 00 7c 7c c2 '  cmps r11,  #0 wz
16a4(0588): 13 00 7c 5c '  jmp #BR_Z
16a8(0589): 40 16 00 00 '  long @C__doprnt_110 ' EQI4
16ac(058a): 04 00 7c 5c '  jmp #LODA
16b0(058b): 18 25 00 00 '  long @C__doprnt_L000112
16b4(058c): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
16b8(058d): 3e 80 bc 60 '  and r13, r11 ' BANDI/U (1)
16bc(058e):             ' C__doprnt_110
16bc(058e): 05 00 7c 5c '  jmp #LODF
16c0(058f): dc fb ff ff '  long -1060
16c4(0590): 2e 7c bc a0 '  mov r11, RI ' reg <- addrl
16c8(0591): 05 00 7c 5c '  jmp #LODF
16cc(0592): fc ff ff ff '  long -4
16d0(0593): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
16d4(0594): 05 00 7c 5c '  jmp #LODF
16d8(0595): dc fb ff ff '  long -1060
16dc(0596): 2e 84 bc a0 '  mov r15, RI ' reg <- addrl
16e0(0597): 44 7c bc 00 '  rdbyte r11, r17 ' reg <- INDIRU1 reg
16e4(0598): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
16e8(0599): 05 00 7c 5c '  jmp #LODF
16ec(059a): d8 fb ff ff '  long -1064
16f0(059b): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
16f4(059c): 05 00 7c 5c '  jmp #LODF
16f8(059d): d8 fb ff ff '  long -1064
16fc(059e): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
1700(059f): 68 7a fc a0 '  mov r10, #104 ' reg <- coni
1704(05a0): 3d 7c 3c c2 '  cmps r11, r10 wz
1708(05a1): 13 00 7c 5c '  jmp #BR_Z
170c(05a2): e0 16 00 00 '  long @C__doprnt_118 ' EQI4
1710(05a3): 3d 7c 3c c3 '  cmps r11, r10 wz,wc
1714(05a4): 16 00 7c 5c '  jmp #BR_A
1718(05a5): c0 16 00 00 '  long @C__doprnt_122 ' GTI4
171c(05a6): 05 00 7c 5c '  jmp #LODF
1720(05a7): d8 fb ff ff '  long -1064
1724(05a8): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
1728(05a9): 4c 7c 7c c2 '  cmps r11,  #76 wz
172c(05aa): 13 00 7c 5c '  jmp #BR_Z
1730(05ab): 00 17 00 00 '  long @C__doprnt_120 ' EQI4
1734(05ac): 0e 00 7c 5c '  jmp #JMPA
1738(05ad): 08 17 00 00 '  long @C__doprnt_115 ' JUMPV addrg
173c(05ae):             ' C__doprnt_122
173c(05ae): 05 00 7c 5c '  jmp #LODF
1740(05af): d8 fb ff ff '  long -1064
1744(05b0): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
1748(05b1): 6c 7c 7c c2 '  cmps r11,  #108 wz
174c(05b2): 13 00 7c 5c '  jmp #BR_Z
1750(05b3): f0 16 00 00 '  long @C__doprnt_119 ' EQI4
1754(05b4): 0e 00 7c 5c '  jmp #JMPA
1758(05b5): 08 17 00 00 '  long @C__doprnt_115 ' JUMPV addrg
175c(05b6):             ' C__doprnt_118
175c(05b6): 20 80 fc 68 '  or r13, #32 ' BORI4 coni
1760(05b7): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1764(05b8): 0e 00 7c 5c '  jmp #JMPA
1768(05b9): 08 17 00 00 '  long @C__doprnt_116 ' JUMPV addrg
176c(05ba):             ' C__doprnt_119
176c(05ba): 40 80 fc 68 '  or r13, #64 ' BORI4 coni
1770(05bb): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1774(05bc): 0e 00 7c 5c '  jmp #JMPA
1778(05bd): 08 17 00 00 '  long @C__doprnt_116 ' JUMPV addrg
177c(05be):             ' C__doprnt_120
177c(05be): 80 80 fc 68 '  or r13, #128 ' BORI4 coni
1780(05bf): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1784(05c0):             ' C__doprnt_115
1784(05c0):             ' C__doprnt_116
1784(05c0): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
1788(05c1): 3e 88 bc a0 '  mov r17, r11
178c(05c2): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
1790(05c3): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
1794(05c4): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
1798(05c5): 05 00 7c 5c '  jmp #LODF
179c(05c6): f0 ff ff ff '  long -16
17a0(05c7): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
17a4(05c8): 05 00 7c 5c '  jmp #LODF
17a8(05c9): d4 fb ff ff '  long -1068
17ac(05ca): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
17b0(05cb): 05 00 7c 5c '  jmp #LODF
17b4(05cc): d4 fb ff ff '  long -1068
17b8(05cd): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
17bc(05ce): 62 7c 7c c3 '  cmps r11,  #98 wz,wc
17c0(05cf): 18 00 7c 5c '  jmp #BR_B
17c4(05d0): 74 17 00 00 '  long @C__doprnt_160 ' LTI4
17c8(05d1): 75 7c 7c c3 '  cmps r11,  #117 wz,wc
17cc(05d2): 16 00 7c 5c '  jmp #BR_A
17d0(05d3): 94 17 00 00 '  long @C__doprnt_161 ' GTI4
17d4(05d4): 02 7c fc 2c '  shl r11, #2 ' LSHI4 coni
17d8(05d5): 04 00 7c 5c '  jmp #LODA
17dc(05d6): 34 23 00 00 '  long @C__doprnt_162_L000164-392
17e0(05d7): 2e 7a bc a0 '  mov r10, RI ' reg <- addrg
17e4(05d8): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
17e8(05d9): 3e 5c bc 08 '  rdlong RI, r11
17ec(05da): 0f 00 7c 5c '  jmp #JMPI ' JUMPV INDIR reg
17f0(05db):             ' C__doprnt_160
17f0(05db): 05 00 7c 5c '  jmp #LODF
17f4(05dc): d4 fb ff ff '  long -1068
17f8(05dd): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
17fc(05de): 58 7c 7c c2 '  cmps r11,  #88 wz
1800(05df): 13 00 7c 5c '  jmp #BR_Z
1804(05e0): 24 1a 00 00 '  long @C__doprnt_147 ' EQI4
1808(05e1): 0e 00 7c 5c '  jmp #JMPA
180c(05e2): b4 17 00 00 '  long @C__doprnt_123 ' JUMPV addrg
1810(05e3):             ' C__doprnt_161
1810(05e3): 05 00 7c 5c '  jmp #LODF
1814(05e4): d4 fb ff ff '  long -1068
1818(05e5): 2e 7c bc 08 '  rdlong r11, RI ' reg <- INDIRI4 addrl
181c(05e6): 78 7c 7c c2 '  cmps r11,  #120 wz
1820(05e7): 13 00 7c 5c '  jmp #BR_Z
1824(05e8): 24 1a 00 00 '  long @C__doprnt_147 ' EQI4
1828(05e9): 0e 00 7c 5c '  jmp #JMPA
182c(05ea): b4 17 00 00 '  long @C__doprnt_123 ' JUMPV addrg
1830(05eb):             ' C__doprnt_123
1830(05eb): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
1834(05ec): 2d 5c bc a0 '  mov RI, FP
1838(05ed): 10 5c fc 84 '  sub RI, #-(-16)
183c(05ee): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRLi
1840(05ef): 08 5e fc a0 '  mov BC, #8 ' arg size
1844(05f0): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
1848(05f1): 0b 00 7c 5c '  jmp #CALA
184c(05f2): 00 24 00 00 '  long @C_putc
1850(05f3): 08 58 fc 80 '  add SP, #8 ' CALL addrg
1854(05f4): 04 00 7c 5c '  jmp #LODA
1858(05f5): 28 25 00 00 '  long @C__doprnt_L000071
185c(05f6): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
1860(05f7): 3d 66 3c c2 '  cmps r0, r10 wz
1864(05f8): 14 00 7c 5c '  jmp #BRNZ
1868(05f9): 40 18 00 00 '  long @C__doprnt_126 ' NEI4
186c(05fa): 00 7e 7c c2 '  cmps r12,  #0 wz
1870(05fb): 13 00 7c 5c '  jmp #BR_Z
1874(05fc): 14 18 00 00 '  long @C__doprnt_129 ' EQI4
1878(05fd): 3f 7c bc a4 '  neg r11, r12 ' NEGI4
187c(05fe): 05 00 7c 5c '  jmp #LODF
1880(05ff): d0 fb ff ff '  long -1072
1884(0600): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1888(0601): 0e 00 7c 5c '  jmp #JMPA
188c(0602): 2c 18 00 00 '  long @C__doprnt_130 ' JUMPV addrg
1890(0603):             ' C__doprnt_129
1890(0603): 04 00 7c 5c '  jmp #LODA
1894(0604): 28 25 00 00 '  long @C__doprnt_L000071
1898(0605): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
189c(0606): 05 00 7c 5c '  jmp #LODF
18a0(0607): d0 fb ff ff '  long -1072
18a4(0608): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
18a8(0609):             ' C__doprnt_130
18a8(0609): 05 00 7c 5c '  jmp #LODF
18ac(060a): d0 fb ff ff '  long -1072
18b0(060b): 2e 66 bc 08 '  rdlong r0, RI ' reg <- INDIRI4 addrl
18b4(060c): 0e 00 7c 5c '  jmp #JMPA
18b8(060d): 48 22 00 00 '  long @C__doprnt_63 ' JUMPV addrg
18bc(060e):             ' C__doprnt_126
18bc(060e): 01 7e fc d0 '  adds r12, #1 ' ADDI4 coni
18c0(060f): 0e 00 7c 5c '  jmp #JMPA
18c4(0610): 18 22 00 00 '  long @C__doprnt_65 ' JUMPV addrg
18c8(0611):             ' C__doprnt_131
18c8(0611): 40 7c bc a0 '  mov r11, r13
18cc(0612): 20 7c fc 60 '  and r11, #32 ' BANDI4 coni
18d0(0613): 00 7c 7c c2 '  cmps r11,  #0 wz
18d4(0614): 13 00 7c 5c '  jmp #BR_Z
18d8(0615): a0 18 00 00 '  long @C__doprnt_132 ' EQI4
18dc(0616): 2d 7c bc a0 '  mov r11, FP
18e0(0617): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
18e4(0618): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
18e8(0619): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
18ec(061a): 05 00 7c 5c '  jmp #LODF
18f0(061b): 0c 00 00 00 '  long 12
18f4(061c): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
18f8(061d): 04 00 7c 5c '  jmp #LODA
18fc(061e): 2c 25 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
1900(061f): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
1904(0620): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
1908(0621): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
190c(0622): 3f 7a bc a0 '  mov r10, r12 ' CVI, CVU or LOAD
1910(0623): 3e 7a 3c 04 '  wrword r10, r11 ' ASGNI2 reg
1914(0624): 0e 00 7c 5c '  jmp #JMPA
1918(0625): 18 22 00 00 '  long @C__doprnt_65 ' JUMPV addrg
191c(0626):             ' C__doprnt_132
191c(0626): 40 7c bc a0 '  mov r11, r13
1920(0627): 40 7c fc 60 '  and r11, #64 ' BANDI4 coni
1924(0628): 00 7c 7c c2 '  cmps r11,  #0 wz
1928(0629): 13 00 7c 5c '  jmp #BR_Z
192c(062a): f0 18 00 00 '  long @C__doprnt_134 ' EQI4
1930(062b): 2d 7c bc a0 '  mov r11, FP
1934(062c): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
1938(062d): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
193c(062e): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
1940(062f): 05 00 7c 5c '  jmp #LODF
1944(0630): 0c 00 00 00 '  long 12
1948(0631): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
194c(0632): 04 00 7c 5c '  jmp #LODA
1950(0633): 2c 25 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
1954(0634): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
1958(0635): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
195c(0636): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1960(0637): 3e 7e 3c 08 '  wrlong r12, r11 ' ASGNI4 reg
1964(0638): 0e 00 7c 5c '  jmp #JMPA
1968(0639): 18 22 00 00 '  long @C__doprnt_65 ' JUMPV addrg
196c(063a):             ' C__doprnt_134
196c(063a): 2d 7c bc a0 '  mov r11, FP
1970(063b): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
1974(063c): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1978(063d): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
197c(063e): 05 00 7c 5c '  jmp #LODF
1980(063f): 0c 00 00 00 '  long 12
1984(0640): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
1988(0641): 04 00 7c 5c '  jmp #LODA
198c(0642): 2c 25 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
1990(0643): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
1994(0644): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
1998(0645): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
199c(0646): 3e 7e 3c 08 '  wrlong r12, r11 ' ASGNI4 reg
19a0(0647): 0e 00 7c 5c '  jmp #JMPA
19a4(0648): 18 22 00 00 '  long @C__doprnt_65 ' JUMPV addrg
19a8(0649):             ' C__doprnt_136
19a8(0649): 2d 7c bc a0 '  mov r11, FP
19ac(064a): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
19b0(064b): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
19b4(064c): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
19b8(064d): 05 00 7c 5c '  jmp #LODF
19bc(064e): 0c 00 00 00 '  long 12
19c0(064f): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
19c4(0650): 04 00 7c 5c '  jmp #LODA
19c8(0651): 2c 25 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
19cc(0652): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
19d0(0653): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
19d4(0654): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
19d8(0655): 05 00 7c 5c '  jmp #LODF
19dc(0656): fc ff ff ff '  long -4
19e0(0657): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
19e4(0658): 2d 7c bc a0 '  mov r11, FP
19e8(0659): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
19ec(065a): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
19f0(065b): 00 7c 7c 86 '  cmp r11,  #0 wz
19f4(065c): 14 00 7c 5c '  jmp #BRNZ
19f8(065d): 94 19 00 00 '  long @C__doprnt_137 ' NEU4
19fc(065e): 04 00 7c 5c '  jmp #LODA
1a00(065f): 10 25 00 00 '  long @C__doprnt_139_L000140
1a04(0660): 2d 5e bc a0 '  mov BC, FP
1a08(0661): 04 5e fc 84 '  sub BC, #-(-4)
1a0c(0662): 2f 5c 3c 08 '  wrlong RI, BC ' ASGNP4 addrli addrg
1a10(0663):             ' C__doprnt_137
1a10(0663): 2d 7c bc a0 '  mov r11, FP
1a14(0664): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
1a18(0665): 3e 84 bc 08 '  rdlong r15, r11 ' reg <- INDIRP4 reg
1a1c(0666): 0e 00 7c 5c '  jmp #JMPA
1a20(0667): e4 19 00 00 '  long @C__doprnt_142 ' JUMPV addrg
1a24(0668):             ' C__doprnt_141
1a24(0668): 42 7c bc 00 '  rdbyte r11, r15 ' reg <- INDIRU1 reg
1a28(0669): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
1a2c(066a): 00 7c 7c c2 '  cmps r11,  #0 wz
1a30(066b): 14 00 7c 5c '  jmp #BRNZ
1a34(066c): c4 19 00 00 '  long @C__doprnt_144 ' NEI4
1a38(066d): 0e 00 7c 5c '  jmp #JMPA
1a3c(066e): 3c 1c 00 00 '  long @C__doprnt_124 ' JUMPV addrg
1a40(066f):             ' C__doprnt_144
1a40(066f): 01 84 fc d0 '  adds r15, #1 ' ADDP4 coni
1a44(0670): 2d 7c bc a0 '  mov r11, FP
1a48(0671): 18 7c fc 84 '  sub r11, #-(-24) ' reg <- addrli
1a4c(0672): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1a50(0673): 01 7c fc d4 '  subs r11, #1 ' SUBI4 coni
1a54(0674): 05 00 7c 5c '  jmp #LODF
1a58(0675): e8 ff ff ff '  long -24
1a5c(0676): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1a60(0677):             ' C__doprnt_142
1a60(0677): 00 7c fc a0 '  mov r11, #0 ' reg <- coni
1a64(0678): 2d 7a bc a0 '  mov r10, FP
1a68(0679): 18 7a fc 84 '  sub r10, #-(-24) ' reg <- addrli
1a6c(067a): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRI4 reg
1a70(067b): 3e 7a 3c c2 '  cmps r10, r11 wz
1a74(067c): 14 00 7c 5c '  jmp #BRNZ
1a78(067d): a8 19 00 00 '  long @C__doprnt_141 ' NEI4
1a7c(067e): 04 00 7c 5c '  jmp #LODA
1a80(067f): 20 25 00 00 '  long @C__doprnt_L000098
1a84(0680): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
1a88(0681): 40 7a bc 60 '  and r10, r13 ' BANDI/U (2)
1a8c(0682): 3e 7a 3c c2 '  cmps r10, r11 wz
1a90(0683): 13 00 7c 5c '  jmp #BR_Z
1a94(0684): a8 19 00 00 '  long @C__doprnt_141 ' EQI4
1a98(0685): 0e 00 7c 5c '  jmp #JMPA
1a9c(0686): 3c 1c 00 00 '  long @C__doprnt_124 ' JUMPV addrg
1aa0(0687):             ' C__doprnt_146
1aa0(0687):             ' C__doprnt_147
1aa0(0687): 04 00 7c 5c '  jmp #LODA
1aa4(0688): 20 25 00 00 '  long @C__doprnt_L000098
1aa8(0689): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1aac(068a): 40 7c bc 60 '  and r11, r13 ' BANDI/U (2)
1ab0(068b): 00 7c 7c c2 '  cmps r11,  #0 wz
1ab4(068c): 14 00 7c 5c '  jmp #BRNZ
1ab8(068d): 58 1a 00 00 '  long @C__doprnt_148 ' NEI4
1abc(068e): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
1ac0(068f): 05 00 7c 5c '  jmp #LODF
1ac4(0690): e8 ff ff ff '  long -24
1ac8(0691): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1acc(0692): 0e 00 7c 5c '  jmp #JMPA
1ad0(0693): 80 1a 00 00 '  long @C__doprnt_149 ' JUMPV addrg
1ad4(0694):             ' C__doprnt_148
1ad4(0694): 2d 7c bc a0 '  mov r11, FP
1ad8(0695): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
1adc(0696): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1ae0(0697): 70 7c 7c c2 '  cmps r11,  #112 wz
1ae4(0698): 13 00 7c 5c '  jmp #BR_Z
1ae8(0699): 80 1a 00 00 '  long @C__doprnt_150 ' EQI4
1aec(069a): 04 00 7c 5c '  jmp #LODA
1af0(069b): 18 25 00 00 '  long @C__doprnt_L000112
1af4(069c): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1af8(069d): 3e 80 bc 60 '  and r13, r11 ' BANDI/U (1)
1afc(069e):             ' C__doprnt_150
1afc(069e):             ' C__doprnt_149
1afc(069e): 00 6a fc a0 '  mov r2, #0 ' reg ARG coni
1b00(069f): 2d 5c bc a0 '  mov RI, FP
1b04(06a0): 18 5c fc 84 '  sub RI, #-(-24)
1b08(06a1): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRLi
1b0c(06a2): 2d 7c bc a0 '  mov r11, FP
1b10(06a3): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
1b14(06a4): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1b18(06a5): 3e 6e bc a0 '  mov r4, r11 ' CVUI
1b1c(06a6): 4d 6e bc 60 '  and r4, cviu_m1 ' zero extend
1b20(06a7): 42 70 bc a0 '  mov r5, r15 ' CVI, CVU or LOAD
1b24(06a8): 10 58 fc 84 '  sub SP, #16 ' stack space for reg ARGs
1b28(06a9): 40 5c bc a0 '  mov RI, r13
1b2c(06aa): 06 00 7c 5c '  jmp #PSHL ' stack ARG
1b30(06ab): 2d 5c bc a0 '  mov RI, FP
1b34(06ac): 0c 5c fc 80 '  add RI, #12
1b38(06ad): 06 00 7c 5c '  jmp #PSHL ' stack ARG ADDRFi
1b3c(06ae): 18 5e fc a0 '  mov BC, #24 ' arg size
1b40(06af): 0b 00 7c 5c '  jmp #CALA
1b44(06b0): c8 0c 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012
1b48(06b1): 18 58 fc 80 '  add SP, #24 ' CALL addrg
1b4c(06b2): 33 84 bc a0 '  mov r15, r0 ' CVI, CVU or LOAD
1b50(06b3): 0e 00 7c 5c '  jmp #JMPA
1b54(06b4): 3c 1c 00 00 '  long @C__doprnt_124 ' JUMPV addrg
1b58(06b5):             ' C__doprnt_152
1b58(06b5): 04 00 7c 5c '  jmp #LODA
1b5c(06b6): 0c 25 00 00 '  long @C__doprnt_L000153
1b60(06b7): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1b64(06b8): 3e 80 bc 68 '  or r13, r11 ' BORI/U (1)
1b68(06b9): 04 00 7c 5c '  jmp #LODA
1b6c(06ba): 20 25 00 00 '  long @C__doprnt_L000098
1b70(06bb): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1b74(06bc): 40 7c bc 60 '  and r11, r13 ' BANDI/U (2)
1b78(06bd): 00 7c 7c c2 '  cmps r11,  #0 wz
1b7c(06be): 14 00 7c 5c '  jmp #BRNZ
1b80(06bf): 20 1b 00 00 '  long @C__doprnt_156 ' NEI4
1b84(06c0): 01 7c fc a0 '  mov r11, #1 ' reg <- coni
1b88(06c1): 05 00 7c 5c '  jmp #LODF
1b8c(06c2): e8 ff ff ff '  long -24
1b90(06c3): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1b94(06c4): 0e 00 7c 5c '  jmp #JMPA
1b98(06c5): 30 1b 00 00 '  long @C__doprnt_157 ' JUMPV addrg
1b9c(06c6):             ' C__doprnt_156
1b9c(06c6): 04 00 7c 5c '  jmp #LODA
1ba0(06c7): 18 25 00 00 '  long @C__doprnt_L000112
1ba4(06c8): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1ba8(06c9): 3e 80 bc 60 '  and r13, r11 ' BANDI/U (1)
1bac(06ca):             ' C__doprnt_157
1bac(06ca): 01 6a fc a0 '  mov r2, #1 ' reg ARG coni
1bb0(06cb): 2d 5c bc a0 '  mov RI, FP
1bb4(06cc): 18 5c fc 84 '  sub RI, #-(-24)
1bb8(06cd): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRLi
1bbc(06ce): 2d 7c bc a0 '  mov r11, FP
1bc0(06cf): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
1bc4(06d0): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1bc8(06d1): 3e 6e bc a0 '  mov r4, r11 ' CVUI
1bcc(06d2): 4d 6e bc 60 '  and r4, cviu_m1 ' zero extend
1bd0(06d3): 42 70 bc a0 '  mov r5, r15 ' CVI, CVU or LOAD
1bd4(06d4): 10 58 fc 84 '  sub SP, #16 ' stack space for reg ARGs
1bd8(06d5): 40 5c bc a0 '  mov RI, r13
1bdc(06d6): 06 00 7c 5c '  jmp #PSHL ' stack ARG
1be0(06d7): 2d 5c bc a0 '  mov RI, FP
1be4(06d8): 0c 5c fc 80 '  add RI, #12
1be8(06d9): 06 00 7c 5c '  jmp #PSHL ' stack ARG ADDRFi
1bec(06da): 18 5e fc a0 '  mov BC, #24 ' arg size
1bf0(06db): 0b 00 7c 5c '  jmp #CALA
1bf4(06dc): c8 0c 00 00 '  long @C_tmpfilehCn8zT_4c2c6c11_o_print_L000012
1bf8(06dd): 18 58 fc 80 '  add SP, #24 ' CALL addrg
1bfc(06de): 33 84 bc a0 '  mov r15, r0 ' CVI, CVU or LOAD
1c00(06df): 0e 00 7c 5c '  jmp #JMPA
1c04(06e0): 3c 1c 00 00 '  long @C__doprnt_124 ' JUMPV addrg
1c08(06e1):             ' C__doprnt_158
1c08(06e1): 42 7c bc a0 '  mov r11, r15 ' CVI, CVU or LOAD
1c0c(06e2): 3e 84 bc a0 '  mov r15, r11
1c10(06e3): 01 84 fc d0 '  adds r15, #1 ' ADDP4 coni
1c14(06e4): 2d 7a bc a0 '  mov r10, FP
1c18(06e5): 0c 7a fc 80 '  add r10, #12 ' reg <- addrfi
1c1c(06e6): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRP4 reg
1c20(06e7): 04 7a fc d0 '  adds r10, #4 ' ADDP4 coni
1c24(06e8): 05 00 7c 5c '  jmp #LODF
1c28(06e9): 0c 00 00 00 '  long 12
1c2c(06ea): 2e 7a 3c 08 '  wrlong r10, RI ' ASGNP4 addrl
1c30(06eb): 04 00 7c 5c '  jmp #LODA
1c34(06ec): 2c 25 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
1c38(06ed): 2e 78 bc 08 '  rdlong  r9, RI ' reg <- con
1c3c(06ee): 3c 7a bc d0 '  adds r10, r9 ' ADDI/P (1)
1c40(06ef): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRI4 reg
1c44(06f0): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
1c48(06f1): 0e 00 7c 5c '  jmp #JMPA
1c4c(06f2): 3c 1c 00 00 '  long @C__doprnt_124 ' JUMPV addrg
1c50(06f3):             ' C__doprnt_159
1c50(06f3): 2d 7c bc a0 '  mov r11, FP
1c54(06f4): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
1c58(06f5): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1c5c(06f6): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
1c60(06f7): 05 00 7c 5c '  jmp #LODF
1c64(06f8): 0c 00 00 00 '  long 12
1c68(06f9): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
1c6c(06fa): 04 00 7c 5c '  jmp #LODA
1c70(06fb): 2c 25 00 00 '  long @C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005
1c74(06fc): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
1c78(06fd): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
1c7c(06fe): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1c80(06ff): 05 00 7c 5c '  jmp #LODF
1c84(0700): 0c 00 00 00 '  long 12
1c88(0701): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
1c8c(0702): 2d 7c bc a0 '  mov r11, FP
1c90(0703): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
1c94(0704): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1c98(0705): 04 7c fc d0 '  adds r11, #4 ' ADDP4 coni
1c9c(0706): 05 00 7c 5c '  jmp #LODF
1ca0(0707): 0c 00 00 00 '  long 12
1ca4(0708): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
1ca8(0709): 3d 7c bc d0 '  adds r11, r10 ' ADDI/P (1)
1cac(070a): 3e 88 bc 08 '  rdlong r17, r11 ' reg <- INDIRP4 reg
1cb0(070b): 0e 00 7c 5c '  jmp #JMPA
1cb4(070c): 18 22 00 00 '  long @C__doprnt_65 ' JUMPV addrg
1cb8(070d):             ' C__doprnt_124
1cb8(070d): 20 7c fc a0 '  mov r11, #32 ' reg <- coni
1cbc(070e): 05 00 7c 5c '  jmp #LODF
1cc0(070f): f4 ff ff ff '  long -12
1cc4(0710): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1cc8(0711): 40 7c bc a0 '  mov r11, r13
1ccc(0712): 10 7c fc 60 '  and r11, #16 ' BANDI4 coni
1cd0(0713): 00 7c 7c c2 '  cmps r11,  #0 wz
1cd4(0714): 13 00 7c 5c '  jmp #BR_Z
1cd8(0715): 70 1c 00 00 '  long @C__doprnt_166 ' EQI4
1cdc(0716): 30 7c fc a0 '  mov r11, #48 ' reg <- coni
1ce0(0717): 05 00 7c 5c '  jmp #LODF
1ce4(0718): f4 ff ff ff '  long -12
1ce8(0719): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1cec(071a):             ' C__doprnt_166
1cec(071a): 42 7c bc a0 '  mov r11, r15 ' CVI, CVU or LOAD
1cf0(071b): 2d 7a bc a0 '  mov r10, FP
1cf4(071c): 04 7a fc 84 '  sub r10, #-(-4) ' reg <- addrli
1cf8(071d): 3d 7a bc 08 '  rdlong r10, r10 ' reg <- INDIRP4 reg
1cfc(071e): 3d 7c bc 84 '  sub r11, r10 ' SUBU (1)
1d00(071f): 3e 82 bc a0 '  mov r14, r11 ' CVI, CVU or LOAD
1d04(0720): 00 7c fc a0 '  mov r11, #0 ' reg <- coni
1d08(0721): 05 00 7c 5c '  jmp #LODF
1d0c(0722): e0 ff ff ff '  long -32
1d10(0723): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1d14(0724): 40 7c bc a0 '  mov r11, r13
1d18(0725): 10 7c fc 60 '  and r11, #16 ' BANDI4 coni
1d1c(0726): 00 7c 7c c2 '  cmps r11,  #0 wz
1d20(0727): 13 00 7c 5c '  jmp #BR_Z
1d24(0728): 6c 1d 00 00 '  long @C__doprnt_168 ' EQI4
1d28(0729): 2d 7c bc a0 '  mov r11, FP
1d2c(072a): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
1d30(072b): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1d34(072c): 78 7c 7c c2 '  cmps r11,  #120 wz
1d38(072d): 13 00 7c 5c '  jmp #BR_Z
1d3c(072e): d0 1c 00 00 '  long @C__doprnt_172 ' EQI4
1d40(072f): 58 7c 7c c2 '  cmps r11,  #88 wz
1d44(0730): 14 00 7c 5c '  jmp #BRNZ
1d48(0731): e4 1c 00 00 '  long @C__doprnt_171 ' NEI4
1d4c(0732):             ' C__doprnt_172
1d4c(0732): 40 7c bc a0 '  mov r11, r13
1d50(0733): 08 7c fc 60 '  and r11, #8 ' BANDI4 coni
1d54(0734): 00 7c 7c c2 '  cmps r11,  #0 wz
1d58(0735): 14 00 7c 5c '  jmp #BRNZ
1d5c(0736): 50 1d 00 00 '  long @C__doprnt_175 ' NEI4
1d60(0737):             ' C__doprnt_171
1d60(0737): 2d 7c bc a0 '  mov r11, FP
1d64(0738): 10 7c fc 84 '  sub r11, #-(-16) ' reg <- addrli
1d68(0739): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1d6c(073a): 70 7c 7c c2 '  cmps r11,  #112 wz
1d70(073b): 13 00 7c 5c '  jmp #BR_Z
1d74(073c): 50 1d 00 00 '  long @C__doprnt_175 ' EQI4
1d78(073d): 04 00 7c 5c '  jmp #LODA
1d7c(073e): 0c 25 00 00 '  long @C__doprnt_L000153
1d80(073f): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1d84(0740): 40 7c bc 60 '  and r11, r13 ' BANDI/U (2)
1d88(0741): 00 7c 7c c2 '  cmps r11,  #0 wz
1d8c(0742): 13 00 7c 5c '  jmp #BR_Z
1d90(0743): 6c 1d 00 00 '  long @C__doprnt_168 ' EQI4
1d94(0744): 2d 7c bc a0 '  mov r11, FP
1d98(0745): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
1d9c(0746): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1da0(0747): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
1da4(0748): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
1da8(0749): 2b 7c 7c c2 '  cmps r11,  #43 wz
1dac(074a): 13 00 7c 5c '  jmp #BR_Z
1db0(074b): 50 1d 00 00 '  long @C__doprnt_175 ' EQI4
1db4(074c): 2d 7c 7c c2 '  cmps r11,  #45 wz
1db8(074d): 13 00 7c 5c '  jmp #BR_Z
1dbc(074e): 50 1d 00 00 '  long @C__doprnt_175 ' EQI4
1dc0(074f): 20 7c 7c c2 '  cmps r11,  #32 wz
1dc4(0750): 14 00 7c 5c '  jmp #BRNZ
1dc8(0751): 6c 1d 00 00 '  long @C__doprnt_168 ' NEI4
1dcc(0752):             ' C__doprnt_175
1dcc(0752): 2d 7c bc a0 '  mov r11, FP
1dd0(0753): 20 7c fc 84 '  sub r11, #-(-32) ' reg <- addrli
1dd4(0754): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1dd8(0755): 01 7c fc d0 '  adds r11, #1 ' ADDI4 coni
1ddc(0756): 05 00 7c 5c '  jmp #LODF
1de0(0757): e0 ff ff ff '  long -32
1de4(0758): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1de8(0759):             ' C__doprnt_168
1de8(0759): 2d 7c bc a0 '  mov r11, FP
1dec(075a): 14 7c fc 84 '  sub r11, #-(-20) ' reg <- addrli
1df0(075b): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1df4(075c): 41 7c bc d4 '  subs r11, r14 ' SUBI/P (1)
1df8(075d): 05 00 7c 5c '  jmp #LODF
1dfc(075e): f8 ff ff ff '  long -8
1e00(075f): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1e04(0760): 00 7c 7c c3 '  cmps r11,  #0 wz,wc
1e08(0761): 17 00 7c 5c '  jmp #BRBE
1e0c(0762): 64 20 00 00 '  long @C__doprnt_176 ' LEI4
1e10(0763): 40 7c bc a0 '  mov r11, r13
1e14(0764): 01 7c fc 60 '  and r11, #1 ' BANDI4 coni
1e18(0765): 00 7c 7c c2 '  cmps r11,  #0 wz
1e1c(0766): 14 00 7c 5c '  jmp #BRNZ
1e20(0767): 64 20 00 00 '  long @C__doprnt_178 ' NEI4
1e24(0768): 2d 7c bc a0 '  mov r11, FP
1e28(0769): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
1e2c(076a): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1e30(076b): 3e 7e bc d0 '  adds r12, r11 ' ADDI/P (1)
1e34(076c): 2d 7c bc a0 '  mov r11, FP
1e38(076d): 20 7c fc 84 '  sub r11, #-(-32) ' reg <- addrli
1e3c(076e): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
1e40(076f): 00 7c 7c c2 '  cmps r11,  #0 wz
1e44(0770): 13 00 7c 5c '  jmp #BR_Z
1e48(0771): b0 1f 00 00 '  long @C__doprnt_180 ' EQI4
1e4c(0772): 04 00 7c 5c '  jmp #LODA
1e50(0773): 0c 25 00 00 '  long @C__doprnt_L000153
1e54(0774): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1e58(0775): 40 7c bc 60 '  and r11, r13 ' BANDI/U (2)
1e5c(0776): 00 7c 7c c2 '  cmps r11,  #0 wz
1e60(0777): 13 00 7c 5c '  jmp #BR_Z
1e64(0778): a0 1e 00 00 '  long @C__doprnt_182 ' EQI4
1e68(0779): 01 82 fc d4 '  subs r14, #1 ' SUBI4 coni
1e6c(077a): 01 7e fc d0 '  adds r12, #1 ' ADDI4 coni
1e70(077b): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
1e74(077c): 2d 7c bc a0 '  mov r11, FP
1e78(077d): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
1e7c(077e): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1e80(077f): 3e 7a bc a0 '  mov r10, r11
1e84(0780): 01 7a fc d0 '  adds r10, #1 ' ADDP4 coni
1e88(0781): 05 00 7c 5c '  jmp #LODF
1e8c(0782): fc ff ff ff '  long -4
1e90(0783): 2e 7a 3c 08 '  wrlong r10, RI ' ASGNP4 addrl
1e94(0784): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
1e98(0785): 3e 6c bc a0 '  mov r3, r11 ' CVUI
1e9c(0786): 4d 6c bc 60 '  and r3, cviu_m1 ' zero extend
1ea0(0787): 08 5e fc a0 '  mov BC, #8 ' arg size
1ea4(0788): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
1ea8(0789): 0b 00 7c 5c '  jmp #CALA
1eac(078a): 00 24 00 00 '  long @C_putc
1eb0(078b): 08 58 fc 80 '  add SP, #8 ' CALL addrg
1eb4(078c): 04 00 7c 5c '  jmp #LODA
1eb8(078d): 28 25 00 00 '  long @C__doprnt_L000071
1ebc(078e): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
1ec0(078f): 3d 66 3c c2 '  cmps r0, r10 wz
1ec4(0790): 14 00 7c 5c '  jmp #BRNZ
1ec8(0791): b0 1f 00 00 '  long @C__doprnt_183 ' NEI4
1ecc(0792): 00 7e 7c c2 '  cmps r12,  #0 wz
1ed0(0793): 13 00 7c 5c '  jmp #BR_Z
1ed4(0794): 74 1e 00 00 '  long @C__doprnt_187 ' EQI4
1ed8(0795): 3f 7c bc a4 '  neg r11, r12 ' NEGI4
1edc(0796): 05 00 7c 5c '  jmp #LODF
1ee0(0797): d0 fb ff ff '  long -1072
1ee4(0798): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1ee8(0799): 0e 00 7c 5c '  jmp #JMPA
1eec(079a): 8c 1e 00 00 '  long @C__doprnt_188 ' JUMPV addrg
1ef0(079b):             ' C__doprnt_187
1ef0(079b): 04 00 7c 5c '  jmp #LODA
1ef4(079c): 28 25 00 00 '  long @C__doprnt_L000071
1ef8(079d): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
1efc(079e): 05 00 7c 5c '  jmp #LODF
1f00(079f): d0 fb ff ff '  long -1072
1f04(07a0): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1f08(07a1):             ' C__doprnt_188
1f08(07a1): 05 00 7c 5c '  jmp #LODF
1f0c(07a2): d0 fb ff ff '  long -1072
1f10(07a3): 2e 66 bc 08 '  rdlong r0, RI ' reg <- INDIRI4 addrl
1f14(07a4): 0e 00 7c 5c '  jmp #JMPA
1f18(07a5): 48 22 00 00 '  long @C__doprnt_63 ' JUMPV addrg
1f1c(07a6):             ' C__doprnt_182
1f1c(07a6): 02 82 fc d4 '  subs r14, #2 ' SUBI4 coni
1f20(07a7): 02 7e fc d0 '  adds r12, #2 ' ADDI4 coni
1f24(07a8): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
1f28(07a9): 2d 7c bc a0 '  mov r11, FP
1f2c(07aa): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
1f30(07ab): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1f34(07ac): 3e 7a bc a0 '  mov r10, r11
1f38(07ad): 01 7a fc d0 '  adds r10, #1 ' ADDP4 coni
1f3c(07ae): 05 00 7c 5c '  jmp #LODF
1f40(07af): fc ff ff ff '  long -4
1f44(07b0): 2e 7a 3c 08 '  wrlong r10, RI ' ASGNP4 addrl
1f48(07b1): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
1f4c(07b2): 3e 6c bc a0 '  mov r3, r11 ' CVUI
1f50(07b3): 4d 6c bc 60 '  and r3, cviu_m1 ' zero extend
1f54(07b4): 08 5e fc a0 '  mov BC, #8 ' arg size
1f58(07b5): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
1f5c(07b6): 0b 00 7c 5c '  jmp #CALA
1f60(07b7): 00 24 00 00 '  long @C_putc
1f64(07b8): 08 58 fc 80 '  add SP, #8 ' CALL addrg
1f68(07b9): 04 00 7c 5c '  jmp #LODA
1f6c(07ba): 28 25 00 00 '  long @C__doprnt_L000071
1f70(07bb): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
1f74(07bc): 3d 66 3c c2 '  cmps r0, r10 wz
1f78(07bd): 13 00 7c 5c '  jmp #BR_Z
1f7c(07be): 60 1f 00 00 '  long @C__doprnt_191 ' EQI4
1f80(07bf): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
1f84(07c0): 2d 7c bc a0 '  mov r11, FP
1f88(07c1): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
1f8c(07c2): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
1f90(07c3): 3e 7a bc a0 '  mov r10, r11
1f94(07c4): 01 7a fc d0 '  adds r10, #1 ' ADDP4 coni
1f98(07c5): 05 00 7c 5c '  jmp #LODF
1f9c(07c6): fc ff ff ff '  long -4
1fa0(07c7): 2e 7a 3c 08 '  wrlong r10, RI ' ASGNP4 addrl
1fa4(07c8): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
1fa8(07c9): 3e 6c bc a0 '  mov r3, r11 ' CVUI
1fac(07ca): 4d 6c bc 60 '  and r3, cviu_m1 ' zero extend
1fb0(07cb): 08 5e fc a0 '  mov BC, #8 ' arg size
1fb4(07cc): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
1fb8(07cd): 0b 00 7c 5c '  jmp #CALA
1fbc(07ce): 00 24 00 00 '  long @C_putc
1fc0(07cf): 08 58 fc 80 '  add SP, #8 ' CALL addrg
1fc4(07d0): 04 00 7c 5c '  jmp #LODA
1fc8(07d1): 28 25 00 00 '  long @C__doprnt_L000071
1fcc(07d2): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
1fd0(07d3): 3d 66 3c c2 '  cmps r0, r10 wz
1fd4(07d4): 14 00 7c 5c '  jmp #BRNZ
1fd8(07d5): b0 1f 00 00 '  long @C__doprnt_189 ' NEI4
1fdc(07d6):             ' C__doprnt_191
1fdc(07d6): 00 7e 7c c2 '  cmps r12,  #0 wz
1fe0(07d7): 13 00 7c 5c '  jmp #BR_Z
1fe4(07d8): 84 1f 00 00 '  long @C__doprnt_193 ' EQI4
1fe8(07d9): 3f 7c bc a4 '  neg r11, r12 ' NEGI4
1fec(07da): 05 00 7c 5c '  jmp #LODF
1ff0(07db): d0 fb ff ff '  long -1072
1ff4(07dc): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
1ff8(07dd): 0e 00 7c 5c '  jmp #JMPA
1ffc(07de): 9c 1f 00 00 '  long @C__doprnt_194 ' JUMPV addrg
2000(07df):             ' C__doprnt_193
2000(07df): 04 00 7c 5c '  jmp #LODA
2004(07e0): 28 25 00 00 '  long @C__doprnt_L000071
2008(07e1): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
200c(07e2): 05 00 7c 5c '  jmp #LODF
2010(07e3): d0 fb ff ff '  long -1072
2014(07e4): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2018(07e5):             ' C__doprnt_194
2018(07e5): 05 00 7c 5c '  jmp #LODF
201c(07e6): d0 fb ff ff '  long -1072
2020(07e7): 2e 66 bc 08 '  rdlong r0, RI ' reg <- INDIRI4 addrl
2024(07e8): 0e 00 7c 5c '  jmp #JMPA
2028(07e9): 48 22 00 00 '  long @C__doprnt_63 ' JUMPV addrg
202c(07ea):             ' C__doprnt_189
202c(07ea):             ' C__doprnt_183
202c(07ea):             ' C__doprnt_180
202c(07ea):             ' C__doprnt_195
202c(07ea): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
2030(07eb): 2d 5c bc a0 '  mov RI, FP
2034(07ec): 0c 5c fc 84 '  sub RI, #-(-12)
2038(07ed): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRLi
203c(07ee): 08 5e fc a0 '  mov BC, #8 ' arg size
2040(07ef): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
2044(07f0): 0b 00 7c 5c '  jmp #CALA
2048(07f1): 00 24 00 00 '  long @C_putc
204c(07f2): 08 58 fc 80 '  add SP, #8 ' CALL addrg
2050(07f3): 04 00 7c 5c '  jmp #LODA
2054(07f4): 28 25 00 00 '  long @C__doprnt_L000071
2058(07f5): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
205c(07f6): 3d 66 3c c2 '  cmps r0, r10 wz
2060(07f7): 14 00 7c 5c '  jmp #BRNZ
2064(07f8): 3c 20 00 00 '  long @C__doprnt_198 ' NEI4
2068(07f9): 00 7e 7c c2 '  cmps r12,  #0 wz
206c(07fa): 13 00 7c 5c '  jmp #BR_Z
2070(07fb): 10 20 00 00 '  long @C__doprnt_201 ' EQI4
2074(07fc): 3f 7c bc a4 '  neg r11, r12 ' NEGI4
2078(07fd): 05 00 7c 5c '  jmp #LODF
207c(07fe): d0 fb ff ff '  long -1072
2080(07ff): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2084(0800): 0e 00 7c 5c '  jmp #JMPA
2088(0801): 28 20 00 00 '  long @C__doprnt_202 ' JUMPV addrg
208c(0802):             ' C__doprnt_201
208c(0802): 04 00 7c 5c '  jmp #LODA
2090(0803): 28 25 00 00 '  long @C__doprnt_L000071
2094(0804): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
2098(0805): 05 00 7c 5c '  jmp #LODF
209c(0806): d0 fb ff ff '  long -1072
20a0(0807): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
20a4(0808):             ' C__doprnt_202
20a4(0808): 05 00 7c 5c '  jmp #LODF
20a8(0809): d0 fb ff ff '  long -1072
20ac(080a): 2e 66 bc 08 '  rdlong r0, RI ' reg <- INDIRI4 addrl
20b0(080b): 0e 00 7c 5c '  jmp #JMPA
20b4(080c): 48 22 00 00 '  long @C__doprnt_63 ' JUMPV addrg
20b8(080d):             ' C__doprnt_198
20b8(080d): 2d 7c bc a0 '  mov r11, FP
20bc(080e): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
20c0(080f): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
20c4(0810): 01 7c fc d4 '  subs r11, #1 ' SUBI4 coni
20c8(0811): 05 00 7c 5c '  jmp #LODF
20cc(0812): f8 ff ff ff '  long -8
20d0(0813): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
20d4(0814): 00 7c 7c c2 '  cmps r11,  #0 wz
20d8(0815): 14 00 7c 5c '  jmp #BRNZ
20dc(0816): b0 1f 00 00 '  long @C__doprnt_195 ' NEI4
20e0(0817):             ' C__doprnt_178
20e0(0817):             ' C__doprnt_176
20e0(0817): 41 7e bc d0 '  adds r12, r14 ' ADDI/P (1)
20e4(0818): 0e 00 7c 5c '  jmp #JMPA
20e8(0819): 1c 21 00 00 '  long @C__doprnt_204 ' JUMPV addrg
20ec(081a):             ' C__doprnt_203
20ec(081a): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
20f0(081b): 2d 7c bc a0 '  mov r11, FP
20f4(081c): 04 7c fc 84 '  sub r11, #-(-4) ' reg <- addrli
20f8(081d): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRP4 reg
20fc(081e): 3e 7a bc a0 '  mov r10, r11
2100(081f): 01 7a fc d0 '  adds r10, #1 ' ADDP4 coni
2104(0820): 05 00 7c 5c '  jmp #LODF
2108(0821): fc ff ff ff '  long -4
210c(0822): 2e 7a 3c 08 '  wrlong r10, RI ' ASGNP4 addrl
2110(0823): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
2114(0824): 3e 6c bc a0 '  mov r3, r11 ' CVUI
2118(0825): 4d 6c bc 60 '  and r3, cviu_m1 ' zero extend
211c(0826): 08 5e fc a0 '  mov BC, #8 ' arg size
2120(0827): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
2124(0828): 0b 00 7c 5c '  jmp #CALA
2128(0829): 00 24 00 00 '  long @C_putc
212c(082a): 08 58 fc 80 '  add SP, #8 ' CALL addrg
2130(082b): 04 00 7c 5c '  jmp #LODA
2134(082c): 28 25 00 00 '  long @C__doprnt_L000071
2138(082d): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
213c(082e): 3d 66 3c c2 '  cmps r0, r10 wz
2140(082f): 14 00 7c 5c '  jmp #BRNZ
2144(0830): 1c 21 00 00 '  long @C__doprnt_206 ' NEI4
2148(0831): 00 7e 7c c2 '  cmps r12,  #0 wz
214c(0832): 13 00 7c 5c '  jmp #BR_Z
2150(0833): f0 20 00 00 '  long @C__doprnt_209 ' EQI4
2154(0834): 3f 7c bc a4 '  neg r11, r12 ' NEGI4
2158(0835): 05 00 7c 5c '  jmp #LODF
215c(0836): d0 fb ff ff '  long -1072
2160(0837): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2164(0838): 0e 00 7c 5c '  jmp #JMPA
2168(0839): 08 21 00 00 '  long @C__doprnt_210 ' JUMPV addrg
216c(083a):             ' C__doprnt_209
216c(083a): 04 00 7c 5c '  jmp #LODA
2170(083b): 28 25 00 00 '  long @C__doprnt_L000071
2174(083c): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
2178(083d): 05 00 7c 5c '  jmp #LODF
217c(083e): d0 fb ff ff '  long -1072
2180(083f): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2184(0840):             ' C__doprnt_210
2184(0840): 05 00 7c 5c '  jmp #LODF
2188(0841): d0 fb ff ff '  long -1072
218c(0842): 2e 66 bc 08 '  rdlong r0, RI ' reg <- INDIRI4 addrl
2190(0843): 0e 00 7c 5c '  jmp #JMPA
2194(0844): 48 22 00 00 '  long @C__doprnt_63 ' JUMPV addrg
2198(0845):             ' C__doprnt_206
2198(0845):             ' C__doprnt_204
2198(0845): 41 7c bc a0 '  mov r11, r14
219c(0846): 01 7c fc d4 '  subs r11, #1 ' SUBI4 coni
21a0(0847): 3e 82 bc a0 '  mov r14, r11 ' CVI, CVU or LOAD
21a4(0848): 00 7c 7c c3 '  cmps r11,  #0 wz,wc
21a8(0849): 15 00 7c 5c '  jmp #BRAE
21ac(084a): 70 20 00 00 '  long @C__doprnt_203 ' GEI4
21b0(084b): 2d 7c bc a0 '  mov r11, FP
21b4(084c): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
21b8(084d): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
21bc(084e): 00 7c 7c c3 '  cmps r11,  #0 wz,wc
21c0(084f): 17 00 7c 5c '  jmp #BRBE
21c4(0850): f0 21 00 00 '  long @C__doprnt_214 ' LEI4
21c8(0851): 2d 7c bc a0 '  mov r11, FP
21cc(0852): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
21d0(0853): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
21d4(0854): 3e 7e bc d0 '  adds r12, r11 ' ADDI/P (1)
21d8(0855): 0e 00 7c 5c '  jmp #JMPA
21dc(0856): f0 21 00 00 '  long @C__doprnt_214 ' JUMPV addrg
21e0(0857):             ' C__doprnt_213
21e0(0857): 43 6a bc a0 '  mov r2, r16 ' CVI, CVU or LOAD
21e4(0858): 2d 5c bc a0 '  mov RI, FP
21e8(0859): 0c 5c fc 84 '  sub RI, #-(-12)
21ec(085a): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRLi
21f0(085b): 08 5e fc a0 '  mov BC, #8 ' arg size
21f4(085c): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
21f8(085d): 0b 00 7c 5c '  jmp #CALA
21fc(085e): 00 24 00 00 '  long @C_putc
2200(085f): 08 58 fc 80 '  add SP, #8 ' CALL addrg
2204(0860): 04 00 7c 5c '  jmp #LODA
2208(0861): 28 25 00 00 '  long @C__doprnt_L000071
220c(0862): 2e 7a bc 08 '  rdlong  r10, RI ' reg <- con
2210(0863): 3d 66 3c c2 '  cmps r0, r10 wz
2214(0864): 14 00 7c 5c '  jmp #BRNZ
2218(0865): f0 21 00 00 '  long @C__doprnt_216 ' NEI4
221c(0866): 00 7e 7c c2 '  cmps r12,  #0 wz
2220(0867): 13 00 7c 5c '  jmp #BR_Z
2224(0868): c4 21 00 00 '  long @C__doprnt_219 ' EQI4
2228(0869): 3f 7c bc a4 '  neg r11, r12 ' NEGI4
222c(086a): 05 00 7c 5c '  jmp #LODF
2230(086b): d0 fb ff ff '  long -1072
2234(086c): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2238(086d): 0e 00 7c 5c '  jmp #JMPA
223c(086e): dc 21 00 00 '  long @C__doprnt_220 ' JUMPV addrg
2240(086f):             ' C__doprnt_219
2240(086f): 04 00 7c 5c '  jmp #LODA
2244(0870): 28 25 00 00 '  long @C__doprnt_L000071
2248(0871): 2e 7c bc 08 '  rdlong  r11, RI ' reg <- con
224c(0872): 05 00 7c 5c '  jmp #LODF
2250(0873): d0 fb ff ff '  long -1072
2254(0874): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2258(0875):             ' C__doprnt_220
2258(0875): 05 00 7c 5c '  jmp #LODF
225c(0876): d0 fb ff ff '  long -1072
2260(0877): 2e 66 bc 08 '  rdlong r0, RI ' reg <- INDIRI4 addrl
2264(0878): 0e 00 7c 5c '  jmp #JMPA
2268(0879): 48 22 00 00 '  long @C__doprnt_63 ' JUMPV addrg
226c(087a):             ' C__doprnt_216
226c(087a):             ' C__doprnt_214
226c(087a): 2d 7c bc a0 '  mov r11, FP
2270(087b): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
2274(087c): 3e 7c bc 08 '  rdlong r11, r11 ' reg <- INDIRI4 reg
2278(087d): 01 7c fc d4 '  subs r11, #1 ' SUBI4 coni
227c(087e): 05 00 7c 5c '  jmp #LODF
2280(087f): f8 ff ff ff '  long -8
2284(0880): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
2288(0881): 00 7c 7c c3 '  cmps r11,  #0 wz,wc
228c(0882): 15 00 7c 5c '  jmp #BRAE
2290(0883): 64 21 00 00 '  long @C__doprnt_213 ' GEI4
2294(0884):             ' C__doprnt_65
2294(0884): 44 7c bc a0 '  mov r11, r17 ' CVI, CVU or LOAD
2298(0885): 3e 88 bc a0 '  mov r17, r11
229c(0886): 01 88 fc d0 '  adds r17, #1 ' ADDP4 coni
22a0(0887): 3e 7c bc 00 '  rdbyte r11, r11 ' reg <- INDIRU1 reg
22a4(0888): 4d 7c bc 60 '  and r11, cviu_m1 ' zero extend
22a8(0889): 05 00 7c 5c '  jmp #LODF
22ac(088a): f0 ff ff ff '  long -16
22b0(088b): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNI4 addrl
22b4(088c): 00 7c 7c c2 '  cmps r11,  #0 wz
22b8(088d): 14 00 7c 5c '  jmp #BRNZ
22bc(088e): 0c 13 00 00 '  long @C__doprnt_64 ' NEI4
22c0(088f): 3f 66 bc a0 '  mov r0, r12 ' CVI, CVU or LOAD
22c4(0890):             ' C__doprnt_63
22c4(0890): 23 00 7c 5c '  jmp #POPM
22c8(0891): 00 fe 03 00 '  long $3fe00 ' restore registers
22cc(0892): 03 00 7c 5c '  jmp #LODL
22d0(0893): 30 04 00 00 '  long 1072
22d4(0894): 2e 58 bc 80 '  add SP, RI ' framesize
22d8(0895): 0a 00 7c 5c '  jmp #RETF
22dc(0896):             '  long ' align long
22dc(0896):             ' C__i_compute ' <symbol:_i_compute>
22dc(0896): 22 00 7c 5c '  jmp #PSHM
22e0(0897): 00 fc 03 00 '  long $3fc00 ' save registers
22e4(0898): 38 88 bc a0 '  mov r17, r5 ' reg var <- reg arg
22e8(0899): 37 86 bc a0 '  mov r16, r4 ' reg var <- reg arg
22ec(089a): 36 84 bc a0 '  mov r15, r3 ' reg var <- reg arg
22f0(089b): 35 82 bc a0 '  mov r14, r2 ' reg var <- reg arg
22f4(089c): 44 66 bc a0 '  mov r0, r17 ' setup r0/r1 (2)
22f8(089d): 43 68 bc a0 '  mov r1, r16 ' setup r0/r1 (2)
22fc(089e): 11 00 7c 5c '  jmp #DIVU ' DIVU
2300(089f): 34 80 bc a0 '  mov r13, r1 ' CVI, CVU or LOAD
2304(08a0): 44 66 bc a0 '  mov r0, r17 ' setup r0/r1 (2)
2308(08a1): 43 68 bc a0 '  mov r1, r16 ' setup r0/r1 (2)
230c(08a2): 11 00 7c 5c '  jmp #DIVU ' DIVU
2310(08a3): 33 88 bc a0 '  mov r17, r0 ' CVI, CVU or LOAD
2314(08a4): 00 88 7c 86 '  cmp r17,  #0 wz
2318(08a5): 14 00 7c 5c '  jmp #BRNZ
231c(08a6): b0 22 00 00 '  long @C__i_compute_4 ' NEU4
2320(08a7): 01 82 7c c3 '  cmps r14,  #1 wz,wc
2324(08a8): 17 00 7c 5c '  jmp #BRBE
2328(08a9): dc 22 00 00 '  long @C__i_compute_2 ' LEI4
232c(08aa):             ' C__i_compute_4
232c(08aa): 41 6a bc a0 '  mov r2, r14
2330(08ab): 01 6a fc d4 '  subs r2, #1 ' SUBI4 coni
2334(08ac): 42 6c bc a0 '  mov r3, r15 ' CVI, CVU or LOAD
2338(08ad): 43 6e bc a0 '  mov r4, r16 ' CVI, CVU or LOAD
233c(08ae): 44 70 bc a0 '  mov r5, r17 ' CVI, CVU or LOAD
2340(08af): 10 5e fc a0 '  mov BC, #16 ' arg size
2344(08b0): 10 58 fc 84 '  sub SP, #16 ' stack space for reg ARGs
2348(08b1): 0b 00 7c 5c '  jmp #CALA
234c(08b2): 60 22 00 00 '  long @C__i_compute
2350(08b3): 10 58 fc 80 '  add SP, #16 ' CALL addrg
2354(08b4): 33 84 bc a0 '  mov r15, r0 ' CVI, CVU or LOAD
2358(08b5):             ' C__i_compute_2
2358(08b5): 42 7c bc a0 '  mov r11, r15 ' CVI, CVU or LOAD
235c(08b6): 3e 84 bc a0 '  mov r15, r11
2360(08b7): 01 84 fc d0 '  adds r15, #1 ' ADDP4 coni
2364(08b8): 09 80 7c c3 '  cmps r13,  #9 wz,wc
2368(08b9): 17 00 7c 5c '  jmp #BRBE
236c(08ba): 0c 23 00 00 '  long @C__i_compute_6 ' LEI4
2370(08bb): 40 7a bc a0 '  mov r10, r13
2374(08bc): 0a 7a fc d4 '  subs r10, #10 ' SUBI4 coni
2378(08bd): 3d 7e bc a0 '  mov r12, r10
237c(08be): 61 7e fc d0 '  adds r12, #97 ' ADDI4 coni
2380(08bf): 0e 00 7c 5c '  jmp #JMPA
2384(08c0): 14 23 00 00 '  long @C__i_compute_7 ' JUMPV addrg
2388(08c1):             ' C__i_compute_6
2388(08c1): 40 7e bc a0 '  mov r12, r13
238c(08c2): 30 7e fc d0 '  adds r12, #48 ' ADDI4 coni
2390(08c3):             ' C__i_compute_7
2390(08c3): 3f 7a bc a0 '  mov r10, r12 ' CVI, CVU or LOAD
2394(08c4): 3e 7a 3c 00 '  wrbyte r10, r11 ' ASGNU1 reg
2398(08c5): 42 66 bc a0 '  mov r0, r15 ' CVI, CVU or LOAD
239c(08c6): 23 00 7c 5c '  jmp #POPM
23a0(08c7): 00 fc 03 00 '  long $3fc00 ' restore registers
23a4(08c8): 0c 00 7c 5c '  jmp #RETN
23a8(08c9):             '  long ' align long
23a8(08c9):             ' C__ina
23a8(08c9): f2 67 bc a0 '  mov r0, INA
23ac(08ca): 0c 00 7c 5c '  jmp #RETN
23b0(08cb):             '  long ' align long
23b0(08cb):             ' C__outa
23b0(08cb): f4 67 bc a0 '  mov r0, OUTA
23b4(08cc): 36 e8 bf 64 '  andn OUTA, r3
23b8(08cd): 35 e8 bf 68 '  or OUTA, r2
23bc(08ce): 0c 00 7c 5c '  jmp #RETN
23c0(08cf):             '  long ' align long
23c0(08cf):             ' C_printf ' <symbol:printf>
23c0(08cf): 09 00 7c 5c '  jmp #NEWF
23c4(08d0): 08 58 fc 84 '  sub SP, #8
23c8(08d1): 22 00 7c 5c '  jmp #PSHM
23cc(08d2): 00 08 00 00 '  long $800 ' save registers
23d0(08d3): 2d 5c bc a0 '  mov RI, FP
23d4(08d4): 08 5c fc 80 '  add RI, #8
23d8(08d5): 04 5e fc 84 '  sub BC, #4
23dc(08d6): 2e 5e 3c 87 '  cmp BC, RI wz,wc
23e0(08d7): 2f 6a 0c 08 '  if_ae wrlong r2, BC ' spill reg (varadic)
23e4(08d8): 04 5e fc 84 '  sub BC, #4
23e8(08d9): 2e 5e 3c 87 '  cmp BC, RI wz,wc
23ec(08da): 2f 6c 0c 08 '  if_ae wrlong r3, BC ' spill reg (varadic)
23f0(08db): 04 5e fc 84 '  sub BC, #4
23f4(08dc): 2e 5e 3c 87 '  cmp BC, RI wz,wc
23f8(08dd): 2f 6e 0c 08 '  if_ae wrlong r4, BC ' spill reg (varadic)
23fc(08de): 04 5e fc 84 '  sub BC, #4
2400(08df): 2e 5e 3c 87 '  cmp BC, RI wz,wc
2404(08e0): 2f 70 0c 08 '  if_ae wrlong r5, BC ' spill reg (varadic)
2408(08e1): 2d 7c bc a0 '  mov r11, FP
240c(08e2): 0c 7c fc 80 '  add r11, #12 ' reg <- addrfi
2410(08e3): 05 00 7c 5c '  jmp #LODF
2414(08e4): fc ff ff ff '  long -4
2418(08e5): 2e 7c 3c 08 '  wrlong r11, RI ' ASGNP4 addrl
241c(08e6): 04 00 7c 5c '  jmp #LODA
2420(08e7): 50 25 00 00 '  long @C___stdout
2424(08e8): 2e 6a bc a0 '  mov r2, RI ' reg ARG ADDRG
2428(08e9): 2d 5c bc a0 '  mov RI, FP
242c(08ea): 04 5c fc 84 '  sub RI, #-(-4)
2430(08eb): 2e 6c bc 08 '  rdlong r3, RI ' reg ARG INDIR ADDRLi
2434(08ec): 2d 5c bc a0 '  mov RI, FP
2438(08ed): 08 5c fc 80 '  add RI, #8
243c(08ee): 2e 6e bc 08 '  rdlong r4, RI ' reg ARG INDIR ADDRFi
2440(08ef): 0c 5e fc a0 '  mov BC, #12 ' arg size
2444(08f0): 0c 58 fc 84 '  sub SP, #12 ' stack space for reg ARGs
2448(08f1): 0b 00 7c 5c '  jmp #CALA
244c(08f2): d4 12 00 00 '  long @C__doprnt
2450(08f3): 0c 58 fc 80 '  add SP, #12 ' CALL addrg
2454(08f4): 05 00 7c 5c '  jmp #LODF
2458(08f5): f8 ff ff ff '  long -8
245c(08f6): 2e 66 3c 08 '  wrlong r0, RI ' ASGNI4 addrl
2460(08f7): 2d 7c bc a0 '  mov r11, FP
2464(08f8): 08 7c fc 84 '  sub r11, #-(-8) ' reg <- addrli
2468(08f9): 3e 66 bc 08 '  rdlong r0, r11 ' reg <- INDIRI4 reg
246c(08fa): 23 00 7c 5c '  jmp #POPM
2470(08fb): 00 08 00 00 '  long $800 ' restore registers
2474(08fc): 08 58 fc 80 '  add SP, #8 ' framesize
2478(08fd): 0a 00 7c 5c '  jmp #RETF
247c(08fe):             '  long ' align long
247c(08fe):             ' C_putc ' <symbol:putc>
247c(08fe): 22 00 7c 5c '  jmp #PSHM
2480(08ff): 00 08 03 00 '  long $30800 ' save registers
2484(0900): 36 88 bc a0 '  mov r17, r3 ' reg var <- reg arg
2488(0901): 35 86 bc a0 '  mov r16, r2 ' reg var <- reg arg
248c(0902): 44 6c bc a0 '  mov r3, r17 ' CVI, CVU or LOAD
2490(0903): 08 5e fc a0 '  mov BC, #8 ' arg size
2494(0904): 08 58 fc 84 '  sub SP, #8 ' stack space for reg ARGs
2498(0905): 0b 00 7c 5c '  jmp #CALA
249c(0906): 54 0b 00 00 '  long @C_catalina_putc
24a0(0907): 08 58 fc 80 '  add SP, #8 ' CALL addrg
24a4(0908): 33 7c bc a0 '  mov r11, r0 ' CVI, CVU or LOAD
24a8(0909): 23 00 7c 5c '  jmp #POPM
24ac(090a): 00 08 03 00 '  long $30800 ' restore registers
24b0(090b): 0c 00 7c 5c '  jmp #RETN
24b4(090c):             '  long ' align long
24b4(090c):             ' C_toupper ' <symbol:toupper>
24b4(090c): 22 00 7c 5c '  jmp #PSHM
24b8(090d): 00 08 02 00 '  long $20800 ' save registers
24bc(090e): 35 7c bc a0 '  mov r11, r2
24c0(090f): 61 7c fc d4 '  subs r11, #97 ' SUBI4 coni
24c4(0910): 1a 7c 7c 87 '  cmp r11,  #26 wz,wc 
24c8(0911): 15 00 7c 5c '  jmp #BRAE
24cc(0912): 6c 24 00 00 '  long @C_toupper_3 ' GEU4
24d0(0913): 35 7c bc a0 '  mov r11, r2
24d4(0914): 61 7c fc d4 '  subs r11, #97 ' SUBI4 coni
24d8(0915): 3e 88 bc a0 '  mov r17, r11
24dc(0916): 41 88 fc d0 '  adds r17, #65 ' ADDI4 coni
24e0(0917): 0e 00 7c 5c '  jmp #JMPA
24e4(0918): 70 24 00 00 '  long @C_toupper_4 ' JUMPV addrg
24e8(0919):             ' C_toupper_3
24e8(0919): 35 88 bc a0 '  mov r17, r2 ' CVI, CVU or LOAD
24ec(091a):             ' C_toupper_4
24ec(091a): 44 66 bc a0 '  mov r0, r17 ' CVI, CVU or LOAD
24f0(091b): 23 00 7c 5c '  jmp #POPM
24f4(091c): 00 08 02 00 '  long $20800 ' restore registers
24f8(091d): 0c 00 7c 5c '  jmp #RETN
24fc(091e):             '  long ' align long
24fc(091e):             ' C__waitcnt
24fc(091e): 00 6a fc f8 '  waitcnt r2, #0
2500(091f): 0c 00 7c 5c '  jmp #RETN
2504(0920):             '  long ' align long
2504(0920):             ' Catalina_Cnst
2504(0920):             '  long ' align long
2504(0920):             ' C_main_10_L000011 ' <symbol:10>
2504(0920): 43          '  byte 67
2505(----): 75          '  byte 117
2506(----): 72          '  byte 114
2507(----): 72          '  byte 114
2508(0921): 65          '  byte 101
2509(----): 6e          '  byte 110
250a(----): 74          '  byte 116
250b(----): 20          '  byte 32
250c(0922): 66          '  byte 102
250d(----): 72          '  byte 114
250e(----): 65          '  byte 101
250f(----): 71          '  byte 113
2510(0923): 75          '  byte 117
2511(----): 65          '  byte 101
2512(----): 6e          '  byte 110
2513(----): 63          '  byte 99
2514(0924): 79          '  byte 121
2515(----): 20          '  byte 32
2516(----): 3d          '  byte 61
2517(----): 20          '  byte 32
2518(0925): 25          '  byte 37
2519(----): 75          '  byte 117
251a(----): 0a          '  byte 10
251b(----): 00          '  byte 0
251c(0926):             '  long ' align long
251c(0926):             ' C_bbos_time_init_L000005 ' <symbol:6>
251c(0926): 40 42 0f 00 '  long 1000000
2520(0927):             '  long ' align long
2520(0927):             ' C_bbos_time_init_L000002 ' <symbol:3>
2520(0927): 3f 42 0f 00 '  long 999999
2524(0928):             '  long ' align long
2524(0928):             ' C_ds18b20_meas_to_cel_3_L000004 ' <symbol:3>
2524(0928): 54          '  byte 84
2525(----): 65          '  byte 101
2526(----): 6d          '  byte 109
2527(----): 70          '  byte 112
2528(0929): 65          '  byte 101
2529(----): 72          '  byte 114
252a(----): 61          '  byte 97
252b(----): 74          '  byte 116
252c(092a): 75          '  byte 117
252d(----): 72          '  byte 114
252e(----): 65          '  byte 101
252f(----): 3a          '  byte 58
2530(092b): 20          '  byte 32
2531(----): 25          '  byte 37
2532(----): 64          '  byte 100
2533(----): 43          '  byte 67
2534(092c): 0a          '  byte 10
2535(----): 00          '  byte 0
2536(----): 00 00       
2538(092d):             '  long ' align long
2538(092d):             ' C__doprnt_162_L000164 ' <symbol:162>
2538(092d): 24 1a 00 00 '  long @C__doprnt_147
253c(092e): 8c 1b 00 00 '  long @C__doprnt_158
2540(092f): dc 1a 00 00 '  long @C__doprnt_152
2544(0930): b4 17 00 00 '  long @C__doprnt_123
2548(0931): b4 17 00 00 '  long @C__doprnt_123
254c(0932): b4 17 00 00 '  long @C__doprnt_123
2550(0933): b4 17 00 00 '  long @C__doprnt_123
2554(0934): dc 1a 00 00 '  long @C__doprnt_152
2558(0935): b4 17 00 00 '  long @C__doprnt_123
255c(0936): b4 17 00 00 '  long @C__doprnt_123
2560(0937): b4 17 00 00 '  long @C__doprnt_123
2564(0938): b4 17 00 00 '  long @C__doprnt_123
2568(0939): 4c 18 00 00 '  long @C__doprnt_131
256c(093a): 24 1a 00 00 '  long @C__doprnt_147
2570(093b): 24 1a 00 00 '  long @C__doprnt_146
2574(093c): b4 17 00 00 '  long @C__doprnt_123
2578(093d): d4 1b 00 00 '  long @C__doprnt_159
257c(093e): 2c 19 00 00 '  long @C__doprnt_136
2580(093f): b4 17 00 00 '  long @C__doprnt_123
2584(0940): 24 1a 00 00 '  long @C__doprnt_147
2588(0941):             '  long ' align long
2588(0941):             ' C__doprnt_L000153 ' <symbol:154>
2588(0941): 00 04 00 00 '  long 1024
258c(0942):             '  long ' align long
258c(0942):             ' C__doprnt_139_L000140 ' <symbol:139>
258c(0942): 28          '  byte 40
258d(----): 6e          '  byte 110
258e(----): 75          '  byte 117
258f(----): 6c          '  byte 108
2590(0943): 6c          '  byte 108
2591(----): 29          '  byte 41
2592(----): 00          '  byte 0
2593(----): 00          
2594(0944):             '  long ' align long
2594(0944):             ' C__doprnt_L000112 ' <symbol:113>
2594(0944): ef ff ff ff '  long -17
2598(0945):             '  long ' align long
2598(0945):             ' C__doprnt_L000107 ' <symbol:108>
2598(0945): fb ff ff ff '  long -5
259c(0946):             '  long ' align long
259c(0946):             ' C__doprnt_L000098 ' <symbol:99>
259c(0946): 00 02 00 00 '  long 512
25a0(0947):             '  long ' align long
25a0(0947):             ' C__doprnt_L000088 ' <symbol:89>
25a0(0947): 00 10 00 00 '  long 4096
25a4(0948):             '  long ' align long
25a4(0948):             ' C__doprnt_L000071 ' <symbol:72>
25a4(0948): ff ff ff ff '  long -1
25a8(0949):             '  long ' align long
25a8(0949):             ' C_tmpfilexMRBQL_4c2c6c11_gnum_L000001_L000005 ' <symbol:6>
25a8(0949): fc ff ff ff '  long -4
25ac(094a):             '  long ' align long
25ac(094a):             ' Catalina_Init
25ac(094a):             '  long ' align long
25ac(094a): 00 00 00 00 ' C_errno long 0
25b0(094b):             '  long ' align long
25b0(094b):             ' C_tmpfilenc16i7_4d1284f5_ow_dpin_L000002 ' <symbol:ow_dpin>
25b0(094b): 01 00 00 00 '  long $1
25b4(094c):             '  long ' align long
25b4(094c):             ' C___stdin ' <symbol:__stdin>
25b4(094c): 00 00 00 00 '  long 0
25b8(094d): 00 00 00 00 '  long 0
25bc(094e): 01 00 00 00 '  long 1
25c0(094f): 00 00 00 00 '  long 0
25c4(0950): 00 00 00 00 '  long $0
25c8(0951): 00 00 00 00 '  long $0
25cc(0952):             '  long ' align long
25cc(0952):             ' C___stdout ' <symbol:__stdout>
25cc(0952): 00 00 00 00 '  long 0
25d0(0953): 01 00 00 00 '  long 1
25d4(0954): 02 00 00 00 '  long 2
25d8(0955): 00 00 00 00 '  long 0
25dc(0956): 00 00 00 00 '  long $0
25e0(0957): 00 00 00 00 '  long $0
25e4(0958):             '  long ' align long
25e4(0958):             ' C___stderr ' <symbol:__stderr>
25e4(0958): 00 00 00 00 '  long 0
25e8(0959): 02 00 00 00 '  long 2
25ec(095a): 42 00 00 00 '  long 66
25f0(095b): 00 00 00 00 '  long 0
25f4(095c): 00 00 00 00 '  long $0
25f8(095d): 00 00 00 00 '  long $0
25fc(095e):             '  long ' align long
25fc(095e):             ' C___iotab ' <symbol:__iotab>
25fc(095e): 38 25 00 00 '  long @C___stdin
2600(095f): 50 25 00 00 '  long @C___stdout
2604(0960): 68 25 00 00 '  long @C___stderr
2608(0961): 00 00 00 00 '  long $0
260c(0962): 00 00 00 00 '  byte 0[64]
2610(0963): 00 00 00 00 ' 
2614(0964): 00 00 00 00 ' 
2618(0965): 00 00 00 00 ' 
261c(0966): 00 00 00 00 ' 
2620(0967): 00 00 00 00 ' 
2624(0968): 00 00 00 00 ' 
2628(0969): 00 00 00 00 ' 
262c(096a): 00 00 00 00 ' 
2630(096b): 00 00 00 00 ' 
2634(096c): 00 00 00 00 ' 
2638(096d): 00 00 00 00 ' 
263c(096e): 00 00 00 00 ' 
2640(096f): 00 00 00 00 ' 
2644(0970): 00 00 00 00 ' 
2648(0971): 00 00 00 00 ' 
264c(0972):             '  long ' align long
264c(0972):             ' Catalina_Data
264c(0972):             '  long ' align long
264c(0972):             ' C_usec_delay ' <symbol:usec_delay>
264c(0972): 00 00 00 00 '  byte 0[4]
2650(0973):             '  long ' align long
2650(0973):             ' sbrkinit  ' heap starts here
2650(0973): 00 00 00 00 '  long 0 ' this long is required to workaround an obscure homespun bug!!!
2654(0974):             '  long ' align long
2654(0974):             ' Catalina_Ends ' end of segments
'============================ Method #1: PUB Base =============================
'PUB Base : addr
'------------------------------------------------------------------------------
   addr := @@0 ' Catalina Base Address
'------------------------------------------------------------------------------
2654: 35             PUSH#0	
2655: 97 00          PUSH#.B	OBJ+0[]
2657: 61             POP  	Locals+0
2658: 32             RETURN	
2659: 00 00 00    

'******************************************************************************
'                           Catalina_Cogstore.spin                             
'******************************************************************************

'=================================== CONs =====================================
MAX_LONGS = 300
COGSTORE = 32508
ARGC_ADDR = 32560
ARGV_ADDR = 32562
ARGV_0 = 32564
ARGV_MAX = 32
CMD_READ = 268435456
CMD_WRITE = 536870912
CMD_SIZE = 805306368
CMD_SETUP = 1073741824
CMD_RESPONSE = -17958194
QUOTE_CHAR = 34
'=============================== Object Header ================================
265c: ac 03 08 01 ' 940 bytes, 8-1 methods, 1 object pointers
2660: 94 02 00 00 ' ptr #1 to $28f0: PUB Start (locals size: 0)
2664: 9b 02 00 00 ' ptr #2 to $28f7: PUB Valid (locals size: 0)
2668: b7 02 00 00 ' ptr #3 to $2913: PUB Stop (locals size: 0)
266c: c0 02 00 00 ' ptr #4 to $291c: PUB Write (locals size: 0)
2670: e6 02 00 00 ' ptr #5 to $2942: PUB Read (locals size: 0)
2674: 0c 03 04 00 ' ptr #6 to $2968: PUB Size (locals size: 4)
2678: 41 03 00 00 ' ptr #7 to $299d: PUB Setup (locals size: 0)
267c: 4c 11 00 00 ' ptr #8 to $37a8: OBJ common : Catalina_Common.spin (VAR offset: 0)
'================================ DAT Section =================================
2680(0000):             '               org       0
2680(0000):             ' entry
2680(0000):             ' done
2680(0000): 00 18 fd a0 '               mov       t0,#0
2684(0001): 91 18 3d 08 '               wrlong    t0,command
2688(0002):             ' loop
2688(0002): 91 18 bd 0a '               rdlong    t0,command wz           ' loop ...
268c(0003): 02 00 68 5c '         if_z  jmp       #loop                   ' ... till ...
2690(0004): 93 18 3d 86 '               cmp       t0,response wz          ' ... we get ...
2694(0005): 02 00 68 5c '         if_z  jmp       #loop                   ' ... a command
2698(0006): 8c 1a bd a0 '               mov       t1,t0                   ' extract ...
269c(0007): 90 1a bd 60 '               and       t1,low24                ' ... address argument
26a0(0008): 1c 18 fd 28 '               shr       t0,#28                  ' extract command
26a4(0009): 01 18 7d 86 '               cmp       t0,#CMD_READ>>28 wz     ' do ...
26a8(000a): 13 00 68 5c '         if_z  jmp       #do_read                ' ... read
26ac(000b): 02 18 7d 86 '               cmp       t0,#CMD_WRITE>>28 wz    ' do ... 
26b0(000c): 1b 00 68 5c '         if_z  jmp       #do_write               ' ... write               
26b4(000d): 03 18 7d 86 '               cmp       t0,#CMD_SIZE>>28 wz     ' do ...
26b8(000e): 2a 00 68 5c '         if_z  jmp       #do_size                ' ... size
26bc(000f): 04 18 7d 86 '               cmp       t0,#CMD_SETUP>>28 wz    ' do ...
26c0(0010): 30 00 68 5c '         if_z  jmp       #do_setup               ' ... setup
26c4(0011):             ' identify        
26c4(0011): 91 26 3d 08 '               wrlong    response,command        ' otherwise return unlikely response ...
26c8(0012): 02 00 7c 5c '               jmp       #loop                   ' ... and loop till we get a known command
26cc(0013):             ' do_read
26cc(0013): 9b 2c fc 54 '               movd      rd_inst,#storage        ' read a copy ...                                
26d0(0014): 98 18 bd a2 '               mov       t0,len wz               ' ... of ...                                
26d4(0015):             ' rd_loop                                         ' ... the ...                                  
26d4(0015): 00 00 68 5c '         if_z  jmp       #done                   ' ... string ...                                
26d8(0016): 8d 00 3c 08 ' rd_inst       wrlong    0-0,t1                  ' ... to ...                              
26dc(0017): 97 2c bc 80 '               add       rd_inst,d_inc           ' ... the ...                                 
26e0(0018): 04 1a fd 80 '               add       t1,#4                   ' ... address ...                                   
26e4(0019): 01 18 fd 86 '               sub       t0,#1 wz                ' ... provided ...                              
26e8(001a): 15 00 7c 5c '               jmp       #rd_loop                ' ... (assume there is enough space!)
26ec(001b):             ' do_write
26ec(001b): 9b 3c fc 54 '               movd      wr_inst,#storage        ' write ...
26f0(001c): 00 30 fd a0 '               mov       len,#0                  ' ... a ...
26f4(001d):             ' wr_loop                                         ' ... copy ...
26f4(001d): 8d 1c bd 08 '               rdlong    t2,t1                   ' ... of ...
26f8(001e): 8e 00 bc a0 ' wr_inst       mov       0-0,t2                  ' ... the ...
26fc(001f): 97 3c bc 80 '               add       wr_inst,d_inc           ' ... string ...
2700(0020): 04 1a fd 80 '               add       t1,#4                   ' ... to ...
2704(0021): 01 30 fd 80 '               add       len,#1                  ' ... cog ...
2708(0022): 2c 31 7d 86 '               cmp       len,#MAX_LONGS wz       ' ... RAM ...
270c(0023): 00 00 68 5c '         if_z  jmp       #done                   ' ... stopping ...
2710(0024): 04 18 fd a0 '               mov       t0,#4                   ' ... when ... 
2714(0025): ff 1c 7d 62 ' wr_test       test      t2,#$FF wz              ' ... cog ...
2718(0026): 00 00 68 5c '       if_z    jmp       #done                   ' ... full ...
271c(0027): 08 1c fd 28 '               shr       t2,#8                   ' ... or ...
2720(0028): 25 18 fd e4 '               djnz      t0,#wr_test             ' ... termination ... 
2724(0029): 1d 00 7c 5c '               jmp       #wr_loop                ' ... detected
2728(002a):             ' do_size
2728(002a): 90 1a 3d 86 '               cmp       t1,low24 wz             ' return ...
272c(002b): 02 00 54 5c '         if_nz jmp       #loop                   ' ... the ...                     
2730(002c): 98 18 bd a0 '               mov       t0,len                  ' ... size (in LONGs) ...
2734(002d): 92 18 bd 68 '               or        t0,size_cmd             ' ... of ...
2738(002e): 91 18 3d 08 '               wrlong    t0,command              ' ... the stored ...
273c(002f): 02 00 7c 5c '               jmp       #loop                   ' ... command line
2740(0030):             ' do_setup                                        
2740(0030): 77 30 7d ec '               tjz       len,#no_args            ' if no stored string, set argc/argv to default values
2744(0031): 8d 1c bd a0 '               mov       t2,t1                   ' save the address argument
2748(0032): 9b 6a fc 54 '               movd      su_inst,#storage        ' otherwise ...
274c(0033): 98 18 bd a2 '               mov       t0,len wz               ' ... read ...
2750(0034):             ' su_loop                                         ' ... the ...             
2750(0034): 3a 00 68 5c '         if_z  jmp       #su_count_args          ' ... stored ...
2754(0035): 8d 00 3c 08 ' su_inst       wrlong    0-0,t1                  ' ... string ...
2758(0036): 97 6a bc 80 '               add       su_inst,d_inc           ' ... to ...
275c(0037): 04 1a fd 80 '               add       t1,#4                   ' ... the ...
2760(0038): 01 18 fd 86 '               sub       t0,#1 wz                ' ... address ...
2764(0039): 34 00 7c 5c '               jmp       #su_loop                ' ... provided (assume there is enough space!) 
2768(003a):             ' su_count_args
2768(003a): 8e 1a bd a0 '               mov       t1,t2                   ' count the number of arguments in the string
276c(003b): 00 32 fd a0 '               mov       n,#0                    ' no arguments yet           
2770(003c): 00 34 fd a0 '               mov       q,#0                    ' not in a quoted string                                                    
2774(003d):             ' su_count_loop
2774(003d): 7c 00 fd 5c '               call      #skip_to_non_space      ' find next non-space
2778(003e): 00 18 7d 86 '               cmp       t0,#0 wz                ' end of string?
277c(003f): 43 00 68 5c '         if_z  jmp       #su_save_argc           ' yes - set up argc
2780(0040): 01 32 fd 80 '               add       n,#1                    ' no - found an argument
2784(0041): 81 16 fd 5c '               call      #skip_to_space          ' skip to next space (i.e. end of argument)                            
2788(0042): 3d 00 7c 5c '               jmp       #su_count_loop                         
278c(0043):             ' su_save_argc
278c(0043): 20 32 7d 87 '               cmp       n,#ARGV_MAX wz,wc       ' set up argc and first element of argv                                 
2790(0044): 20 32 c5 a0 '         if_a  mov       n,#ARGV_MAX             '                                    
2794(0045): 94 32 3d 04 '               wrword    n,argc                  ' word[common#ARGC_ADDR] := n                                              
2798(0046): 95 2c 3d 04 '               wrword    argv_start,argv         ' word[common#ARGV_ADDR] := argv_0                               
279c(0047): 8e 1a bd a0 '               mov       t1,t2      
27a0(0048): 7c 00 fd 5c '               call      #skip_to_non_space      ' find start of first argument ...
27a4(0049): 96 1e bd a0 '               mov       t3,argv_start           ' ... and save it ...                                
27a8(004a): 8f 1a 3d 08 '               wrlong    t1,t3                   ' ... in long[common#ARGV_0] 
27ac(004b): 00 34 fd a0 '               mov       q,#0                    ' not currently within quoted string
27b0(004c):             ' su_argv_loop
27b0(004c): 8d 18 bd 02 '               rdbyte    t0,t1 wz                ' deconstruct command line, creating the argv array as we go                 
27b4(004d): 73 00 68 5c '         if_z  jmp       #su_argv_done           ' end of string found - terminate the argv array                                                                    
27b8(004e): 22 18 7d 86 '               cmp       t0,#QUOTE_CHAR wz       ' found a quote?                                                            
27bc(004f): 62 00 54 5c '         if_nz jmp       #su_argv_notquote       ' no - just copy character (or terminate argument of it is a space)
27c0(0050): 01 34 fd 6e '               xor       q,#1 wz                 ' yes - toggle marker indicating we are within quoted string
27c4(0051): 71 00 54 5c '         if_nz jmp       #su_argv_nextchar       ' if this is the start of a quoted string, just keep processing
27c8(0052): 8d 18 bd a0 '               mov       t0,t1                   ' otherwise, is the end ...
27cc(0053): 01 18 fd 80 '               add       t0,#1                   ' ... of the quoted string ...
27d0(0054): 8c 18 bd 02 '               rdbyte    t0,t0 wz                ' ... also ... 
27d4(0055): 58 00 68 5c '         if_z  jmp       #su_argv_chkquote       ' ... the end ...
27d8(0056): 20 18 7d 86 '               cmp       t0,#" " wz              ' ... of the argument?
27dc(0057): 71 00 54 5c '         if_nz jmp       #su_argv_nextchar       ' no - just keep processing 
27e0(0058):             ' su_argv_chkquote
27e0(0058): 8f 18 bd 08 '               rdlong    t0,t3                   ' yes - is there a quote ...
27e4(0059): 8c 18 bd 00 '               rdbyte    t0,t0                   ' ... at the start ...
27e8(005a): 22 18 7d 86 '               cmp       t0,#QUOTE_CHAR wz       ' ... of the argument?
27ec(005b): 5e 00 68 5c '         if_z  jmp       #su_argv_delquote       ' yes - delete the start and end quotes 
27f0(005c): 01 1a fd 80 '               add       t1,#1                   ' no - do not delete the start or end quotes ...
27f4(005d): 65 00 7c 5c '               jmp       #su_argv_nextarg        ' ... just save the argument        
27f8(005e):             ' su_argv_delquote             
27f8(005e): 8f 18 bd 08 '               rdlong    t0,t3                   ' remove quote ...
27fc(005f): 01 18 fd 80 '               add       t0,#1                   ' ... from start ...     
2800(0060): 8f 18 3d 08 '               wrlong    t0,t3                   ' ... of string
2804(0061): 65 00 7c 5c '               jmp       #su_argv_nextarg        ' save next argument
2808(0062):             ' su_argv_notquote                                 
2808(0062): 20 18 7d 86 '               cmp       t0,#" " wz              ' found a space?              
280c(0063): 71 00 54 5c '         if_nz jmp       #su_argv_nextchar       ' no - just keep processing                                       
2810(0064): 71 34 7d e8 '               tjnz      q,#su_argv_nextchar     ' yes - are we within a quote? If yes, just keep processing
2814(0065):             ' su_argv_nextarg              
2814(0065): 01 32 fd 80 '               add       n,#1                    ' no - found the end of an argument                                       
2818(0066): 20 32 7d 87 '               cmp       n,#ARGV_MAX wz,wc       ' too many arguments?                                      
281c(0067): 73 00 4c 5c '         if_ae jmp       #su_argv_done           ' yes - just terminate argv array                                       
2820(0068): 00 18 fd a0 '               mov       t0,#0                   ' no - zero terminate ...
2824(0069): 8d 18 3d 00 '               wrbyte    t0,t1                   ' ... the current argument                                          
2828(006a): 01 1a fd 80 '               add       t1,#1                   ' find the start ...    
282c(006b): 7c 00 fd 5c '               call      #skip_to_non_space      ' ... of the next argument
2830(006c): 8d 18 bd 02 '               rdbyte    t0,t1 wz                ' end of string?
2834(006d): 73 00 68 5c '         if_z  jmp       #su_argv_done           ' yes - terminate qrgv array
2838(006e): 04 1e fd 80 '               add       t3,#4                   ' no - save new pointer ...          
283c(006f): 8f 1a 3d 08 '               wrlong    t1,t3                   ' ... in the argv array          
2840(0070): 4c 00 7c 5c '               jmp       #su_argv_loop           ' ... and keep processing
2844(0071):             ' su_argv_nextchar        
2844(0071): 01 1a fd 80 '               add       t1,#1                   '  process ...              
2848(0072): 4c 00 7c 5c '               jmp       #su_argv_loop           '  ... the next character          
284c(0073):             ' su_argv_done                                                        
284c(0073): 04 1e fd 80 '               add       t3,#4                   '   ' terminate argv array with a null entry   
2850(0074): 00 18 fd a0 '               mov       t0,#0                   '   long[b] := 0                               
2854(0075): 8f 18 3d 08 '               wrlong    t0,t3                   '                                              
2858(0076): 00 00 7c 5c '               jmp       #done                   '   
285c(0077):             ' no_args                                         ' 
285c(0077): 00 18 fd a0 '               mov       t0,#0                   ' if no stored string ...   
2860(0078): 94 18 3d 04 '               wrword    t0,argc                 ' ... set argc ...                    
2864(0079): 96 18 3d 08 '               wrlong    t0,argv_start           ' ... and argv_0 to zero                 
2868(007a): 95 2c 3d 04 '               wrword    argv_start,argv         ' set argv to argv_0          
286c(007b): 00 00 7c 5c '               jmp       #done                   
2870(007c):             ' skip_to_non_space
2870(007c): 8d 18 bd 00 '               rdbyte    t0,t1
2874(007d): 20 18 7d 86 '               cmp       t0,#" " wz
2878(007e): 01 1a e9 80 '         if_z  add       t1,#1     
287c(007f): 7c 00 68 5c '         if_z  jmp       #skip_to_non_space          
2880(0080):             ' skip_to_non_space_ret
2880(0080): 00 00 7c 5c '               ret
2884(0081):             ' skip_to_space
2884(0081): 8d 18 bd 02 '               rdbyte    t0,t1 wz
2888(0082): 8b 00 68 5c '         if_z  jmp       #skip_to_space_ret
288c(0083): 22 18 7d 86 '               cmp       t0,#QUOTE_CHAR wz
2890(0084): 01 34 e9 6c '         if_z  xor       q,#1
2894(0085): 89 00 68 5c '         if_z  jmp       #:skip_char
2898(0086): 20 18 7d 86 '               cmp       t0,#" " wz
289c(0087): 89 00 54 5c '         if_nz jmp       #:skip_char
28a0(0088): 8b 34 7d ec '               tjz       q,#skip_to_space_ret
28a4(0089):             ' :skip_char              
28a4(0089): 01 1a fd 80 '               add       t1,#1
28a8(008a): 81 00 7c 5c '               jmp       #skip_to_space          
28ac(008b):             ' skip_to_space_ret
28ac(008b): 00 00 7c 5c '               ret
28b0(008c): 00 00 00 00 ' t0            long      0
28b4(008d): 00 00 00 00 ' t1            long      0
28b8(008e): 00 00 00 00 ' t2            long      0
28bc(008f): 00 00 00 00 ' t3            long      0
28c0(0090): ff ff ff 00 ' low24         long      $FFFFFF
28c4(0091): fc 7e 00 00 ' command       long      COGSTORE   
28c8(0092): 00 00 00 30 ' size_cmd      long      CMD_SIZE
28cc(0093): ce fa ed fe ' response      long      CMD_RESPONSE
28d0(0094): 30 7f 00 00 ' argc          long      ARGC_ADDR
28d4(0095): 32 7f 00 00 ' argv          long      ARGV_ADDR
28d8(0096): 34 7f 00 00 ' argv_start    long      ARGV_0
28dc(0097): 00 02 00 00 ' d_inc         long      1<<9
28e0(0098): 00 00 00 00 ' len           long      0                       ' storage used (longs)
28e4(0099): 00 00 00 00 ' n             long      0
28e8(009a): 00 00 00 00 ' q             long      0
28ec(009b): 00 00 00 00 ' storage       long      0                       ' long storage starts here      
'=========================== Method #1: PUB Start =============================
'PUB Start
'------------------------------------------------------------------------------
  coginit(7, @entry, 0)
'------------------------------------------------------------------------------
28f0: 37 22          PUSH#kp	7 ($7)
28f2: c7 24          PUSH#.L	OBJ+36
28f4: 35             PUSH#0	
28f5: 2c             COGISUB	
28f6: 32             RETURN	
'=========================== Method #2: PUB Valid =============================
'PUB Valid : ok
'------------------------------------------------------------------------------
  long[COGSTORE] := -1 ' any invalid command
'------------------------------------------------------------------------------
28f7: 34             PUSH#-1	
28f8: 39 7e fc       PUSH#k2	32508
28fb: c1             POP.L	Mem[]
'------------------------------------------------------------------------------
  repeat 100
'------------------------------------------------------------------------------
28fc: 38 64          PUSH#k1	100
28fe: 08 10          LOOPJPF	.+16 (dest:$2910)
'------------------------------------------------------------------------------
    if long[COGSTORE] == CMD_RESPONSE
'------------------------------------------------------------------------------
2900: 39 7e fc       PUSH#k2	32508
2903: c0             PUSH.L	Mem[]
2904: 3b fe ed fa ce PUSH#k4	-17958194
2909: fc             EQ   	
290a: 0a 02          JPF  	.+2 (dest:$290e)
'------------------------------------------------------------------------------
      return -1
'------------------------------------------------------------------------------
290c: 34             PUSH#-1	
290d: 33             RETVAL	
290e: 09 70          LOOPRPT	.-16 (dest:$2900)
'------------------------------------------------------------------------------
  return 0
'------------------------------------------------------------------------------
2910: 35             PUSH#0	
2911: 33             RETVAL	
2912: 32             RETURN	
'============================ Method #3: PUB Stop =============================
'PUB Stop
'------------------------------------------------------------------------------
  if Valid
'------------------------------------------------------------------------------
2913: 00             FRAME	Call with return value	
2914: 05 02          CALL 	+2 
2916: 0a 03          JPF  	.+3 (dest:$291b)
'------------------------------------------------------------------------------
    cogstop(7)
'------------------------------------------------------------------------------
2918: 37 22          PUSH#kp	7 ($7)
291a: 21             COGSTOP	
291b: 32             RETURN	
'=========================== Method #4: PUB Write =============================
'PUB Write(Addr) : ok
'------------------------------------------------------------------------------
  if Valid
'------------------------------------------------------------------------------
291c: 00             FRAME	Call with return value	
291d: 05 02          CALL 	+2 
291f: 0a 1e          JPF  	.+30 (dest:$293f)
'------------------------------------------------------------------------------
    long[COGSTORE] := CMD_WRITE | Addr
'------------------------------------------------------------------------------
2921: 37 1c          PUSH#kp	536870912 ($20000000)
2923: 64             PUSH 	Locals+4
2924: ea             BIT_OR	
2925: 39 7e fc       PUSH#k2	32508
2928: c1             POP.L	Mem[]
'------------------------------------------------------------------------------
    repeat 100000
'------------------------------------------------------------------------------
2929: 3a 01 86 a0    PUSH#k3	100000
292d: 08 0c          LOOPJPF	.+12 (dest:$293b)
'------------------------------------------------------------------------------
      if long[COGSTORE] == 0
'------------------------------------------------------------------------------
292f: 39 7e fc       PUSH#k2	32508
2932: c0             PUSH.L	Mem[]
2933: 35             PUSH#0	
2934: fc             EQ   	
2935: 0a 02          JPF  	.+2 (dest:$2939)
'------------------------------------------------------------------------------
        return -1
'------------------------------------------------------------------------------
2937: 34             PUSH#-1	
2938: 33             RETVAL	
2939: 09 74          LOOPRPT	.-12 (dest:$292f)
'------------------------------------------------------------------------------
    return 0
'------------------------------------------------------------------------------
293b: 35             PUSH#0	
293c: 33             RETVAL	
'------------------------------------------------------------------------------
  else
'------------------------------------------------------------------------------
293d: 04 02          GOTO 	.+2 (dest:$2941)
'------------------------------------------------------------------------------
    return 0
'------------------------------------------------------------------------------
293f: 35             PUSH#0	
2940: 33             RETVAL	
2941: 32             RETURN	
'============================ Method #5: PUB Read =============================
'PUB Read(Addr) : ok
'------------------------------------------------------------------------------
  if Valid
'------------------------------------------------------------------------------
2942: 00             FRAME	Call with return value	
2943: 05 02          CALL 	+2 
2945: 0a 1e          JPF  	.+30 (dest:$2965)
'------------------------------------------------------------------------------
    long[COGSTORE] := CMD_READ | Addr
'------------------------------------------------------------------------------
2947: 37 1b          PUSH#kp	268435456 ($10000000)
2949: 64             PUSH 	Locals+4
294a: ea             BIT_OR	
294b: 39 7e fc       PUSH#k2	32508
294e: c1             POP.L	Mem[]
'------------------------------------------------------------------------------
    repeat 100000
'------------------------------------------------------------------------------
294f: 3a 01 86 a0    PUSH#k3	100000
2953: 08 0c          LOOPJPF	.+12 (dest:$2961)
'------------------------------------------------------------------------------
      if long[COGSTORE] == 0
'------------------------------------------------------------------------------
2955: 39 7e fc       PUSH#k2	32508
2958: c0             PUSH.L	Mem[]
2959: 35             PUSH#0	
295a: fc             EQ   	
295b: 0a 02          JPF  	.+2 (dest:$295f)
'------------------------------------------------------------------------------
        return -1
'------------------------------------------------------------------------------
295d: 34             PUSH#-1	
295e: 33             RETVAL	
295f: 09 74          LOOPRPT	.-12 (dest:$2955)
'------------------------------------------------------------------------------
    return 0
'------------------------------------------------------------------------------
2961: 35             PUSH#0	
2962: 33             RETVAL	
'------------------------------------------------------------------------------
  else
'------------------------------------------------------------------------------
2963: 04 02          GOTO 	.+2 (dest:$2967)
'------------------------------------------------------------------------------
    return 0
'------------------------------------------------------------------------------
2965: 35             PUSH#0	
2966: 33             RETVAL	
2967: 32             RETURN	
'============================ Method #6: PUB Size =============================
'PUB Size | s
'------------------------------------------------------------------------------
  if not Valid
'------------------------------------------------------------------------------
2968: 00             FRAME	Call with return value	
2969: 05 02          CALL 	+2 
296b: ff             LOG_NOT	
296c: 0a 02          JPF  	.+2 (dest:$2970)
'------------------------------------------------------------------------------
    return -1
'------------------------------------------------------------------------------
296e: 34             PUSH#-1	
296f: 33             RETVAL	
'------------------------------------------------------------------------------
  long[COGSTORE] := CMD_SIZE | $FFFFFF 
'------------------------------------------------------------------------------
2970: 3b 30 00 00 00 PUSH#k4	805306368
2975: 37 37          PUSH#kp	16777215 ($ffffff)
2977: ea             BIT_OR	
2978: 39 7e fc       PUSH#k2	32508
297b: c1             POP.L	Mem[]
'------------------------------------------------------------------------------
  repeat 100
'------------------------------------------------------------------------------
297c: 38 64          PUSH#k1	100
297e: 08 19          LOOPJPF	.+25 (dest:$2999)
'------------------------------------------------------------------------------
    if long[COGSTORE] <> CMD_SIZE | $FFFFFF
'------------------------------------------------------------------------------
2980: 39 7e fc       PUSH#k2	32508
2983: c0             PUSH.L	Mem[]
2984: 3b 30 00 00 00 PUSH#k4	805306368
2989: 37 37          PUSH#kp	16777215 ($ffffff)
298b: ea             BIT_OR	
298c: fb             NE   	
298d: 0a 08          JPF  	.+8 (dest:$2997)
'------------------------------------------------------------------------------
      return long[COGSTORE] & $FFFFFF
'------------------------------------------------------------------------------
298f: 39 7e fc       PUSH#k2	32508
2992: c0             PUSH.L	Mem[]
2993: 37 37          PUSH#kp	16777215 ($ffffff)
2995: e8             BIT_AND	
2996: 33             RETVAL	
2997: 09 67          LOOPRPT	.-25 (dest:$2980)
'------------------------------------------------------------------------------
  return -2
'------------------------------------------------------------------------------
2999: 37 60          PUSH#kp	-2 ($fffffffe)
299b: 33             RETVAL	
299c: 32             RETURN	
'=========================== Method #7: PUB Setup =============================
'PUB Setup(addr) : i
'------------------------------------------------------------------------------
  word[ARGC_ADDR] := 0
'------------------------------------------------------------------------------
299d: 35             PUSH#0	
299e: 39 7f 30       PUSH#k2	32560
29a1: a1             POP.W	Mem[]
'------------------------------------------------------------------------------
  word[ARGV_ADDR] := 0
'------------------------------------------------------------------------------
29a2: 35             PUSH#0	
29a3: 39 7f 32       PUSH#k2	32562
29a6: a1             POP.W	Mem[]
'------------------------------------------------------------------------------
  repeat i from 0 to ARGV_MAX-1
'------------------------------------------------------------------------------
29a7: 35             PUSH#0	
29a8: 61             POP  	Locals+0
'------------------------------------------------------------------------------
    long[ARGV_0][i] := 0
'------------------------------------------------------------------------------
29a9: 35             PUSH#0	
29aa: 39 7f 34       PUSH#k2	32564
29ad: 60             PUSH 	Locals+0
29ae: d1             POP.L	Mem[][]
29af: 35             PUSH#0	
29b0: 37 04          PUSH#kp	32 ($20)
29b2: 36             PUSH#1	
29b3: ed             SUB  	
29b4: 62 02 72       USING	Locals+0, RPTINCJ .-14 (dest:$29a9)
'------------------------------------------------------------------------------
  if not Valid
'------------------------------------------------------------------------------
29b7: 00             FRAME	Call with return value	
29b8: 05 02          CALL 	+2 
29ba: ff             LOG_NOT	
29bb: 0a 2c          JPF  	.+44 (dest:$29e9)
'------------------------------------------------------------------------------
    word[ARGC_ADDR] := 1
'------------------------------------------------------------------------------
29bd: 36             PUSH#1	
29be: 39 7f 30       PUSH#k2	32560
29c1: a1             POP.W	Mem[]
'------------------------------------------------------------------------------
    word[ARGV_ADDR] := ARGV_0
'------------------------------------------------------------------------------
29c2: 39 7f 34       PUSH#k2	32564
29c5: 39 7f 32       PUSH#k2	32562
29c8: a1             POP.W	Mem[]
'------------------------------------------------------------------------------
    long[ARGV_0] := ARGV_0 + 4*(ARGV_MAX-2)
'------------------------------------------------------------------------------
29c9: 39 7f 34       PUSH#k2	32564
29cc: 37 01          PUSH#kp	4 ($4)
29ce: 37 04          PUSH#kp	32 ($20)
29d0: 37 00          PUSH#kp	2 ($2)
29d2: ed             SUB  	
29d3: f4             MPY  	
29d4: ec             ADD  	
29d5: 39 7f 34       PUSH#k2	32564
29d8: c1             POP.L	Mem[]
'------------------------------------------------------------------------------
    long[ARGV_0][ARGV_MAX-2] := $6C6C756E ' null
'------------------------------------------------------------------------------
29d9: 3b 6c 6c 75 6e PUSH#k4	1819047278
29de: 39 7f 34       PUSH#k2	32564
29e1: 37 04          PUSH#kp	32 ($20)
29e3: 37 00          PUSH#kp	2 ($2)
29e5: ed             SUB  	
29e6: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  else
'------------------------------------------------------------------------------
29e7: 04 1c          GOTO 	.+28 (dest:$2a05)
'------------------------------------------------------------------------------
    long[COGSTORE] := CMD_SETUP | Addr
'------------------------------------------------------------------------------
29e9: 37 1d          PUSH#kp	1073741824 ($40000000)
29eb: 64             PUSH 	Locals+4
29ec: ea             BIT_OR	
29ed: 39 7e fc       PUSH#k2	32508
29f0: c1             POP.L	Mem[]
'------------------------------------------------------------------------------
    repeat 100000
'------------------------------------------------------------------------------
29f1: 3a 01 86 a0    PUSH#k3	100000
29f5: 08 0c          LOOPJPF	.+12 (dest:$2a03)
'------------------------------------------------------------------------------
      if long[COGSTORE] == 0
'------------------------------------------------------------------------------
29f7: 39 7e fc       PUSH#k2	32508
29fa: c0             PUSH.L	Mem[]
29fb: 35             PUSH#0	
29fc: fc             EQ   	
29fd: 0a 02          JPF  	.+2 (dest:$2a01)
'------------------------------------------------------------------------------
        return -1
'------------------------------------------------------------------------------
29ff: 34             PUSH#-1	
2a00: 33             RETVAL	
2a01: 09 74          LOOPRPT	.-12 (dest:$29f7)
'------------------------------------------------------------------------------
    return 0
'------------------------------------------------------------------------------
2a03: 35             PUSH#0	
2a04: 33             RETVAL	
2a05: 32             RETURN	
2a06: 00 00       

'******************************************************************************
'                              Catalina_LMM.spin                               
'******************************************************************************

'=================================== CONs =====================================
SignFlag = 1
ZeroFlag = 2
NaNFlag = 8
'=============================== Object Header ================================
2a08: a8 07 03 00 ' 1960 bytes, 3-1 methods, 0 object pointers
2a0c: 88 07 00 00 ' ptr #1 to $3190: PUB Entry_Addr (locals size: 0)
2a10: 8c 07 00 00 ' ptr #2 to $3194: PUB Run (locals size: 0)
'================================ DAT Section =================================
2a14(0000):             '  org 0
2a14(0000):             ' entry
2a14(0000): 02 00 7c 5c '    jmp #INIT            '$00
2a18(0001): 02 00 7c 5c '    jmp #INIT            '$01 remove this line when using POD, since it
2a1c(0002): 53 00 7c 5c ' INIT    jmp #lmm_init   '$02
2a20(0003): 81 00 7c 5c ' LODL    jmp #load_l     '$03
2a24(0004): 83 00 7c 5c ' LODA    jmp #load_a     '$04
2a28(0005): 85 00 7c 5c ' LODF    jmp #fp_ind     '$05
2a2c(0006): 88 00 7c 5c ' PSHL    jmp #push_l     '$06
2a30(0007): a9 00 7c 5c ' PSHB    jmp #push_b     '$07
2a34(0008): b1 00 7c 5c ' CPYB    jmp #copy_b     '$08
2a38(0009): be 00 7c 5c ' NEWF    jmp #new_fp     '$09
2a3c(000a): c4 00 7c 5c ' RETF    jmp #fp_ret     '$0a
2a40(000b): c9 00 7c 5c ' CALA    jmp #f_call     '$0b
2a44(000c): c6 00 7c 5c ' RETN    jmp #f_ret      '$0c
2a48(000d): cb 00 7c 5c ' CALI    jmp #f_cali     '$0d
2a4c(000e): ce 00 7c 5c ' JMPA    jmp #f_jump     '$0e
2a50(000f): d0 00 7c 5c ' JMPI    jmp #f_jmpi     '$0f
2a54(0010): de 00 7c 5c ' DIVS    jmp #f_d32s     '$10
2a58(0011): f0 00 7c 5c ' DIVU    jmp #f_d32u     '$11
2a5c(0012): fc 00 7c 5c ' MULT    jmp #f_m32      '$12
2a60(0013): 06 01 7c 5c ' BR_Z    jmp #bra_z      '$13
2a64(0014): 08 01 7c 5c ' BRNZ    jmp #bra_nz     '$14
2a68(0015): 0a 01 7c 5c ' BRAE    jmp #bra_ae     '$15
2a6c(0016): 0c 01 7c 5c ' BR_A    jmp #bra_a      '$16
2a70(0017): 0e 01 7c 5c ' BRBE    jmp #bra_be     '$17
2a74(0018): 10 01 7c 5c ' BR_B    jmp #bra_b      '$18
2a78(0019): 12 01 7c 5c ' SYSP    jmp #plugin     '$19
2a7c(001a): 8b 00 7c 5c ' PSHA    jmp #push_a     '$1a
2a80(001b): 32 01 7c 5c ' FADD    jmp #flt_add    '$1b
2a84(001c): 31 01 7c 5c ' FSUB    jmp #flt_sub    '$1c
2a88(001d): 47 01 7c 5c ' FMUL    jmp #flt_mul    '$1d
2a8c(001e): 56 01 7c 5c ' FDIV    jmp #flt_div    '$1e
2a90(001f): 82 01 7c 5c ' FCMP    jmp #flt_cmp    '$1f
2a94(0020): 66 01 7c 5c ' FLIN    jmp #flt_int    '$20
2a98(0021): 73 01 7c 5c ' INFL    jmp #int_flt    '$21
2a9c(0022): 93 00 7c 5c ' PSHM    jmp #push_m     '$22
2aa0(0023): 9e 00 7c 5c ' POPM    jmp #pop_m      '$23
2aa4(0024): 8d 00 7c 5c ' PSHF    jmp #push_i     '$24
2aa8(0025): d2 00 7c 5c ' RLNG    jmp #rd_long    '$25
2aac(0026): d4 00 7c 5c ' RWRD    jmp #rd_word    '$26
2ab0(0027): d6 00 7c 5c ' RBYT    jmp #rd_byte    '$27
2ab4(0028): d8 00 7c 5c ' WLNG    jmp #wr_long    '$28
2ab8(0029): da 00 7c 5c ' WWRD    jmp #wr_word    '$29
2abc(002a): dc 00 7c 5c ' WBYT    jmp #wr_byte    '$2a
2ac0(002b): 00 00 00 00 ' PC      long 0          '$2b
2ac4(002c): 00 00 00 00 ' SP      long 0          '$2c
2ac8(002d): 00 00 00 00 ' FP      long 0          '$2d
2acc(002e): 00 00 00 00 ' RI      long 0          '$2e
2ad0(002f): 00 00 00 00 ' BC      long 0          '$2f
2ad4(0030): 00 00 00 00 ' BA      long 0          '$30
2ad8(0031): 00 00 00 00 ' BZ      long 0          '$31
2adc(0032): 00 00 00 00 ' CS      long 0          '$32
2ae0(0033): 00 00 00 00 ' r0      long 0          '$33
2ae4(0034): 00 00 00 00 ' r1      long 0          '$34
2ae8(0035): 00 00 00 00 ' r2      long 0          '$35
2aec(0036): 00 00 00 00 ' r3      long 0          '$36
2af0(0037): 00 00 00 00 ' r4      long 0          '$37
2af4(0038): 00 00 00 00 ' r5      long 0          '$38
2af8(0039): 00 00 00 00 ' r6      long 0          '$39
2afc(003a): 00 00 00 00 ' r7      long 0          '$3a
2b00(003b): 00 00 00 00 ' r8      long 0          '$3b
2b04(003c): 00 00 00 00 ' r9      long 0          '$3c
2b08(003d): 00 00 00 00 ' r10     long 0          '$3d
2b0c(003e): 00 00 00 00 ' r11     long 0          '$3e
2b10(003f): 00 00 00 00 ' r12     long 0          '$3f
2b14(0040): 00 00 00 00 ' r13     long 0          '$40
2b18(0041): 00 00 00 00 ' r14     long 0          '$41
2b1c(0042): 00 00 00 00 ' r15     long 0          '$42
2b20(0043): 00 00 00 00 ' r16     long 0          '$43
2b24(0044): 00 00 00 00 ' r17     long 0          '$44
2b28(0045): 00 00 00 00 ' r18     long 0          '$45
2b2c(0046): 00 00 00 00 ' r19     long 0          '$46
2b30(0047): 00 00 00 00 ' r20     long 0          '$47
2b34(0048): 00 00 00 00 ' r21     long 0          '$48
2b38(0049): 00 00 00 00 ' r22     long 0          '$49
2b3c(004a): 00 00 00 00 ' r23     long 0          '$4a
2b40(004b): 00 00 00 80 ' Bit31   long  $80000000 '$4b
2b44(004c): ff ff ff ff ' all_1s  long  $ffffffff '$4c
2b48(004d): ff 00 00 00 ' cviu_m1 long  $000000ff '$4d
2b4c(004e): ff ff 00 00 ' cviu_m2 long  $0000ffff '$4e
2b50(004f): 00 00 00 ff ' top8    long  $ff000000 '$4f   ' top 8 bits bitmask
2b54(0050): ff ff ff 00 ' low24   long  $00ffffff '$50   ' low 24 bits bitmask
2b58(0051): 00 00 00 00 ' init_BZ long  $00000000 '$51   ' end of code / start of heap
2b5c(0052): 00 00 00 00 ' init_PC long  $00000000 '$52   ' the initial PC
2b60(0053):             ' lmm_init
2b60(0053): 01 66 fc 0c '         cogid   r0              '1 convert ...
2b64(0054): 02 66 fc 2c '         shl     r0,#2           '2 ... my cog id ...
2b68(0055): f0 67 bc 80 '         add     r0,par          '3 ... to my registration addr
2b6c(0056): 33 66 bc 08 '         rdlong  r0,r0           '4 get my request block addr
2b70(0057):             ' wait
2b70(0057): 33 60 bc 0a '         rdlong  BA,r0 wz        '5 Wait till we are given the base address ...
2b74(0058): 57 00 68 5c '   if_z  jmp     #wait           '6 .. (required to relocate segments)
2b78(0059): 04 66 fc 80 '         add     r0,#4           '7 Load our initial SP ...
2b7c(005a): 33 58 bc 08 '         rdlong  SP,r0           '8 ... from the request block
2b80(005b): 4c 63 fc a0 '         mov     BZ,#init_BZ<<2+8 '9 calculate ...
2b84(005c): 30 62 bc 80 '         add     BZ,BA           '10 ... pointer to initial BZ
2b88(005d): 31 56 bc a0 '         mov     PC,BZ           '11 load ...
2b8c(005e): 04 56 fc 80 '         add     PC,#4           '12 ... initial  ...
2b90(005f): 2b 56 bc 08 '         rdlong  PC,PC           '13 ... PC and ...
2b94(0060): 31 62 bc 08 '         rdlong  BZ,BZ           '14 ... BZ and ...
2b98(0061): 72 00 fd 5c '         call    #Reloc          '15 ... relocate segments 
2b9c(0062): 65 00 7c 5c '         jmp     #LMM_loop       '16 we can now start executing LMM code
2ba0(0063): 00 00 00 00 '         nop                     '17
2ba4(0064):             ' LMM_next
2ba4(0064): 04 56 fc 80 '         add    PC,#4
2ba8(0065):             ' LMM_loop
2ba8(0065): 2b ce bc 08 '         rdlong LMM_1,PC
2bac(0066): 04 56 fc 80 '         add    PC,#4
2bb0(0067):             ' LMM_1
2bb0(0067): 00 00 00 00 '         nop
2bb4(0068): 2b d4 bc 08 '         rdlong LMM_2,PC
2bb8(0069): 04 56 fc 80 '         add    PC,#4
2bbc(006a):             ' LMM_2
2bbc(006a): 00 00 00 00 '         nop
2bc0(006b): 2b da bc 08 '         rdlong LMM_3,PC
2bc4(006c): 04 56 fc 80 '         add    PC,#4
2bc8(006d):             ' LMM_3
2bc8(006d): 00 00 00 00 '         nop
2bcc(006e): 2b e0 bc 08 '         rdlong LMM_4,PC
2bd0(006f): 04 56 fc 80 '         add    PC,#4
2bd4(0070):             ' LMM_4
2bd4(0070): 00 00 00 00 '         nop
2bd8(0071): 65 00 7c 5c '         jmp    #LMM_loop
2bdc(0072):             ' Reloc
2bdc(0072): 31 5e bc a0 '         mov   BC,BZ         ' length of data to be relocated
2be0(0073): 03 5e fc 80 '         add   BC,#3         ' round up ...
2be4(0074): 03 5e fc 64 '         andn  BC,#3         ' ... to a multiple of 4 bytes
2be8(0075): 10 5e fc 84 '         sub   BC,#$10       ' omit first 16 bytes
2bec(0076): 10 b6 ff a0 '         mov   t2,#$10       ' destination is byte 16
2bf0(0077): 30 b4 bf a0 '         mov   t1,BA         ' source is BA ...
2bf4(0078): 10 b4 ff 80 '         add   t1,#$10       ' ... plus 16 bytes 
2bf8(0079):             ' reloc_loop
2bf8(0079): 80 5e 7c ec '        tjz    BC,#Reloc_ret ' no more to copy
2bfc(007a): da b9 bf 08 '        rdlong t3,t1         ' read from src to t3
2c00(007b): db b9 3f 08 '        wrlong t3,t2         ' write t3 to dst
2c04(007c): 04 b4 ff 80 '        add    t1,#4         ' increment source
2c08(007d): 04 b6 ff 80 '        add    t2,#4         ' increment destination
2c0c(007e): 04 5e fc 84 '        sub    BC,#4         ' decrement count ...
2c10(007f): 79 00 7c 5c '        jmp    #reloc_loop   ' ... and keep copying
2c14(0080):             ' Reloc_ret
2c14(0080): 00 00 7c 5c '        ret        
2c18(0081):             ' load_l
2c18(0081): 2b 5c bc 08 '        rdlong RI,PC         ' load the long value
2c1c(0082): 64 00 7c 5c '        jmp    #LMM_next     ' increment PC, execute next instruction
2c20(0083):             ' load_a
2c20(0083): 2b 5c bc 08 '        rdlong RI,PC         ' load the address
2c24(0084): 64 00 7c 5c '        jmp    #LMM_next     ' increment PC, execute next instruction
2c28(0085):             ' fp_ind
2c28(0085): 2b 5c bc 08 '        rdlong RI,PC         ' load the long value
2c2c(0086): 2d 5c bc d0 '        adds   RI,FP         ' add the frame pointer
2c30(0087): 64 00 7c 5c '        jmp    #LMM_next     ' increment PC, execute next instruction
2c34(0088):             ' push_l
2c34(0088): 04 58 fc 84 '        sub    SP,#4         ' decrement SP
2c38(0089): 2c 5c 3c 08 '        wrlong RI,SP         ' save value on stack
2c3c(008a): 65 00 7c 5c '        jmp    #LMM_loop     ' increment PC, execute next instruction
2c40(008b):             ' push_a
2c40(008b): 2b 5c bc 08 '        rdlong RI,PC         ' load the address
2c44(008c): 8f 00 7c 5c '        jmp    #push_x       ' use the result as an address of the value to push
2c48(008d):             ' push_i
2c48(008d): 2b 5c bc 08 '        rdlong RI,PC         ' load the long value
2c4c(008e): 2d 5c bc d0 '        adds   RI,FP         ' add the frame pointer
2c50(008f):             ' push_x
2c50(008f): 2e 5c bc 08 '        rdlong RI,RI         ' read the value at that address
2c54(0090): 04 58 fc 84 '        sub    SP,#4         ' decrement SP
2c58(0091): 2c 5c 3c 08 '        wrlong RI,SP         ' save value on stack
2c5c(0092): 64 00 7c 5c '        jmp    #LMM_next     ' increment PC, execute next instruction
2c60(0093):             ' push_m
2c60(0093): 2b 5c bc 08 '        rdlong RI,PC         ' load the long value specifying the registers to push
2c64(0094): 39 32 fd 54 '        movd   :push_x,#r6   ' start with ...
2c68(0095): 06 5c fc 28 '        shr    RI,#6         ' ... r6
2c6c(0096): 12 b4 ff a0 '        mov    t1,#18        ' we will push up to 18 registers (up to R24)
2c70(0097):             ' :push_nxt
2c70(0097): 01 5c fc 2b '        shr    RI,#1 wc,wz   ' save rx?
2c74(0098): 04 58 f0 84 '  if_c  sub    SP,#4         ' if so ...
2c78(0099):             ' :push_x                     ' ... save ...
2c78(0099): 2c 00 30 08 '  if_c  wrlong 0,SP          ' ... the register
2c7c(009a): 64 00 68 5c '  if_z  jmp    #LMM_next     ' no more to save
2c80(009b): d9 33 bd 80 '        add    :push_x,dlsb  ' point to next register
2c84(009c): 97 b4 ff e4 '        djnz   t1,#:push_nxt ' continue till all 24 registers checked
2c88(009d): 64 00 7c 5c '        jmp    #LMM_next     ' increment PC, execute next instruction
2c8c(009e):             ' pop_m
2c8c(009e): 2b 5c bc 08 '        rdlong RI,PC         ' load the long value specifying the registers to push
2c90(009f): 4a 46 fd 54 '        movd   :pop_x,#r23   ' start with ...
2c94(00a0): 08 5c fc 2c '        shl    RI,#(32-24)   ' ... r23         
2c98(00a1): 12 b4 ff a0 '        mov    t1,#18        ' we will pop up to 18 registers (down to r6)
2c9c(00a2):             ' :pop_nxt
2c9c(00a2): 01 5c fc 2f '        shl    RI,#1 wc,wz   ' load rx?
2ca0(00a3):             ' :pop_x                      ' if so ...
2ca0(00a3): 2c 00 b0 08 '  if_c  rdlong 0,SP          ' ... load ...
2ca4(00a4): 04 58 f0 80 '  if_c  add    SP,#4         ' ... the register
2ca8(00a5): 64 00 68 5c '  if_z  jmp    #LMM_next
2cac(00a6): d9 47 bd 84 '        sub    :pop_x,dlsb   ' point to previous register
2cb0(00a7): a2 b4 ff e4 '        djnz   t1,#:pop_nxt  ' continue till all 24 registers checked
2cb4(00a8): 64 00 7c 5c '        jmp    #LMM_next     ' increment PC, execute next instruction
2cb8(00a9):             ' push_b
2cb8(00a9): 2b 5e bc 08 '        rdlong BC,PC         ' load the byte count
2cbc(00aa): 04 56 fc 80 '        add    PC,#4         ' increment the PC
2cc0(00ab): 03 5e fc 80 '        add    BC,#3         ' round up BC ...
2cc4(00ac): 03 5e fc 64 '        andn   BC,#3         ' ... to be a multiple of 4
2cc8(00ad): 2f 58 bc 84 '        sub    SP,BC         ' decrement SP by rounded up size
2ccc(00ae): 33 b4 bf a0 '        mov    t1,R0         ' source is in R0
2cd0(00af): 2c b6 bf a0 '        mov    t2,SP         ' destination is SP
2cd4(00b0): b7 00 7c 5c '        jmp    #copy_longs   ' do the copy
2cd8(00b1):             ' copy_b
2cd8(00b1): 2b 5e bc 08 '        rdlong BC,PC         ' load the byte count
2cdc(00b2): 04 56 fc 80 '        add    PC,#4         ' increment the PC
2ce0(00b3): 03 5e fc 80 '        add    BC,#3         ' round up BC ...
2ce4(00b4): 03 5e fc 64 '        andn   BC,#3         ' ... to be a multiple of 4
2ce8(00b5): 34 b4 bf a0 '        mov    t1,R1         ' source is in R1
2cec(00b6): 33 b6 bf a0 '        mov    t2,R0         ' destination is in R0
2cf0(00b7):             ' copy_longs
2cf0(00b7): 65 5e 7c ec '        tjz    BC,#LMM_Loop  ' no more to copy
2cf4(00b8): da b9 bf 08 '        rdlong t3,t1         ' read from src to t3
2cf8(00b9): db b9 3f 08 '        wrlong t3,t2         ' write t3 to dst
2cfc(00ba): 04 b4 ff 80 '        add    t1,#4         ' increment source
2d00(00bb): 04 b6 ff 80 '        add    t2,#4         ' increment destination
2d04(00bc): 04 5e fc 84 '        sub    BC,#4         ' decrement count ...
2d08(00bd): b7 00 7c 5c '        jmp    #copy_longs   ' ... and keep copying
2d0c(00be):             ' new_fp
2d0c(00be): 04 58 fc 84 '        sub     SP,#4         ' decrement the stack pointer
2d10(00bf): 2c 5a 3c 08 '        wrlong FP,SP         ' save FP to stack
2d14(00c0): 2c 5a bc a0 '        mov    FP,SP         ' set up new FP
2d18(00c1): 08 5e fc 80 '        add    BC,#8         ' calculate what SP was ...
2d1c(00c2): 2d 5e bc 80 '        add    BC,FP         ' ... before arguments were pushed
2d20(00c3): 65 00 7c 5c '        jmp    #LMM_loop     ' execute the next instruction
2d24(00c4):             ' fp_ret
2d24(00c4): 2c 5a bc 08 '        rdlong FP,SP         ' restore previous FP
2d28(00c5): 04 58 fc 80 '        add    SP,#4         ' increment the SP
2d2c(00c6):             ' f_ret
2d2c(00c6): 2c 56 bc 08 '        rdlong PC,SP         ' read the PC
2d30(00c7): 04 58 fc 80 '        add    SP,#4         ' increment the SP
2d34(00c8): 65 00 7c 5c '        jmp    #LMM_loop     ' execute the next instruction
2d38(00c9):             ' f_call                    
2d38(00c9): 2b 5c bc 08 '        rdlong RI,PC         ' get the address to call
2d3c(00ca): 04 56 fc 80 '        add    PC,#4         ' increment the PC (this is the return address)
2d40(00cb):             ' f_cali
2d40(00cb): 04 58 fc 84 '        sub    SP,#4         ' decrement the SP
2d44(00cc): 2c 56 3c 08 '        wrlong PC,SP         ' save current PC to stack
2d48(00cd): d0 00 7c 5c '        jmp    #f_jmpi       ' jump to location in RI
2d4c(00ce):             ' f_jump
2d4c(00ce): 2b 56 bc 08 '        rdlong PC,PC         ' get the address to jump to
2d50(00cf): 65 00 7c 5c '        jmp    #LMM_loop     ' execute next instruction
2d54(00d0):             ' f_jmpi
2d54(00d0): 2e 56 bc a0 '        mov    PC,RI         ' get the address to jump to
2d58(00d1): 65 00 7c 5c '        jmp    #LMM_loop     ' execute next instruction
2d5c(00d2):             ' rd_long
2d5c(00d2): 2e 5e bc 08 '         rdlong  BC,RI
2d60(00d3): 64 00 7c 5c '         jmp     #LMM_Next
2d64(00d4):             ' rd_word
2d64(00d4): 2e 5e bc 04 '         rdword  BC,RI
2d68(00d5): 64 00 7c 5c '         jmp     #LMM_Next
2d6c(00d6):             ' rd_byte
2d6c(00d6): 2e 5e bc 00 '         rdbyte  BC,RI
2d70(00d7): 64 00 7c 5c '         jmp     #LMM_Next
2d74(00d8):             ' wr_long
2d74(00d8): 2e 5e 3c 08 '         wrlong  BC,RI
2d78(00d9): 64 00 7c 5c '         jmp     #LMM_Next
2d7c(00da):             ' wr_word
2d7c(00da): 2e 5e 3c 04 '         wrword  BC,RI
2d80(00db): 64 00 7c 5c '         jmp     #LMM_Next
2d84(00dc):             ' wr_byte
2d84(00dc): 2e 5e 3c 00 '         wrbyte  BC,RI
2d88(00dd): 64 00 7c 5c '         jmp     #LMM_Next
2d8c(00de):             ' f_d32s
2d8c(00de): 20 b4 ff a0 '         mov  t1,#32
2d90(00df): 00 b6 ff a0 '         mov  t2,#0           ' tmp2 is temp register to hold the remainder
2d94(00e0): 34 c6 bf a0 '         mov  ftemp,r1
2d98(00e1): 33 c8 bf a0 '         mov  ftmp2,r0
2d9c(00e2): 34 68 bc a8 '         abs  r1, r1
2da0(00e3): 33 66 bc a8 '         abs  r0, r0
2da4(00e4): e4 c7 bf 6c '         xor  ftemp, ftmp2
2da8(00e5):             ' :loop
2da8(00e5): 01 66 fc 2d '         shl  r0,#1 WC
2dac(00e6): 01 b6 ff 35 '         rcl  t2,#1 WC
2db0(00e7): 34 b6 bf e3 '         cmpsub t2,r1 WC,WZ
2db4(00e8): 01 66 f8 80 '  if_be add  r0,#1
2db8(00e9): e5 b4 ff e4 '         djnz t1,#:loop
2dbc(00ea): db 69 bc a0 '         mov  r1,t2
2dc0(00eb): e4 c9 bf a1 '         mov  ftmp2,ftmp2 WC  ' get bit #31 into carry
2dc4(00ec): 34 68 bc b0 '         negc r1,r1                   ' adjust the sign of the remainder
2dc8(00ed): e3 c7 bf a1 '         mov  ftemp,ftemp WC  ' get bit #31 into carry
2dcc(00ee): 33 66 bc b0 '         negc r0,r0                   ' adjust the sign of the result
2dd0(00ef): 65 00 7c 5c '         jmp  #LMM_loop
2dd4(00f0):             ' f_d32u
2dd4(00f0): 20 c6 ff a0 '         mov ftemp,#32
2dd8(00f1): 00 c8 ff a0 '         mov ftmp2, #0
2ddc(00f2):             ' :up2
2ddc(00f2): 01 66 fc 2d '         shl r0,#1       WC
2de0(00f3): 01 c8 ff 35 '         rcl ftmp2,#1    WC
2de4(00f4): e4 69 3c 87 '         cmp r1,ftmp2    WC,WZ
2de8(00f5): f8 00 44 5c '  if_a   jmp #:down
2dec(00f6): 34 c8 bf 84 '         sub ftmp2,r1
2df0(00f7): 01 66 fc 80 '         add r0,#1
2df4(00f8):             ' :down
2df4(00f8): 01 c6 ff 86 '         sub ftemp, #1   WZ
2df8(00f9): f2 00 54 5c '  if_ne  jmp #:up2
2dfc(00fa): e4 69 bc a0 '         mov r1,ftmp2
2e00(00fb): 65 00 7c 5c '         jmp #LMM_loop
2e04(00fc):             ' f_m32
2e04(00fc): 00 c6 ff a0 '         mov ftemp,#0
2e08(00fd):             ' :start
2e08(00fd): 00 66 7c 86 '         cmp r0,#0       WZ
2e0c(00fe): 04 01 68 5c '  if_e   jmp #:down3
2e10(00ff): 01 66 fc 29 '         shr r0,#1       WC
2e14(0100): 02 01 4c 5c '  if_ae  jmp #:down2
2e18(0101): 34 c6 bf 81 '         add ftemp,r1    WC
2e1c(0102):             ' :down2
2e1c(0102): 01 68 fc 2d '         shl r1,#1       WC
2e20(0103): fd 00 7c 5c '         jmp #:start
2e24(0104):             ' :down3
2e24(0104): e3 67 bc a0 '         mov r0,ftemp
2e28(0105): 65 00 7c 5c '         jmp #LMM_loop
2e2c(0106):             ' bra_z
2e2c(0106): ce 00 68 5c '   if_z  jmp    #f_jump       ' if condition true, branch is equiv to jump
2e30(0107): 64 00 7c 5c '         jmp    #LMM_next     ' increment PC, execute next instruction
2e34(0108):             ' bra_nz
2e34(0108): ce 00 54 5c '  if_nz  jmp    #f_jump       ' if condition true, branch is equiv to jump
2e38(0109): 64 00 7c 5c '         jmp    #LMM_next     ' increment PC, execute next instruction
2e3c(010a):             ' bra_ae
2e3c(010a): ce 00 4c 5c '  if_ae  jmp    #f_jump       ' if condition true, branch is equiv to jump
2e40(010b): 64 00 7c 5c '         jmp    #LMM_next     ' increment PC, execute next instruction
2e44(010c):             ' bra_a
2e44(010c): ce 00 44 5c '  if_a   jmp    #f_jump       ' if condition true, branch is equiv to jump
2e48(010d): 64 00 7c 5c '         jmp    #LMM_next     ' increment PC, execute next instruction
2e4c(010e):             ' bra_be
2e4c(010e): ce 00 78 5c '  if_be  jmp    #f_jump       ' if condition true, branch is equiv to jump
2e50(010f): 64 00 7c 5c '         jmp    #LMM_next     ' increment PC, execute next instruction
2e54(0110):             ' bra_b
2e54(0110): ce 00 70 5c '  if_b   jmp    #f_jump       ' if condition true, branch is equiv to jump
2e58(0111): 64 00 7c 5c '         jmp    #LMM_next     ' increment PC, execute next instruction
2e5c(0112):             ' plugin
2e5c(0112): 36 66 bc a0 '         mov     r0,r3           ' get plugin type
2e60(0113): 80 66 7c 62 '         test    r0,#$80 wz      ' request by type?
2e64(0114): 17 01 68 5c '  if_z   jmp     #ptype          ' yes - must find plugin of this type
2e68(0115): 7f 66 fc 60 '         and     r0,#$7f         ' no - code is cog id
2e6c(0116): 23 01 7c 5c '         jmp     #pid            ' invoke plugin by cog id
2e70(0117):             ' ptype
2e70(0117): f0 b5 bf a0 '         mov     t1,par          ' no - point to registry
2e74(0118): 00 b6 ff a0 '         mov     t2,#0           ' start at cog 0
2e78(0119):             ' plgt1
2e78(0119): 08 b6 7f 87 '         cmp     t2,#8 wc,wz     ' run out of plugins?
2e7c(011a): 2f 01 4c 5c '  if_ae  jmp     #plugerr        ' yes - no such plugin
2e80(011b): da b9 bf 08 '         rdlong  t3,t1           ' no - check next plugin type
2e84(011c): 18 b8 ff 28 '         shr     t3,#24          ' is it ...
2e88(011d): 33 b8 3f 86 '         cmp     t3,r0 wz        ' ... the type what we wanted?
2e8c(011e): 22 01 68 5c '  if_z   jmp     #plgt2          ' yes - use this plugin
2e90(011f): 01 b6 ff 80 '         add     t2,#1           ' no ...
2e94(0120): 04 b4 ff 80 '         add     t1,#4           ' ... check ...
2e98(0121): 19 01 7c 5c '         jmp     #plgt1          ' ... next cog
2e9c(0122):             ' plgt2
2e9c(0122): db 67 bc a0 '         mov     r0,t2           ' use the cog where we found the plugin
2ea0(0123):             ' pid
2ea0(0123): 02 66 fc 2c '         shl     r0,#2           ' multiply plugin (cog) id by 4 ...
2ea4(0124): f0 67 bc 80 '         add     r0,par          ' add registry base to get registry entry
2ea8(0125): 33 66 bc 08 '         rdlong  r0,r0           ' get request block from registry
2eac(0126): 4f 66 3c 62 '         test    r0,top8 wz      ' plugin registered?
2eb0(0127): 2f 01 68 5c '  if_z   jmp     #plugerr        ' no - error 255
2eb4(0128): 50 66 bc 60 '         and     r0,low24        ' yes - write request ...
2eb8(0129): 33 6a 3c 08 '         wrlong  r2,r0           ' ... to request block
2ebc(012a): 33 6c bc 0a ' loop    rdlong  r3,r0   wz      ' wait till ...
2ec0(012b): 2a 01 54 5c '  if_nz  jmp     #loop           ' ... request completed
2ec4(012c): 04 66 fc 80 '         add     r0,#4           ' get results ...
2ec8(012d): 33 66 bc 08 '         rdlong  r0,r0           ' ... from request block
2ecc(012e): 65 00 7c 5c '         jmp     #LMM_loop       'done
2ed0(012f): 01 66 fc a4 ' plugerr neg     r0,#1           ' plugin not registered
2ed4(0130): 65 00 7c 5c '         jmp     #LMM_loop
2ed8(0131): 4b 68 bc 6c ' flt_sub                 xor     r1, Bit31               ' negate B
2edc(0132): 92 3b ff 5c ' flt_add                 call    #_Unpack2               ' unpack two variables
2ee0(0133): 65 00 78 5c '           if_c_or_z     jmp     #LMM_Loop               ' check for NaN or B = 0
2ee4(0134): 01 ba 7f 62 '                         test    flagA, #SignFlag wz     ' negate A mantissa if negative
2ee8(0135): df bf 97 a4 '           if_nz         neg     manA, manA
2eec(0136): 01 c0 7f 62 '                         test    flagB, #SignFlag wz     ' negate B mantissa if negative
2ef0(0137): e2 c5 97 a4 '           if_nz         neg     manB, manB
2ef4(0138): de b5 bf a0 '                         mov     t1, expA                ' align mantissas
2ef8(0139): e1 b5 bf 84 '                         sub     t1, expB
2efc(013a): da b5 bf a8 '                         abs     t1, t1
2f00(013b): 1f b4 ff 4c '                         max     t1, #31
2f04(013c): e1 bd 3f c3 '                         cmps    expA, expB wz,wc
2f08(013d): da c5 87 38 '           if_nz_and_nc  sar     manB, t1
2f0c(013e): da bf 93 38 '           if_nz_and_c   sar     manA, t1
2f10(013f): e1 bd 93 a0 '           if_nz_and_c   mov     expA, expB
2f14(0140): e2 bf bf 80 '                         add     manA, manB              ' add the two mantissas
2f18(0141): 00 be 7f c1 '                         cmps    manA, #0 wc, nr         ' set sign of result
2f1c(0142): 01 ba f3 68 '           if_c          or      flagA, #SignFlag
2f20(0143): 01 ba cf 64 '           if_nc         andn    flagA, #SignFlag
2f24(0144): df bf bf a8 '                         abs     manA, manA              ' pack result and exit
2f28(0145): bc a9 ff 5c '                         call    #_Pack
2f2c(0146): 65 00 7c 5c '                         jmp     #LMM_Loop
2f30(0147): 92 3b ff 5c ' flt_mul                 call    #_Unpack2               ' unpack two variables
2f34(0148): 65 00 70 5c '           if_c          jmp     #LMM_Loop               ' check for NaN
2f38(0149): e0 bb bf 6c '                         xor     flagA, flagB            ' get sign of result
2f3c(014a): e1 bd bf 80 '                         add     expA, expB              ' add exponents
2f40(014b): 00 b4 ff a0 '                         mov     t1, #0                  ' t2 = upper 32 bits of manB
2f44(014c): 20 b6 ff a0 '                         mov     t2, #32                 ' loop counter for multiply
2f48(014d): 01 c4 ff 29 '                         shr     manB, #1 wc             ' get initial multiplier bit
2f4c(014e): df b5 b3 81 ' :multiply if_c          add     t1, manA wc             ' 32x32 bit multiply
2f50(014f): 01 b4 ff 31 '                         rcr     t1, #1 wc
2f54(0150): 01 c4 ff 31 '                         rcr     manB, #1 wc
2f58(0151): 4e b7 ff e4 '                         djnz    t2, #:multiply
2f5c(0152): 03 b4 ff 2c '                         shl     t1, #3                  ' justify result and exit
2f60(0153): da bf bf a0 '                         mov     manA, t1
2f64(0154): bc a9 ff 5c '                         call    #_Pack
2f68(0155): 65 00 7c 5c '                         jmp     #LMM_Loop
2f6c(0156): 92 3b ff 5c ' flt_div                 call    #_Unpack2               ' unpack two variables
2f70(0157): d5 67 b8 a0 '           if_c_or_z     mov     r0, NaN                 ' check for NaN or divide by 0
2f74(0158): 65 00 78 5c '           if_c_or_z     jmp     #LMM_Loop
2f78(0159): e0 bb bf 6c '                         xor     flagA, flagB            ' get sign of result
2f7c(015a): e1 bd bf 84 '                         sub     expA, expB              ' subtract exponents
2f80(015b): 00 b4 ff a0 '                         mov     t1, #0                  ' clear quotient
2f84(015c): 1e b6 ff a0 '                         mov     t2, #30                 ' loop counter for divide
2f88(015d): 01 b4 ff 2c ' :divide                 shl     t1, #1                  ' divide the mantissas
2f8c(015e): e2 bf 3f c3 '                         cmps    manA, manB wz,wc
2f90(015f): e2 bf af 84 '           if_z_or_nc    sub     manA, manB
2f94(0160): 01 b4 ef 80 '           if_z_or_nc    add     t1, #1
2f98(0161): 01 be ff 2c '                         shl     manA, #1
2f9c(0162): 5d b7 ff e4 '                         djnz    t2, #:divide
2fa0(0163): da bf bf a0 '                         mov     manA, t1                ' get result and exit
2fa4(0164): bc a9 ff 5c '                         call    #_Pack
2fa8(0165): 65 00 7c 5c '                         jmp     #LMM_Loop
2fac(0166): 33 ba bf a0 ' flt_int                 mov     flagA, r0               ' get integer value
2fb0(0167): 00 66 fc a0 '                         mov     r0, #0                  ' set initial result to zero
2fb4(0168): dd bf bf aa '                         abs     manA, flagA wz          ' get absolute value of integer
2fb8(0169): 65 00 68 5c '           if_z          jmp     #LMM_Loop               ' if zero, exit
2fbc(016a): 1f ba ff 28 '                         shr     flagA, #31              ' set sign flag
2fc0(016b): 1f bc ff a0 '                         mov     expA, #31               ' set initial value for exponent
2fc4(016c): 01 be ff 2d ' :normalize              shl     manA, #1 wc             ' normalize the mantissa
2fc8(016d): 01 bc cf 84 '           if_nc         sub     expA, #1                ' adjust exponent
2fcc(016e): 6c 01 4c 5c '           if_nc         jmp     #:normalize
2fd0(016f): 01 be ff 30 '                         rcr     manA, #1                ' justify mantissa
2fd4(0170): 02 be ff 28 '                         shr     manA, #2
2fd8(0171): bc a9 ff 5c '                         call    #_Pack                  ' pack and exit
2fdc(0172): 65 00 7c 5c '                         jmp     #LMM_Loop
2fe0(0173): 00 b4 ff a0 ' int_flt                 mov     t1, #0                  ' set for no rounding
2fe4(0174): 9e 77 ff 5c ' fix                     call    #_Unpack                ' unpack floating point value
2fe8(0175): 65 00 70 5c '           if_c          jmp     #LMM_Loop               ' check for NaN
2fec(0176): 02 be ff 2c '                         shl     manA, #2                ' left justify mantissa
2ff0(0177): 00 66 fc a0 '                         mov     r0, #0                  ' initialize result to zero
2ff4(0178): de bd bf a4 '                         neg     expA, expA              ' adjust for exponent value
2ff8(0179): 1e bc ff 82 '                         add     expA, #30 wz
2ffc(017a): 20 bc 7f c1 '                         cmps    expA, #32 wc
3000(017b): 65 00 6c 5c '           if_nc_or_z    jmp     #LMM_Loop
3004(017c): de bf bf 28 '                         shr     manA, expA
3008(017d): da bf bf 80 '                         add     manA, t1                ' round up 1/2 lsb
300c(017e): 01 be ff 28 '                         shr     manA, #1
3010(017f): 01 ba 7f 62 '                         test    flagA, #signFlag wz     ' check sign and exit
3014(0180): df 67 bc 9c '                         sumnz   r0, manA
3018(0181): 65 00 7c 5c '                         jmp     #LMM_Loop
301c(0182): 33 b4 bf a0 ' flt_cmp                 mov     t1, r0               ' compare signs
3020(0183): 34 b4 bf 6c '                         xor     t1, r1
3024(0184): 4b b4 bf 62 '                         and     t1, Bit31 wz
3028(0185): 8c 01 68 5c '           if_z          jmp     #:cmp1                  ' same, then compare magnitude
302c(0186): 33 b4 bf a0 '                         mov     t1, r0               ' check for +0 or -0
3030(0187): 34 b4 bf 68 '                         or      t1, r1
3034(0188): 4b b4 bf 67 '                         andn    t1, Bit31 wz,wc
3038(0189): 65 00 68 5c '           if_z          jmp     #LMM_Loop
303c(018a): 4b 66 3c 61 '                         test    r0, Bit31 wc         ' compare signs
3040(018b): 65 00 7c 5c '                         jmp     #LMM_Loop
3044(018c): 4b 66 3c 62 ' :cmp1                   test    r0, Bit31 wz         ' check signs
3048(018d): 90 01 54 5c '           if_nz         jmp     #:cmp2
304c(018e): 34 66 3c 87 '                         cmp     r0, r1 wz,wc
3050(018f): 65 00 7c 5c '                         jmp     #LMM_Loop
3054(0190): 33 68 3c 87 ' :cmp2                   cmp     r1, r0 wz,wc      ' reverse test if negative
3058(0191): 65 00 7c 5c '                         jmp     #LMM_Loop
305c(0192): 33 b4 bf a0 ' _Unpack2                mov     t1, r0               ' save A
3060(0193): 34 66 bc a0 '                         mov     r0, r1            ' unpack B to A
3064(0194): 9e 77 ff 5c '                         call    #_Unpack
3068(0195): 9d 01 70 5c '           if_c          jmp     #_Unpack2_ret           ' check for NaN
306c(0196): 33 68 bc a0 '                         mov     r1, r0            ' save B variables
3070(0197): dd c1 bf a0 '                         mov     flagB, flagA
3074(0198): de c3 bf a0 '                         mov     expB, expA
3078(0199): df c5 bf a0 '                         mov     manB, manA
307c(019a): da 67 bc a0 '                         mov     r0, t1               ' unpack A
3080(019b): 9e 77 ff 5c '                         call    #_Unpack
3084(019c): 00 c4 7f 86 '                         cmp     manB, #0 wz             ' set Z flag
3088(019d): 00 00 7c 5c ' _Unpack2_ret            ret
308c(019e): 33 ba bf a0 ' _Unpack                 mov     flagA, r0            ' get sign
3090(019f): 1f ba ff 28 '                         shr     flagA, #31
3094(01a0): 33 be bf a0 '                         mov     manA, r0             ' get mantissa
3098(01a1): d7 bf bf 60 '                         and     manA, Mask23
309c(01a2): 33 bc bf a0 '                         mov     expA, r0             ' get exponent
30a0(01a3): 01 bc ff 2c '                         shl     expA, #1
30a4(01a4): 18 bc ff 2a '                         shr     expA, #24 wz
30a8(01a5): ab 01 68 5c '           if_z          jmp     #:zeroSubnormal         ' check for zero or subnormal
30ac(01a6): ff bc 7f 86 '                         cmp     expA, #255 wz           ' check if finite
30b0(01a7): b6 01 54 5c '           if_nz         jmp     #:finite
30b4(01a8): d5 67 bc a0 '                         mov     r0, NaN              ' no, then return NaN
30b8(01a9): 08 ba ff a0 '                         mov     flagA, #NaNFlag
30bc(01aa): b9 01 7c 5c '                         jmp     #:exit2
30c0(01ab): de bf 3f 6a ' :zeroSubnormal          or      manA, expA wz,nr        ' check for zero
30c4(01ac): b0 01 54 5c '           if_nz         jmp     #:subnorm
30c8(01ad): 02 ba ff 68 '                         or      flagA, #ZeroFlag        ' yes, then set zero flag
30cc(01ae): 96 bc ff a4 '                         neg     expA, #150              ' set exponent and exit
30d0(01af): b9 01 7c 5c '                         jmp     #:exit2
30d4(01b0): 07 be ff 2c ' :subnorm                shl     manA, #7                ' fix justification for subnormals
30d8(01b1): d8 bf 3f 62 ' :subnorm2               test    manA, Bit29 wz
30dc(01b2): b8 01 54 5c '           if_nz         jmp     #:exit1
30e0(01b3): 01 be ff 2c '                         shl     manA, #1
30e4(01b4): 01 bc ff 84 '                         sub     expA, #1
30e8(01b5): b1 01 7c 5c '                         jmp     #:subnorm2
30ec(01b6): 06 be ff 2c ' :finite                 shl     manA, #6                ' justify mantissa to bit 29
30f0(01b7): d8 bf bf 68 '                         or      manA, Bit29             ' add leading one bit
30f4(01b8): 7f bc ff 84 ' :exit1                  sub     expA, #127              ' remove bias from exponent
30f8(01b9): 08 ba 7f 61 ' :exit2                  test    flagA, #NaNFlag wc      ' set C flag
30fc(01ba): 00 be 7f 86 '                         cmp     manA, #0 wz             ' set Z flag
3100(01bb): 00 00 7c 5c ' _Unpack_ret             ret
3104(01bc): 00 be 7f 86 ' _Pack                   cmp     manA, #0 wz             ' check for zero
3108(01bd): 00 bc eb a0 '           if_z          mov     expA, #0
310c(01be): cf 01 68 5c '           if_z          jmp     #:exit1
3110(01bf): 01 be ff 2d ' :normalize              shl     manA, #1 wc             ' normalize the mantissa
3114(01c0): 01 bc cf 84 '           if_nc         sub     expA, #1                ' adjust exponent
3118(01c1): bf 01 4c 5c '           if_nc         jmp     #:normalize
311c(01c2): 02 bc ff 80 '                         add     expA, #2                ' adjust exponent
3120(01c3): 00 bf ff 81 '                         add     manA, #$100 wc          ' round up by 1/2 lsb
3124(01c4): 01 bc f3 80 '           if_c          add     expA, #1
3128(01c5): 7f bc ff 80 '                         add     expA, #127              ' add bias to exponent
312c(01c6): d6 bd bf 40 '                         mins    expA, Minus23
3130(01c7): ff bc ff 44 '                         maxs    expA, #255
3134(01c8): 01 bc 7f c1 '                         cmps    expA, #1 wc             ' check for subnormals
3138(01c9): cf 01 4c 5c '           if_nc         jmp     #:exit1
313c(01ca): 01 be ff 68 ' :subnormal              or      manA, #1                ' adjust mantissa
3140(01cb): 01 be ff 20 '                         ror     manA, #1
3144(01cc): de bd bf a4 '                         neg     expA, expA
3148(01cd): de bf bf 28 '                         shr     manA, expA
314c(01ce): 00 bc ff a0 '                         mov     expA, #0                ' biased exponent = 0
3150(01cf): df 67 bc a0 ' :exit1                  mov     r0, manA             ' bits 22:0 mantissa
3154(01d0): 09 66 fc 28 '                         shr     r0, #9
3158(01d1): de 67 bc 58 '                         movi    r0, expA             ' bits 23:30 exponent
315c(01d2): 1f ba ff 2c '                         shl     flagA, #31
3160(01d3): dd 67 bc 68 '                         or      r0, flagA            ' bit 31 sign
3164(01d4): 00 00 7c 5c ' _Pack_ret               ret
3168(01d5): ff ff ff 7f ' NaN                     long    $7FFF_FFFF
316c(01d6): e9 ff ff ff ' Minus23                 long    -23
3170(01d7): ff ff 7f 00 ' Mask23                  long    $007F_FFFF
3174(01d8): 00 00 00 20 ' Bit29                   long    $2000_0000
3178(01d9): 00 02 00 00 ' dlsb                    long    1 << 9
317c(01da):             ' t1                      res     1                       ' temporary values
317c(01db):             ' t2                      res     1
317c(01dc):             ' t3                      res     1
317c(01dd):             ' flagA                   res     1
317c(01de):             ' expA                    res     1
317c(01df):             ' manA                    res     1
317c(01e0):             ' flagB                   res     1
317c(01e1):             ' expB                    res     1
317c(01e2):             ' manB                    res     1
317c(01e3):             ' ftemp                   res     1
317c(01e4):             ' ftmp2                   res     1
317c(01eb):             '               org       $1eb
317c(01eb): 00 00 00 00 ' DEBUG_VECTORS long      0,0,0,0,0
3180(01ec): 00 00 00 00 ' 
3184(01ed): 00 00 00 00 ' 
3188(01ee): 00 00 00 00 ' 
318c(01ef): 00 00 00 00 ' 
'========================= Method #1: PUB Entry_Addr ==========================
'PUB Entry_Addr : addr
'------------------------------------------------------------------------------
   addr := @entry ' Kernel Entry Address
'------------------------------------------------------------------------------
3190: c7 0c          PUSH#.L	OBJ+12
3192: 61             POP  	Locals+0
3193: 32             RETURN	
'============================ Method #2: PUB Run ==============================
'PUB Run (registry, request, Initial_BA, Initial_SP) : cog
'------------------------------------------------------------------------------
  long[request][2 * cogid + 1] := Initial_SP
'------------------------------------------------------------------------------
3194: 70             PUSH 	Locals+16
3195: 68             PUSH 	Locals+8
3196: 37 00          PUSH#kp	2 ($2)
3198: 3f 89          REGPUSH	$89?
319a: f4             MPY  	
319b: 36             PUSH#1	
319c: ec             ADD  	
319d: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[request][2 * cogid]     := Initial_BA
'------------------------------------------------------------------------------
319e: 6c             PUSH 	Locals+12
319f: 68             PUSH 	Locals+8
31a0: 37 00          PUSH#kp	2 ($2)
31a2: 3f 89          REGPUSH	$89?
31a4: f4             MPY  	
31a5: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  coginit(cogid, @entry, registry)
'------------------------------------------------------------------------------
31a6: 3f 89          REGPUSH	$89?
31a8: c7 0c          PUSH#.L	OBJ+12
31aa: 64             PUSH 	Locals+4
31ab: 2c             COGISUB	
31ac: 32             RETURN	
31ad: 00 00 00    

'******************************************************************************
'                         Catalina_HMI_Plugin_PC.spin                          
'******************************************************************************

'=================================== CONs =====================================
cols = 40
rows = 13
chrs = 520
sc_count = 281
nx = 0
ny = 1
buffer = 3
DATASIZE = 296
'=============================== Object Header ================================
31b0: 38 04 03 03 ' 1080 bytes, 3-1 methods, 3 object pointers
31b4: c4 03 00 00 ' ptr #1 to $3574: PUB ProxySetup (locals size: 0)
31b8: cb 03 34 00 ' ptr #2 to $357b: PUB Start (locals size: 52)
31bc: 38 04 0c 00 ' ptr #3 to $35e8: OBJ kbd : Catalina_PC_Keyboard.spin (VAR offset: 12)
31c0: 30 05 0c 00 ' ptr #4 to $36e0: OBJ screen : Catalina_PC_Text.spin (VAR offset: 12)
31c4: f8 05 0c 00 ' ptr #5 to $37a8: OBJ common : Catalina_Common.spin (VAR offset: 12)
'================================ DAT Section =================================
31c8(0000):             '         org     0
31c8(0000):             ' HmiStart
31c8(0000): 01 e0 fd 0c '         cogid   t1              ' calculate ...
31cc(0001): 02 e0 fd 2c '         shl     t1,#2           ' ... my ...
31d0(0002): f0 e1 bd 80 '         add     t1,par          ' ... request ...
31d4(0003): f0 d6 bd 08 '         rdlong  rqstptr,t1      ' ... block ...
31d8(0004): e2 d6 bd 60 '         and     rqstptr,low24   ' ... address
31dc(0005): eb d8 bd a0 '         mov     rsltptr,rqstptr ' calculate ...
31e0(0006): 04 d8 fd 80 '         add     rsltptr,#4      ' ... my result address
31e4(0007):             ' loop
31e4(0007): eb da bd 0a '         rdlong  rqst,rqstptr wz ' wait ...
31e8(0008): 07 00 68 5c '   if_z  jmp     #loop           ' ... for a request
31ec(0009): ed e0 bd a0 '         mov     t1,rqst
31f0(000a): 18 e0 fd 28 '         shr     t1,#24
31f4(000b): 20 e0 7d 87 '         cmp     t1,#32 wz,wc
31f8(000c): a1 00 44 5c '   if_a  jmp     #done_bad
31fc(000d): 02 e0 fd 20 '         ror     t1,#2           ' lookup code address
3200(000e): 16 e0 fd 80 '         add     t1,#svctable
3204(000f): f0 24 bc 50 '         movs    :table,t1
3208(0010): 02 e0 fd 24 '         rol     t1,#2
320c(0011): 03 e0 fd 2c '         shl     t1,#3
3210(0012): 00 e2 bd a0 ' :table  mov     t2,0
3214(0013): f0 e2 bd 28 '         shr     t2,t1
3218(0014): ff e2 fd 60 '         and     t2,#$FF
321c(0015): f1 00 3c 5c '         jmp     t2              ' jump to code routine
3220(0016):             ' svctable
3220(0016): 1f          '         byte    initialize      ' 0
3221(----): 38          '         byte    k_present       ' 1 
3222(----): 3b          '         byte    k_get           ' 2
3223(----): 47          '         byte    k_wait          ' 3
3224(0017): 43          '         byte    k_new           ' 4
3225(----): 4a          '         byte    k_ready         ' 5
3226(----): 4e          '         byte    k_clear         ' 6
3227(----): 3a          '         byte    k_state         ' 7 
3228(0018): a1          '         byte    done_bad        ' 8
3229(----): a1          '         byte    done_bad        ' 9
322a(----): a1          '         byte    done_bad        '10
322b(----): a3          '         byte    done_ok         '11 m_present ignored
322c(0019): a3          '         byte    done_ok         '12 m_button ignored  
322d(----): a3          '         byte    done_ok         '13 m_buttons ignored 
322e(----): a3          '         byte    done_ok         '14 m_abs_x ignored   
322f(----): a3          '         byte    done_ok         '15 m_abs_y ignored   
3230(001a): a3          '         byte    done_ok         '16 m_abs_z ignored   
3231(----): a3          '         byte    done_ok         '17 m_delta_x ignored 
3232(----): a3          '         byte    done_ok         '18 m_delta_y ignored 
3233(----): a3          '         byte    done_ok         '19 m_delta_z ignored 
3234(001b): a3          '         byte    done_ok         '20 m_reset ignored   
3235(----): 52          '         byte    t_geometry      '21
3236(----): 56          '         byte    t_char          '22
3237(----): 5f          '         byte    t_string        '23
3238(001c): 6a          '         byte    t_int           '24
3239(----): 8b          '         byte    t_unsigned      '25
323a(----): 8d          '         byte    t_hex           '26
323b(----): 98          '         byte    t_bin           '27
323c(001d): a3          '         byte    done_ok         '28 t_setpos ignored
323d(----): a3          '         byte    done_ok         '29 t_getpos ignored
323e(----): a3          '         byte    done_ok         '30 t_mode ignored
323f(----): a3          '         byte    done_ok         '31 t_scroll ignored
3240(001e): a3          '         byte    done_ok         '32 t_color ignored
3241(----): 00 00 00    
3244(001f):             '         long                    ' align long
3244(001f):             ' initialize
3244(001f): ed f4 bd 08 '         rdlong  ppkbd,rqst      ' save pointer to keyboard parameters
3248(0020): 04 da fd 80 '         add     rqst,#4         ' save pointer to ...
324c(0021): ed f6 bd 08 '         rdlong  ppmouse,rqst    ' ... mouse params
3250(0022): 04 da fd 80 '         add     rqst,#4         ' save pointer to ...
3254(0023): ed f8 bd 08 '         rdlong  ppscrn,rqst     ' ... screen parameters
3258(0024): 04 da fd 80 '         add     rqst,#4         ' save pointer to ...
325c(0025): ed fa bd 08 '         rdlong  pptv,rqst       ' ... tv parameters
3260(0026): fc de bd a0 '         mov     t0,ppscrn       ' get ...
3264(0027): ef e0 bd 08 '         rdlong  t1,t0           ' ... screen ...
3268(0028): f0 fc bd a0 '         mov     scrcols,t1      ' ... cols
326c(0029): 04 de fd 80 '         add     t0,#4           ' get ...
3270(002a): ef e2 bd 08 '         rdlong  t2,t0           ' ... screen ...
3274(002b): f1 fe bd a0 '         mov     scrrows,t2      ' ... rows
3278(002c): cf a6 fd 5c '         call    #m32            ' multiply rows by cols
327c(002d): ef 00 be a0 '         mov     scrsize,t0      ' save as acreen size
3280(002e): fc 04 be a0 '         mov     scrclrs,ppscrn  ' calculate ...
3284(002f): 08 04 fe 80 '         add     scrclrs,#8      ' ... screen color address
3288(0030): fc 02 be a0 '         mov     scrbuff,ppscrn  ' calculate ...
328c(0031): 0c 02 fe 80 '         add     scrbuff,#12     ' ... screen buffer address
3290(0032): 01 07 be a0 '         mov     scrpall,scrbuff ' calculate ...
3294(0033): 00 07 be 80 '         add     scrpall,scrsize ' ... palette ...
3298(0034): 00 07 be 80 '         add     scrpall,scrsize ' ... address
329c(0035): 03 09 be a0 '         mov     scrcurs,scrpall ' calculate ...
32a0(0036): 40 08 fe 80 '         add     scrcurs,#64     ' ... screen cursors address
32a4(0037): a3 00 7c 5c '         jmp     #done_ok
32a8(0038):             ' k_present
32a8(0038): 01 dc fd a0 '         mov     rslt,#1         ' presume ...
32ac(0039): a4 00 7c 5c '         jmp     #done           ' ... always present
32b0(003a):             ' k_state
32b0(003a): a3 00 7c 5c '         jmp     #done_ok        ' ignore        
32b4(003b):             ' k_get
32b4(003b): af 72 fd 5c '         call    #k_load         ' load key pointed to by par_tail
32b8(003c): a3 00 68 5c '    if_z jmp     #done_ok        ' Z set if no key available
32bc(003d):             ' k_consume
32bc(003d): 01 e0 fd 80 '         add     t1,#1           ' increment ...
32c0(003e): 0f e0 fd 60 '         and     t1,#$f          ' ...
32c4(003f): fa de bd a0 '         mov     t0,ppkbd        ' ...
32c8(0040): 04 de fd 80 '         add     t0,#4           ' ...
32cc(0041): ef e0 3d 08 '         wrlong  t1,t0           ' ... par_tail
32d0(0042): a4 00 7c 5c '         jmp     #done
32d4(0043): a8 5c fd 5c ' k_new   call    #k_setup        ' setup common values
32d8(0044): fa de bd a0 '         mov     t0,ppkbd        ' set par_tail ...
32dc(0045): 04 de fd 80 '         add     t0,#4           ' ... to ...
32e0(0046): ef e2 3d 08 '         wrlong  t2,t0           ' ... par_head
32e4(0047):             ' k_wait
32e4(0047): af 72 fd 5c '         call    #k_load         ' load key pointed to by par_tail
32e8(0048): 47 00 68 5c '  if_z   jmp     #k_wait         ' Z set if no key available
32ec(0049): 3d 00 7c 5c '         jmp     #k_consume      ' consume and return the key
32f0(004a):             ' k_ready
32f0(004a): a8 5c fd 5c '         call    #k_setup        ' setup common values
32f4(004b): a4 00 68 5c '   if_z  jmp     #done           ' rslt == 0 if no key ready
32f8(004c): 01 dc fd a4 '         neg     rslt,#1         ' rslt == -1 if a key is ready
32fc(004d): a4 00 7c 5c '         jmp     #done
3300(004e):             ' k_clear
3300(004e): a8 5c fd 5c '         call    #k_setup        ' setup common values
3304(004f): fa de bd a0 '         mov     t0,ppkbd        ' set par_head ...
3308(0050): ef e0 3d 08 '         wrlong  t1,t0           ' .... to par_tail
330c(0051): a4 00 7c 5c '         jmp     #done
3310(0052):             ' t_geometry
3310(0052): fe dc bd a0 '         mov     rslt,scrcols    ' result is ...
3314(0053): 08 dc fd 2c '         shl     rslt,#8         ' ... cols*256 ...
3318(0054): ff dc bd 80 '         add     rslt,scrrows    ' ... plus rows
331c(0055): a4 00 7c 5c '         jmp     #done
3320(0056):             ' t_char
3320(0056): ed e8 bd a0 '         mov     t5,rqst         ' get ...
3324(0057): ff e8 fd 60 '         and     t5,#$ff         ' ... char to write
3328(0058): 0a e8 7d 86 '         cmp     t5,#$0a wz      ' translate ...
332c(0059): 5d 00 54 5c '   if_nz jmp     #:t_char_1      ' ... lf ...
3330(005a): 0d e8 fd a0 '         mov     t5,#$0d         ' ... to ...
3334(005b): c6 9c fd 5c '         call    #t_put5         ' ... cr ...
3338(005c): 0a e8 fd a0 '         mov     t5,#$0a         ' ... lf
333c(005d):             ' :t_char_1
333c(005d): c6 9c fd 5c '         call    #t_put5         ' write char to screen at cursor
3340(005e): a3 00 7c 5c '         jmp     #done_ok
3344(005f):             ' t_string 
3344(005f): e1 da bd 60 '         and     rqst,low23      ' source address is lower 23 bits of request
3348(0060):             ' :t_strloop
3348(0060): ed e8 bd 02 '         rdbyte  t5,rqst wz      ' get char to write
334c(0061): a3 00 68 5c '   if_z  jmp     #done_ok        ' finished if null byte
3350(0062): 0a e8 7d 86 '         cmp     t5,#$0a wz      ' translate ...
3354(0063): 67 00 54 5c '   if_nz jmp     #:t_str_1      ' ... lf ...
3358(0064): 0d e8 fd a0 '         mov     t5,#$0d         ' ... to ...
335c(0065): c6 9c fd 5c '         call    #t_put5         ' ... cr ...
3360(0066): 0a e8 fd a0 '         mov     t5,#$0a         ' ... lf
3364(0067):             ' :t_str_1
3364(0067): c6 9c fd 5c '         call    #t_put5         ' write char to screen
3368(0068): 01 da fd 80 '         add     rqst,#1         ' increment string pointer
336c(0069): 60 00 7c 5c '         jmp     #:t_strloop     ' put more chars
3370(006a):             ' t_int
3370(006a): c3 8a fd 5c '         call    #t_getnum       ' get number to print
3374(006b): 00 da 7d c3 '         cmps    rqst,#0 WC,WZ   ' positive?
3378(006c): 70 00 4c 5c '  if_ae  jmp     #t_uint         ' yes - no sign
337c(006d): 2d e8 fd a0 '         mov     t5,#$2d         ' no - prefix number with '-'
3380(006e): c6 9c fd 5c '         call    #t_put5         ' write char to screen at cursor
3384(006f): ed da bd ab '         abs     rqst,rqst WC,WZ ' make number positive
3388(0070):             ' t_uint
3388(0070): 87 00 68 5c '   if_z  jmp     #:t_int4        ' if zero, just print one digit
338c(0071): e3 e6 bd a0 '         mov     t4,maxdec       ' get largest possible decimal divisor
3390(0072):             ' :t_int2
3390(0072): f3 da 3d 87 '         cmp     rqst,t4 WC,WZ   ' is our number larger than that?
3394(0073): 79 00 4c 5c '  if_ae  jmp     #:t_int3        ' yes - start extracting decimal digits
3398(0074): f3 de bd a0 '         mov     t0,t4           ' no - divide divisor ...
339c(0075): 0a e0 fd a0 '         mov     t1,#10          ' ... by 10 ...
33a0(0076): d4 be fd 5c '         call    #d32u           ' ... and ...
33a4(0077): ef e6 bd a0 '         mov     t4,t0           ' ... try ...
33a8(0078): 72 00 7c 5c '         jmp     #:t_int2        ' ... again
33ac(0079):             ' :t_int3
33ac(0079): 0a e6 7d 87 '         cmp     t4,#10 WC,WZ    ' is this the last digit?
33b0(007a): 87 00 70 5c '  if_b   jmp     #:t_int4        ' yes - no need to divide any more
33b4(007b): ed de bd a0 '         mov     t0,rqst         ' no - divide number ...
33b8(007c): f3 e0 bd a0 '         mov     t1,t4           ' ... by  ...
33bc(007d): d4 be fd 5c '         call    #d32u           ' ... divisor
33c0(007e): ef e8 bd a0 '         mov     t5,t0           ' convert quotient ...
33c4(007f): 30 e8 fd 80 '         add     t5,#$30         ' ... to digit char
33c8(0080): f0 da bd a0 '         mov     rqst,t1         ' save remainder for next time
33cc(0081): c6 9c fd 5c '         call    #t_put5         ' write char to screen at cursor
33d0(0082): f3 de bd a0 '         mov     t0,t4           ' divide divisor ...
33d4(0083): 0a e0 fd a0 '         mov     t1,#10          ' ... by 10 ...
33d8(0084): d4 be fd 5c '         call    #d32u           ' ... and ...
33dc(0085): ef e6 bd a0 '         mov     t4,t0           ' ... continue ...
33e0(0086): 79 00 7c 5c '         jmp     #:t_int3        ' ... with next digit
33e4(0087):             ' :t_int4
33e4(0087): ed e8 bd a0 '         mov     t5,rqst           ' convert last decimal digit ...
33e8(0088): 30 e8 fd 80 '         add     t5,#$30         ' ... to digit char
33ec(0089): c6 9c fd 5c '         call    #t_put5         ' write char to screen
33f0(008a): a3 00 7c 5c '         jmp     #done_ok
33f4(008b):             ' t_unsigned
33f4(008b): c3 8a fd 5c '         call    #t_getnum       ' get number to print
33f8(008c): 70 00 7c 5c '         jmp     #t_uint         ' no sign, just print digits
33fc(008d):             ' t_hex
33fc(008d): c3 8a fd 5c '         call    #t_getnum       ' and get number to print
3400(008e): 08 e6 fd a0 '         mov     t4,#8           ' print 8 digits
3404(008f):             ' :t_hex1
3404(008f): 04 da fd 24 '         rol     rqst,#4         ' convert 4 bits ...
3408(0090): ed e8 bd a0 '         mov     t5,rqst         ' ... to '0' .. '9'
340c(0091): 0f e8 fd 60 '         and     t5,#$f          ' ... or ...
3410(0092): 0a e8 7d 87 '         cmp     t5,#10 wc,wz    ' ... 'A' .. 'F' ...
3414(0093): 07 e8 cd 80 '  if_ae  add     t5,#($41-$30-10)' ... depending ...
3418(0094): 30 e8 fd 80 '         add     t5,#$30         ' ... on the digit value
341c(0095): c6 9c fd 5c '         call    #t_put5         ' write char to screen
3420(0096): 8f e6 fd e4 '         djnz    t4,#:t_hex1     ' continue with next digit
3424(0097): a3 00 7c 5c '         jmp     #done_ok
3428(0098):             ' t_bin
3428(0098): c3 8a fd 5c '         call    #t_getnum       ' get number to print
342c(0099): 20 e6 fd a0 '         mov     t4,#32          ' print 32 digits
3430(009a):             ' :t_bin1
3430(009a): 01 da fd 24 '         rol     rqst,#1         ' convert bit ...
3434(009b): ed e8 bd a0 '         mov     t5,rqst         ' ... to '0' ...
3438(009c): 01 e8 fd 60 '         and     t5,#1           ' ... or ...
343c(009d): 30 e8 fd 80 '         add     t5,#$30         ' ... '1'
3440(009e): c6 9c fd 5c '         call    #t_put5         ' write char to screen
3444(009f): 9a e6 fd e4 '         djnz    t4,#:t_bin1     ' continue with next digit
3448(00a0): a3 00 7c 5c '         jmp     #done_ok
344c(00a1):             ' done_bad
344c(00a1): 01 dc fd a4 '         neg     rslt,#1         ' unknown code specified
3450(00a2): a4 00 7c 5c '         jmp     #done
3454(00a3):             ' done_ok
3454(00a3): 00 dc fd a0 '         mov      rslt,#0        ' return zero
3458(00a4):             ' done
3458(00a4): ec dc 3d 08 '         wrlong   rslt,rsltptr   ' save result
345c(00a5): 00 dc fd a0 '         mov      rslt,#0        ' indicate ...
3460(00a6): eb dc 3d 08 '         wrlong   rslt,rqstptr   ' ... request complete
3464(00a7): 07 00 7c 5c '         jmp      #loop          ' wait for next request
3468(00a8):             ' k_setup
3468(00a8): fa de bd a0 '         mov     t0,ppkbd        ' get ...
346c(00a9): ef e2 bd 08 '         rdlong  t2,t0           ' ... par_head
3470(00aa): 04 de fd 80 '         add     t0,#4           ' get ...
3474(00ab): ef e0 bd 08 '         rdlong  t1,t0           ' ... par_tail
3478(00ac): f0 dc bd a0 '         mov     rslt,t1         ' set Z flag ...
347c(00ad): f1 dc bd 86 '         sub     rslt,t2 wz      ' ... and rslt = 0 if par_tail == par_head
3480(00ae):             ' k_setup_ret
3480(00ae): 00 00 7c 5c '         ret
3484(00af):             ' k_load
3484(00af): a8 5c fd 5c '         call    #k_setup        ' setup common values
3488(00b0): b9 00 68 5c '  if_z   jmp     #k_load_ret     ' Z flag set if no key available
348c(00b1): 10 de fd 80 '         add     t0,#16          ' get ...
3490(00b2): ef de bd 08 '         rdlong  t0,t0           ' ... bufaddr
3494(00b3): ef dc bd a0 '         mov     rslt,t0         ' load key ...
3498(00b4): f0 dc bd 80 '         add     rslt,t1         ' ... indicated ...
349c(00b5): ee dc bd 00 '         rdbyte  rslt,rslt       ' ... by par_tail
34a0(00b6): 04 dc 7d 86 '         cmp     rslt,#$04 wz    ' EOT?
34a4(00b7): 01 dc e9 a4 '  if_z   neg     rslt,#1         ' if so, return -1 (EOF)
34a8(00b8): 01 de fd a2 '         mov     t0,#1 wz        ' ensure Z flag not set!
34ac(00b9):             ' k_load_ret
34ac(00b9): 00 00 7c 5c '         ret
34b0(00ba):             ' t_setup
34b0(00ba): fd de bd a0 '         mov     t0,pptv         ' get ...
34b4(00bb): ef e2 bd 08 '         rdlong  t2,t0           ' ... tx_head
34b8(00bc): 04 de fd 80 '         add     t0,#4           ' get ...
34bc(00bd): ef e0 bd 08 '         rdlong  t1,t0           ' ... tx_tail
34c0(00be): f1 e4 bd a0 '         mov     t3,t2           ' set Z flag ...
34c4(00bf): 01 e4 fd 80 '         add     t3,#1           ' ... if ...
34c8(00c0): ff e5 fd 60 '         and     t3,#$1ff        ' ... tx_tail 
34cc(00c1): f2 e0 3d 86 '         cmp     t1,t3 wz        ' ... == (tx_head + 1) & $1ff
34d0(00c2):             ' t_setup_ret
34d0(00c2): 00 00 7c 5c '         ret
34d4(00c3):             ' t_getnum
34d4(00c3): e1 da bd 60 '         and     rqst,low23      ' source address is lower 23 bits of request
34d8(00c4): ed da bd 0a '         rdlong  rqst,rqst wz    ' get the actual number in the rquest
34dc(00c5):             ' t_getnum_ret                                
34dc(00c5): 00 00 7c 5c '         ret
34e0(00c6):             ' t_put5
34e0(00c6): ba 84 fd 5c '         call    #t_setup        ' setup common values
34e4(00c7): c6 00 68 5c '  if_z   jmp     #t_put5         ' repeat until (tx_tail <> (tx_head + 1) & $1FF)
34e8(00c8): 0c de fd 80 '         add     t0,#12          ' txbuffer...
34ec(00c9): ef de bd 08 '         rdlong  t0,t0           ' ...
34f0(00ca): f1 de bd 80 '         add     t0,t2           ' ... [tx_head] ...
34f4(00cb): ef e8 3d 00 '         wrbyte  t5,t0           ' ... := t5
34f8(00cc): fd de bd a0 '         mov     t0,pptv         ' tx_head ...
34fc(00cd): ef e4 3d 08 '         wrlong  t3,t0           ' ... := (tx_head + 1) & $1FF
3500(00ce):             ' t_put5_ret
3500(00ce): 00 00 7c 5c '         ret
3504(00cf):             ' m32
3504(00cf): 00 de fd a0 '         mov t0,#0
3508(00d0): d3 e2 7d ec '         tjz t2,#m32_ret
350c(00d1):             ' :m32_loop
350c(00d1): f0 de bd 80 '         add t0,t1
3510(00d2): d1 e2 fd e4 '         djnz t2,#:m32_loop
3514(00d3):             ' m32_ret
3514(00d3): 00 00 7c 5c '         ret
3518(00d4):             ' d32u
3518(00d4): 20 f0 fd a0 '         mov d1,#32
351c(00d5): 00 f2 fd a0 '         mov d2, #0
3520(00d6):             ' :d32up
3520(00d6): 01 de fd 2d '         shl t0,#1    WC
3524(00d7): 01 f2 fd 35 '         rcl d2,#1    WC
3528(00d8): f9 e0 3d 87 '         cmp t1,d2    WC,WZ
352c(00d9): dc 00 44 5c '  if_a   jmp #:d32down
3530(00da): f0 f2 bd 84 '         sub d2,t1
3534(00db): 01 de fd 80 '         add t0,#1
3538(00dc):             ' :d32down
3538(00dc): 01 f0 fd 86 '         sub d1, #1   WZ
353c(00dd): d6 00 54 5c '  if_ne  jmp #:d32up
3540(00de): f9 e0 bd a0 '         mov t1,d2
3544(00df):             ' d32u_ret
3544(00df): 00 00 7c 5c '         ret
3548(00e0): 00 00 80 00 ' curs_1  long     $00800000
354c(00e1): ff ff 7f 00 ' low23   long     $007FFFFF
3550(00e2): ff ff ff 00 ' low24   long     $00ffffff
3554(00e3): 00 ca 9a 3b ' maxdec  long     1000000000     ' maximum decimal divisor for 32 bit values
3558(00e4): 00 02 00 00 ' ctrl    long     $00000200      ' mask to detect control keys
355c(00e5): 00 fd ff ff ' noctrl  long     $fffffd00      ' mask to correct control keys
3560(00e6): 20 02 00 00 ' space   long     $00000220      ' space used when filling
3564(00e7): 00 00 00 00 ' lastcur long     $0
3568(00e8): 00 00 00 00 ' kstat   long     $0
356c(00e9): 00 02 00 00 ' hex200  long     $200
3570(00ea): 32 03 00 00 ' c_snail long     $332           ' control snail should return NUL 
3574(00eb):             ' rqstptr res      1      ' address of my request block
3574(00ec):             ' rsltptr res      1      ' address to put results
3574(00ed):             ' rqst    res      1      ' request being processed
3574(00ee):             ' rslt    res      1      ' result to return
3574(00ef):             ' t0      res      1
3574(00f0):             ' t1      res      1
3574(00f1):             ' t2      res      1
3574(00f2):             ' t3      res      1
3574(00f3):             ' t4      res      1
3574(00f4):             ' t5      res      1
3574(00f5):             ' t6      res      1
3574(00f6):             ' t7      res      1
3574(00f7):             ' t8      res      1
3574(00f8):             ' d1      res      1      ' used when dividing
3574(00f9):             ' d2      res      1      ' used when dividing
3574(00fa):             ' ppkbd   res      1
3574(00fb):             ' ppmouse res      1
3574(00fc):             ' ppscrn  res      1
3574(00fd):             ' pptv    res      1
3574(00fe):             ' scrcols res      1      ' screen cols
3574(00ff):             ' scrrows res      1      ' screen rows
3574(0100):             ' scrsize res      1      ' screen size
3574(0101):             ' scrbuff res      1      ' pointer to screen buffer
3574(0102):             ' scrclrs res      1      ' current color data
3574(0103):             ' scrpall res      1      ' pointer to screen palette
3574(0104):             ' scrcurs res      1      ' pointer to screen cursors
'========================= Method #1: PUB ProxySetup ==========================
'PUB ProxySetup(io_block, proxy_lock, server_cpu)
'------------------------------------------------------------------------------
  v_io_block     := io_block
'------------------------------------------------------------------------------
3574: 64             PUSH 	Locals+4
3575: 41             POP  	VAR+0
'------------------------------------------------------------------------------
  v_proxy_lock   := proxy_lock
'------------------------------------------------------------------------------
3576: 68             PUSH 	Locals+8
3577: 45             POP  	VAR+4
'------------------------------------------------------------------------------
  v_Server_cpu   := server_cpu
'------------------------------------------------------------------------------
3578: 6c             PUSH 	Locals+12
3579: 49             POP  	VAR+8
357a: 32             RETURN	
'=========================== Method #2: PUB Start =============================
'PUB Start (registry, data, start_kbd, start_mouse, start_screen) : ok | prqst, pkbd, pmouse, pscreen, ptv, px_pkbd, px_pmouse, px_pscreen, px_ptv, px_ioblk, px_lock, px_cpu, cog
'------------------------------------------------------------------------------
  pkbd    := data
'------------------------------------------------------------------------------
357b: 68             PUSH 	Locals+8
357c: 7d             POP  	Locals+28
'------------------------------------------------------------------------------
  pmouse  := 0  
'------------------------------------------------------------------------------
357d: 35             PUSH#0	
357e: cd 20          POP.L	Locals+32
'------------------------------------------------------------------------------
  pscreen := pkbd    + 4 * kbd#kb_count  
'------------------------------------------------------------------------------
3580: 7c             PUSH 	Locals+28
3581: 37 01          PUSH#kp	4 ($4)
3583: 38 0a          PUSH#k1	10
3585: f4             MPY  	
3586: ec             ADD  	
3587: cd 24          POP.L	Locals+36
'------------------------------------------------------------------------------
  ptv     := pscreen + 4 * sc_count 
'------------------------------------------------------------------------------
3589: cc 24          PUSH.L	Locals+36
358b: 37 01          PUSH#kp	4 ($4)
358d: 39 01 19       PUSH#k2	281
3590: f4             MPY  	
3591: ec             ADD  	
3592: cd 28          POP.L	Locals+40
'------------------------------------------------------------------------------
  long[pscreen][nx] := cols
'------------------------------------------------------------------------------
3594: 38 28          PUSH#k1	40
3596: cc 24          PUSH.L	Locals+36
3598: 35             PUSH#0	
3599: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[pscreen][ny] := rows
'------------------------------------------------------------------------------
359a: 38 0d          PUSH#k1	13
359c: cc 24          PUSH.L	Locals+36
359e: 36             PUSH#1	
359f: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  if start_kbd
'------------------------------------------------------------------------------
35a0: 6c             PUSH 	Locals+12
35a1: 0a 07          JPF  	.+7 (dest:$35aa)
'------------------------------------------------------------------------------
    kbd.start(pkbd, common#SI_PIN)
'------------------------------------------------------------------------------
35a3: 01             FRAME	Call without return value	
35a4: 7c             PUSH 	Locals+28
35a5: 37 24          PUSH#kp	31 ($1f)
35a7: 06 03 01       CALLOBJ	3:1
'------------------------------------------------------------------------------
  px_pkbd := 0
'------------------------------------------------------------------------------
35aa: 35             PUSH#0	
35ab: cd 2c          POP.L	Locals+44
'------------------------------------------------------------------------------
  if start_screen
'------------------------------------------------------------------------------
35ad: 74             PUSH 	Locals+20
35ae: 0a 0d          JPF  	.+13 (dest:$35bd)
'------------------------------------------------------------------------------
    screen.start(ptv, common#SO_PIN, @long[pscreen][buffer])
'------------------------------------------------------------------------------
35b0: 01             FRAME	Call without return value	
35b1: cc 28          PUSH.L	Locals+40
35b3: 38 1e          PUSH#k1	30
35b5: cc 24          PUSH.L	Locals+36
35b7: 37 21          PUSH#kp	3 ($3)
35b9: d3             PUSH#.L	Mem[][]
35ba: 06 04 01       CALLOBJ	4:1
'------------------------------------------------------------------------------
  px_pscreen := 0
'------------------------------------------------------------------------------
35bd: 35             PUSH#0	
35be: cd 34          POP.L	Locals+52
'------------------------------------------------------------------------------
  cog := cognew(@HmiStart, registry)
'------------------------------------------------------------------------------
35c0: 34             PUSH#-1	
35c1: c7 18          PUSH#.L	OBJ+24
35c3: 64             PUSH 	Locals+4
35c4: 28             COGIFUN	
35c5: cd 48          POP.L	Locals+72
'------------------------------------------------------------------------------
  ok := (cog => 0)
'------------------------------------------------------------------------------
35c7: cc 48          PUSH.L	Locals+72
35c9: 35             PUSH#0	
35ca: fe             GE   	
35cb: 61             POP  	Locals+0
'------------------------------------------------------------------------------
  if ok
'------------------------------------------------------------------------------
35cc: 60             PUSH 	Locals+0
35cd: 0a 15          JPF  	.+21 (dest:$35e4)
'------------------------------------------------------------------------------
    common.SendInitializationData(cog, @pkbd, 0)
'------------------------------------------------------------------------------
35cf: 01             FRAME	Call without return value	
35d0: cc 48          PUSH.L	Locals+72
35d2: 7f             PUSH#	Locals+28
35d3: 35             PUSH#0	
35d4: 06 05 04       CALLOBJ	5:4
'------------------------------------------------------------------------------
    common.WaitForRequest(cog)
'------------------------------------------------------------------------------
35d7: 01             FRAME	Call without return value	
35d8: cc 48          PUSH.L	Locals+72
35da: 06 05 05       CALLOBJ	5:5
'------------------------------------------------------------------------------
    common.Register(cog, common#LMM_HMI)
'------------------------------------------------------------------------------
35dd: 01             FRAME	Call without return value	
35de: cc 48          PUSH.L	Locals+72
35e0: 36             PUSH#1	
35e1: 06 05 02       CALLOBJ	5:2
35e4: 32             RETURN	
35e5: 00 00 00    

'******************************************************************************
'                          Catalina_PC_Keyboard.spin                           
'******************************************************************************

'=================================== CONs =====================================
BAUDRATE = 115200
RXINVERSE = 0
kb_count = 10
rx_pin = 2
rx_mode = 3
rx_ticks = 4
rx_bufptr = 5
rx_buffer = 6
'=============================== Object Header ================================
35e8: f8 00 02 01 ' 248 bytes, 2-1 methods, 1 object pointers
35ec: c4 00 00 00 ' ptr #1 to $36ac: PUB start (locals size: 0)
35f0: c0 01 00 00 ' ptr #2 to $37a8: OBJ Common : Catalina_Common.spin (VAR offset: 0)
'================================ DAT Section =================================
35f4(0000):             '                         org     0
35f4(0000): f0 5d bc a0 ' entry                   mov     t1,par                'get structure address
35f8(0001): 08 5c fc 80 '                         add     t1,#2 << 2            'skip past heads and tails
35fc(0002): 2e 5e bc 08 '                         rdlong  t2,t1                 'get rx_pin
3600(0003): 01 64 fc a0 '                         mov     rxmask,#1
3604(0004): 2f 64 bc 2c '                         shl     rxmask,t2
3608(0005): 04 5c fc 80 '                         add     t1,#4                 'get rx_mode
360c(0006): 2e 60 bc 08 '                         rdlong  rxmode,t1
3610(0007): 04 5c fc 80 '                         add     t1,#4                 'get bit_ticks
3614(0008): 2e 62 bc 08 '                         rdlong  bitticks,t1
3618(0009): 04 5c fc 80 '                         add     t1,#4                 'get buffer_ptr
361c(000a): 2e 66 bc 08 '                         rdlong  rxbuff,t1
3620(000b): 01 60 7c 62 ' receive                 test    rxmode,#%001    wz    'wait for start bit on rx pin
3624(000c): f2 65 3c 61 '                         test    rxmask,ina      wc
3628(000d): 0b 00 64 5c '         if_z_eq_c       jmp     #receive
362c(000e): 09 6a fc a0 '                         mov     rxbits,#9             'ready to receive byte
3630(000f): 31 6c bc a0 '                         mov     rxcnt,bitticks
3634(0010): 01 6c fc 28 '                         shr     rxcnt,#1
3638(0011): f1 6d bc 80 '                         add     rxcnt,cnt                          
363c(0012): 31 6c bc 80 ' :bit                    add     rxcnt,bitticks        'ready next bit period
3640(0013): 36 5c bc a0 ' :wait                   mov     t1,rxcnt              'check if bit receive period done
3644(0014): f1 5d bc 84 '                         sub     t1,cnt
3648(0015): 00 5c 7c c1 '                         cmps    t1,#0           wc
364c(0016): 13 00 4c 5c '         if_nc           jmp     #:wait
3650(0017): f2 65 3c 61 '                         test    rxmask,ina      wc    'receive bit on rx pin
3654(0018): 01 68 fc 30 '                         rcr     rxdata,#1
3658(0019): 12 6a fc e4 '                         djnz    rxbits,#:bit
365c(001a): 17 68 fc 28 '                         shr     rxdata,#32-9          'justify and trim received byte
3660(001b): ff 68 fc 60 '                         and     rxdata,#$FF
3664(001c): 01 60 7c 62 '                         test    rxmode,#%001    wz    'if rx inverted, invert byte
3668(001d): ff 68 d4 6c '         if_nz           xor     rxdata,#$FF
366c(001e): 00 5a 7c 86 '                         cmp     mscnt,#0        wz     'mouse receiving?
3670(001f): 23 00 54 5c '         if_nz           jmp     #getMsPar
3674(0020): 05 68 7c 86 '                         cmp     rxdata,#5      wz     'new mouse Event?
3678(0021): 25 00 54 5c '         if_nz           jmp     #toRxBuff             'no: write in buffer
367c(0022): 04 5a fc a0 '                         mov     mscnt,#4              '4 bytes to ignore
3680(0023): 01 5a fc 84 ' getMsPar                sub     mscnt,#1              'ignore byte
3684(0024): 0b 00 7c 5c '                         jmp     #receive
3688(0025): f0 5f bc 08 ' toRxBuff                rdlong  t2,par                'save received byte and inc head
368c(0026): 33 5e bc 80 '                         add     t2,rxbuff
3690(0027): 2f 68 3c 00 '                         wrbyte  rxdata,t2
3694(0028): 33 5e bc 84 '                         sub     t2,rxbuff
3698(0029): 01 5e fc 80 '                         add     t2,#1
369c(002a): 0f 5e fc 60 '                         and     t2,#$0F
36a0(002b): f0 5f 3c 08 '                         wrlong  t2,par
36a4(002c): 0b 00 7c 5c '                         jmp     #receive
36a8(002d): 00 00 00 00 ' mscnt                   long    0
36ac(002e):             ' t1                      res     1
36ac(002f):             ' t2                      res     1
36ac(0030):             ' rxmode                  res     1
36ac(0031):             ' bitticks                res     1
36ac(0032):             ' rxmask                  res     1
36ac(0033):             ' rxbuff                  res     1
36ac(0034):             ' rxdata                  res     1
36ac(0035):             ' rxbits                  res     1
36ac(0036):             ' rxcnt                   res     1
36ac(0037):             ' rxcode                  res     1
'=========================== Method #1: PUB start =============================
'PUB start(kb_block, basepin) : okay
'------------------------------------------------------------------------------
  longfill(kb_block, 0, kb_count)
'------------------------------------------------------------------------------
36ac: 64             PUSH 	Locals+4
36ad: 35             PUSH#0	
36ae: 38 0a          PUSH#k1	10
36b0: 1a             LONGFIL	
'------------------------------------------------------------------------------
  long[kb_block][rx_pin]    := basepin
'------------------------------------------------------------------------------
36b1: 68             PUSH 	Locals+8
36b2: 64             PUSH 	Locals+4
36b3: 37 00          PUSH#kp	2 ($2)
36b5: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[kb_block][rx_mode]   := RXINVERSE
'------------------------------------------------------------------------------
36b6: 35             PUSH#0	
36b7: 64             PUSH 	Locals+4
36b8: 37 21          PUSH#kp	3 ($3)
36ba: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[kb_block][rx_ticks]  := Common#CLOCKFREQ / BAUDRATE
'------------------------------------------------------------------------------
36bb: 3b 04 c4 b4 00 PUSH#k4	80000000
36c0: 3a 01 c2 00    PUSH#k3	115200
36c4: f6             DIV  	
36c5: 64             PUSH 	Locals+4
36c6: 37 01          PUSH#kp	4 ($4)
36c8: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[kb_block][rx_bufptr] := kb_block + rx_buffer*4 
'------------------------------------------------------------------------------
36c9: 64             PUSH 	Locals+4
36ca: 38 06          PUSH#k1	6
36cc: 37 01          PUSH#kp	4 ($4)
36ce: f4             MPY  	
36cf: ec             ADD  	
36d0: 64             PUSH 	Locals+4
36d1: 38 05          PUSH#k1	5
36d3: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  okay := cognew(@entry, kb_block) + 1
'------------------------------------------------------------------------------
36d4: 34             PUSH#-1	
36d5: c7 0c          PUSH#.L	OBJ+12
36d7: 64             PUSH 	Locals+4
36d8: 28             COGIFUN	
36d9: 36             PUSH#1	
36da: ec             ADD  	
36db: 61             POP  	Locals+0
36dc: 32             RETURN	
36dd: 00 00 00    

'******************************************************************************
'                            Catalina_PC_Text.spin                             
'******************************************************************************

'=================================== CONs =====================================
BAUDRATE = 115200
cols = 40
rows = 13
tv_count = 5
tx_pin = 2
tx_ticks = 3
tx_buffer = 4
'=============================== Object Header ================================
36e0: c8 00 02 01 ' 200 bytes, 2-1 methods, 1 object pointers
36e4: a0 00 00 00 ' ptr #1 to $3780: PUB start (locals size: 0)
36e8: c8 00 00 00 ' ptr #2 to $37a8: OBJ Common : Catalina_Common.spin (VAR offset: 0)
'================================ DAT Section =================================
36ec(0000):             '                         org     0
36ec(0000): f0 4b bc a0 ' entry                   mov     t1,par                'get structure address
36f0(0001): 08 4a fc 80 '                         add     t1,#2 << 2            'skip past heads and tails
36f4(0002): 25 4c bc 08 '                         rdlong  t2,t1                 'get tx_pin
36f8(0003): 01 54 fc a0 '                         mov     txmask,#1
36fc(0004): 26 54 bc 2c '                         shl     txmask,t2 
3700(0005): 2a e8 bf 68 '                         or      outa,txmask           'idle = 1  
3704(0006): 2a ec bf 68 '                         or      dira,txmask           'Pin30 = output
3708(0007): 04 4a fc 80 '                         add     t1,#4                 'get bit_ticks
370c(0008): 25 52 bc 08 '                         rdlong  bittime,t1
3710(0009): 04 4a fc 80 '                         add     t1,#4                 'get buffer_ptr
3714(000a): 25 5a bc 08 '                         rdlong  txbuff,t1
3718(000b): f0 4b bc a0 ' transmit                mov     t1,par                'check for head <> tail
371c(000c): 25 4c bc 08 '                         rdlong  t2,t1
3720(000d): 04 4a fc 80 '                         add     t1,#1 << 2
3724(000e): 25 4e bc 08 '                         rdlong  t3,t1
3728(000f): 27 4c 3c 86 '                         cmp     t2,t3           wz
372c(0010): 0b 00 68 5c '         if_z            jmp     #transmit
3730(0011): 2d 4e bc 80 ' sendloop                add     t3,txbuff             'get byte and inc tail
3734(0012): 27 56 bc 00 '                         rdbyte  txdata,t3
3738(0013): 2d 4e bc 84 '                         sub     t3,txbuff
373c(0014): 01 4e fc 80 '                         add     t3,#1
3740(0015): ff 4f fc 60 '                         and     t3,#$1FF
3744(0016): 25 4e 3c 08 '                         wrlong  t3,t1
3748(0017): 0a 58 fc a0 '                         mov     txcnt,#10
374c(0018): 00 57 fc 68 '                         or      txdata,#$100          'add stoppbit
3750(0019): 01 56 fc 2c '                         shl     txdata,#1             'add startbit
3754(001a): f1 51 bc a0 '                         mov     dtime,cnt
3758(001b): 29 50 bc 80 '                         add     dtime,bittime
375c(001c): 01 56 fc 29 ' sendbit                 shr     txdata,#1    wc       'test LSB
3760(001d): f4 4d bc a0 '                         mov     t2,outa
3764(001e): 2a 4c 8c 64 '               if_nc     andn    t2,txmask             'bit=0  or
3768(001f): 2a 4c b0 68 '               if_c      or      t2,txmask             'bit=1
376c(0020): 26 e8 bf a0 '                         mov     outa,t2
3770(0021): 29 50 bc f8 '                         waitcnt dtime,bittime         'wait 1 bit
3774(0022): 1c 58 fc e4 '                         djnz    txcnt,#sendbit        '10 times
3778(0023): 29 50 bc f8 '                         waitcnt dtime,bittime         '2 stopbits
377c(0024): 0b 00 7c 5c '                         jmp     #transmit             'done,wait for next
3780(0025):             ' t1                      res     1
3780(0026):             ' t2                      res     1
3780(0027):             ' t3                      res     1
3780(0028):             ' dtime                   res     1
3780(0029):             ' bittime                 res     1
3780(002a):             ' txmask                  res     1
3780(002b):             ' txdata                  res     1
3780(002c):             ' txcnt                   res     1
3780(002d):             ' txbuff                  res     1
'=========================== Method #1: PUB start =============================
'PUB start(tv_block, basepin, buffer) : okay
'------------------------------------------------------------------------------
  longfill(tv_block, 0, tv_count)
'------------------------------------------------------------------------------
3780: 64             PUSH 	Locals+4
3781: 35             PUSH#0	
3782: 38 05          PUSH#k1	5
3784: 1a             LONGFIL	
'------------------------------------------------------------------------------
  long[tv_block][tx_pin] := basepin
'------------------------------------------------------------------------------
3785: 68             PUSH 	Locals+8
3786: 64             PUSH 	Locals+4
3787: 37 00          PUSH#kp	2 ($2)
3789: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[tv_block][tx_ticks]:= Common#CLOCKFREQ / BAUDRATE
'------------------------------------------------------------------------------
378a: 3b 04 c4 b4 00 PUSH#k4	80000000
378f: 3a 01 c2 00    PUSH#k3	115200
3793: f6             DIV  	
3794: 64             PUSH 	Locals+4
3795: 37 21          PUSH#kp	3 ($3)
3797: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[tv_block][tx_buffer] := buffer
'------------------------------------------------------------------------------
3798: 6c             PUSH 	Locals+12
3799: 64             PUSH 	Locals+4
379a: 37 01          PUSH#kp	4 ($4)
379c: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  okay := cognew(@entry, tv_block) + 1 
'------------------------------------------------------------------------------
379d: 34             PUSH#-1	
379e: c7 0c          PUSH#.L	OBJ+12
37a0: 64             PUSH 	Locals+4
37a1: 28             COGIFUN	
37a2: 36             PUSH#1	
37a3: ec             ADD  	
37a4: 61             POP  	Locals+0
37a5: 32             RETURN	
37a6: 00 00       

'******************************************************************************
'                            Catalina_Common.spin                              
'******************************************************************************

'=================================== CONs =====================================
SI_PIN = 31
SO_PIN = 30
CLOCKMODE = 1032
XTALFREQ = 5000000
CLOCKFREQ = 80000000
STACKSIZE = 50
LMM_HMI = 1
COGSTORE = 32508
REGISTRY_END = 32508
REGISTRY = 32476
REQUESTS = 32412
ARGC_ADDR = 32560
ARGV_ADDR = 32562
ARGV_0 = 32564
ARGV_MAX = 32
'=============================== Object Header ================================
37a8: 88 00 06 00 ' 136 bytes, 6-1 methods, 0 object pointers
37ac: 18 00 04 00 ' ptr #1 to $37c0: PUB InitializeRegistry (locals size: 4)
37b0: 42 00 00 00 ' ptr #2 to $37ea: PUB Register (locals size: 0)
37b4: 55 00 00 00 ' ptr #3 to $37fd: PUB UnRegister (locals size: 0)
37b8: 63 00 00 00 ' ptr #4 to $380b: PUB SendInitializationData (locals size: 0)
37bc: 78 00 00 00 ' ptr #5 to $3820: PUB WaitForRequest (locals size: 0)
'===================== Method #1: PUB InitializeRegistry ======================
'PUB InitializeRegistry | i
'------------------------------------------------------------------------------
  repeat i from 0 to 7
'------------------------------------------------------------------------------
37c0: 35             PUSH#0	
37c1: 65             POP  	Locals+4
'------------------------------------------------------------------------------
    long[REGISTRY][i] := REQUESTS + (8*i)
'------------------------------------------------------------------------------
37c2: 39 7e 9c       PUSH#k2	32412
37c5: 37 02          PUSH#kp	8 ($8)
37c7: 64             PUSH 	Locals+4
37c8: f4             MPY  	
37c9: ec             ADD  	
37ca: 39 7e dc       PUSH#k2	32476
37cd: 64             PUSH 	Locals+4
37ce: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
    long[REQUESTS][2 * i] := 0
'------------------------------------------------------------------------------
37cf: 35             PUSH#0	
37d0: 39 7e 9c       PUSH#k2	32412
37d3: 37 00          PUSH#kp	2 ($2)
37d5: 64             PUSH 	Locals+4
37d6: f4             MPY  	
37d7: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
    long[REQUESTS][2 * i + 1] := 0
'------------------------------------------------------------------------------
37d8: 35             PUSH#0	
37d9: 39 7e 9c       PUSH#k2	32412
37dc: 37 00          PUSH#kp	2 ($2)
37de: 64             PUSH 	Locals+4
37df: f4             MPY  	
37e0: 36             PUSH#1	
37e1: ec             ADD  	
37e2: d1             POP.L	Mem[][]
37e3: 35             PUSH#0	
37e4: 37 22          PUSH#kp	7 ($7)
37e6: 66 02 59       USING	Locals+4, RPTINCJ .-39 (dest:$37c2)
37e9: 32             RETURN	
'========================== Method #2: PUB Register ===========================
'PUB Register (my_cog, my_plugin_type)
'------------------------------------------------------------------------------
  long[REGISTRY][my_cog] := (my_plugin_type<<24) + (long[REGISTRY][my_cog] & $00FFFFFF)
'------------------------------------------------------------------------------
37ea: 68             PUSH 	Locals+8
37eb: 38 18          PUSH#k1	24
37ed: e3             SHL  	
37ee: 39 7e dc       PUSH#k2	32476
37f1: 64             PUSH 	Locals+4
37f2: d0             PUSH.L	Mem[][]
37f3: 37 37          PUSH#kp	16777215 ($ffffff)
37f5: e8             BIT_AND	
37f6: ec             ADD  	
37f7: 39 7e dc       PUSH#k2	32476
37fa: 64             PUSH 	Locals+4
37fb: d1             POP.L	Mem[][]
37fc: 32             RETURN	
'========================= Method #3: PUB UnRegister ==========================
'PUB UnRegister (my_cog)
'------------------------------------------------------------------------------
  long[REGISTRY][my_cog] := (long[REGISTRY][my_cog] & $00FFFFFF)
'------------------------------------------------------------------------------
37fd: 39 7e dc       PUSH#k2	32476
3800: 64             PUSH 	Locals+4
3801: d0             PUSH.L	Mem[][]
3802: 37 37          PUSH#kp	16777215 ($ffffff)
3804: e8             BIT_AND	
3805: 39 7e dc       PUSH#k2	32476
3808: 64             PUSH 	Locals+4
3809: d1             POP.L	Mem[][]
380a: 32             RETURN	
'=================== Method #4: PUB SendInitializationData ====================
'PUB SendInitializationData(to_cog, data_1, data_2)
'------------------------------------------------------------------------------
  long[REQUESTS][2 * to_cog + 1] := data_2
'------------------------------------------------------------------------------
380b: 6c             PUSH 	Locals+12
380c: 39 7e 9c       PUSH#k2	32412
380f: 37 00          PUSH#kp	2 ($2)
3811: 64             PUSH 	Locals+4
3812: f4             MPY  	
3813: 36             PUSH#1	
3814: ec             ADD  	
3815: d1             POP.L	Mem[][]
'------------------------------------------------------------------------------
  long[REQUESTS][2 * to_cog]     := data_1
'------------------------------------------------------------------------------
3816: 68             PUSH 	Locals+8
3817: 39 7e 9c       PUSH#k2	32412
381a: 37 00          PUSH#kp	2 ($2)
381c: 64             PUSH 	Locals+4
381d: f4             MPY  	
381e: d1             POP.L	Mem[][]
381f: 32             RETURN	
'======================= Method #5: PUB WaitForRequest ========================
'PUB WaitForRequest(to_cog)
'------------------------------------------------------------------------------
  repeat while long[REQUESTS][2 * to_cog] <> 0
'------------------------------------------------------------------------------
3820: 39 7e 9c       PUSH#k2	32412
3823: 37 00          PUSH#kp	2 ($2)
3825: 64             PUSH 	Locals+4
3826: f4             MPY  	
3827: d0             PUSH.L	Mem[][]
3828: 35             PUSH#0	
3829: fb             NE   	
382a: 0a 02          JPF  	.+2 (dest:$382e)
382c: 04 72          GOTO 	.-14 (dest:$3820)
382e: 32             RETURN	
382f: 00          
3830: 00 00 00 00             ' LONG HMI.v_io_block
3834: 00 00 00 00             ' LONG HMI.v_proxy_lock
3838: 00 00 00 00             ' LONG HMI.v_server_cpu
383c: ff ff f9 ff ff ff f9 ff 

